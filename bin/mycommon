#!/usr/bin/env bash

test -f ${XDG_CONFIG_HOME:-~/.config}/user-dirs.dirs && source ${XDG_CONFIG_HOME:-~/.config}/user-dirs.dirs

# Find and/or create path for logging
function doLogPath() {
    local fpPath="/var/log"
    [ ! -w "$fpPath" ] && fpPath="$HOME/.local/var/log" ;
    [ ! -d "$fpPath" ] && mkdir -p $fpPath ;
    if [ ! -d "$fpPath" ]; then
        echo ""
        return 1
    fi
    echo "$fpPath"
    return 0
}

# Script name that is sourcing this
myLogScriptName="${0##*/}"
myLogSctiptBase="${myLogScriptName%%.*}"

# Find a path to Log file
myLogPath=$(doLogPath)
myLogFile="$myLogPath/$myLogSctiptBase.log"

# Print the given message with a timestamp.
function info() { printf '%s %s\n' "$(date +%F_%H:%M:%S | tr '_' ' ') $HOSTNAME" "$*"; }

# Standard log file
function log() {
    local LOCK_rc=0
    if [ ! -f "$myLogFile" ]; then
        touch "$myLogFile"
        LOCK_rc=$?
    fi
    if [[ $LOCK_rc -eq 0 && -f "$myLogFile" ]]; then
        info >>"$myLogFile" "$@"
    else
        info "$@"
    fi
}

# direct it all to /dev/null
function nullify() {
    "$@" >/dev/null 2>&1
}

# Rsync copy w/ progress
function rsyncp_p () {
    rsync -WavP --human-readable --progress $1 $2
}

# Check for a git repo in that location
function is_git_repository() {
    [ "$(git rev-parse &>/dev/null; printf $?)" -eq 0 ] && return 0 || return 1
}

# Trim leading and tailing spaces
# Usage: trim_string "   example   string    "
function trim_string() {
    : "${1#"${1%%[![:space:]]*}"}"
    : "${_%"${_##*[![:space:]]}"}"
    printf '%s\n' "$_"
}

# Usage: say text [delayAfterText]
function say() {
    fold -s -w 76 <<< "$1" | sed 's/^/  /' # wraps text nicely and adds two leading spaces
    snore "${2-0}"
}

# Adapted from Addy
# 'battery_stt -i' = with icon, 'battery' = text only
function battery_stt(){
    local BATTERY=0
    local BATTERY_INFO=$(acpi -b | grep "Battery ${BATTERY}")
    local BATTERY_STATE=$(echo "${BATTERY_INFO}" | grep -wo "Full\|Charging\|Discharging")
    local BATTERY_POWER=$(echo "${BATTERY_INFO}" | grep -o '[0-9]\+%' | tr -d '%')
    
    if [[ "${BATTERY_STATE}" = "Charging" ]]; then
        if  [[ $1 = "-i" ]]; then
            echo "  ${BATTERY_POWER}%+"
        else
            echo "${BATTERY_POWER}%+"
        fi
    elif [[ "${BATTERY_STATE}" = "Discharging" ]]; then
        if  [[ $1 = "-i" ]]; then
            echo "  ${BATTERY_POWER}%-"
        else
            echo "${BATTERY_POWER}%-"
        fi
    else
        if  [[ $1 = "-i" ]]; then
            echo "  ${BATTERY_POWER}%"
        else
            echo "${BATTERY_POWER}%"
        fi
    fi
}

# ps with ISO date format
function ps_ISO(){
    if [ -z "$1" ]; then
        ps -eo etimes,ruser,pid,cmd --sort=start_time | \
            awk 'BEGIN{now=systime()} {$1=strftime("%Y-%m-%d-%H:%M:%S", now-$1); print $0}' | grep -v "grep" | grep -v "awk"
    else
        ps -eo etimes,ruser,pid,cmd --sort=start_time | \
            awk 'BEGIN{now=systime()} {$1=strftime("%Y-%m-%d-%H:%M:%S", now-$1); print $0}' | grep -v "grep" | grep -v "awk" | grep "$1"
    fi
}

# Kill older instances of itself
function kill_older(){
    local s_name="${0##*/}"
    local my_pid=$$
    snore 0.3
    for i in $(ps_ISO "$s_name" | grep "$USER" | grep -P "bash" | grep -v "grep" | awk '{print $3}'); do 
        if [ "$i" != "$my_pid" ]; then
            log "Older instances found: pid=$i  name=$s_name "
            kill "$i" &>/dev/null || true
        fi
    done
    return 0
}

# Return 0 if user in the active session can issue power related commands via policykit
function auth_user() {
    [ $(loginctl show-session $XDG_SESSION_ID --property=Active | grep "yes") ] && return 0
    return 1
}

function can_hibernate() {
    [ $(qdbus --system org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.CanHibernate | grep "yes") ] && return 0
    return 1
}

function can_poweroff() {
    [ $(qdbus --system org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.CanPowerOff | grep "yes") ] && return 0
    return 1
}

function can_reboot() {
    [ $(qdbus --system org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.CanReboot | grep "yes") ] && return 0
    return 1
}

function can_suspend() {
    [ $(qdbus --system org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.CanSuspend | grep "yes") ] && return 0
    return 1
}

# Hibernate using dbus logind (only if user is authorized)
function dbus_suspend() {
    dbus-send --system \
    --print-reply=literal \
    --dest=org.freedesktop.login1 \
    /org/freedesktop/login1 "org.freedesktop.login1.Manager.Hibernate" boolean:true
}

# Poweroff using dbus logind  (only if user is authorized)
function dbus_poweroff() {
    dbus-send --system \
    --print-reply=literal \
    --dest=org.freedesktop.login1 \
    /org/freedesktop/login1 "org.freedesktop.login1.Manager.PowerOff" boolean:true
}

# Reboot using dbus logind  (only if user is authorized)
function dbus_reboot() {
    dbus-send --system \
    --print-reply=literal \
    --dest=org.freedesktop.login1 \
    /org/freedesktop/login1 "org.freedesktop.login1.Manager.Reboot" boolean:true
}

# Suspend using dbus logind (only if user is authorized)
function dbus_suspend() {
    dbus-send --system \
    --print-reply=literal \
    --dest=org.freedesktop.login1 \
    /org/freedesktop/login1 "org.freedesktop.login1.Manager.Suspend" boolean:true
}

# Return 0 if systemctl is found.
function systemctl_ok() {
    [ $(command -v systemctl) ] && return 0
    return 1
}

# Return 0 if shutdown is found.
function shutdown_ok() {
    [ $(command -v shutdown) ] && return 0
    return 1
}

# Return 0 if init is found.
function init_ok() {
    [ $(command -v init) ] && return 0
    return 1
}

# Is the screen already locked?
function locked() {
    local DebugMode=${1:-no}
    local scrsvApps=('i3lock' 'mate-screensaver-dialog' 'cinnamon-screensaver-pam-helper' 'slimlock' 'gnome-screensaver-dialog' 'xscreensaver')
    local c=0
    for p1 in "${scrsvApps[@]}"; do
        c=$(pgrep -lfc "${p1}")
        if [ $c -gt 0 ] ; then
            if [ "$DebugMode" = "debug" ]; then
                log "${p1} found and active";
                return 0;
            fi
        fi
    done
    return 1;
}

# Control the dunst daemon, if it is running.
function dunstctl() {
    pkill -0 --exact dunst || return 0
    
    case ${1:-} in
        stop)
            log "Stopping notifications and locking screen."
            pkill -USR1 --euid "$(id -u)" --exact dunst
        ;;
        resume)
            log "...Resuming notifications."
            pkill -USR2 --euid "$(id -u)" --exact dunst
        ;;
        check)
            log "Checking for dunst."
            [ $(command -v dunst) ] && return 0 || return 1
        ;;
        *)
            echo "dunstctl argument required: stop, resume or check"
            return 1
        ;;
    esac
    return 0
}

# Cleanup running processes.
function stop_it() {
    [ -z "$1" ] && return 1
    
    case ${2:-} in
        stop)
            if [ $(pgrep -lfc "$1") -ge 1 ] ; then
                local v_pid=( $(ps -aux | grep "$1" | egrep -v 'grep --color=auto' | sort -u | awk '{print $2}') )
                local v_len=${#v_pid[@]}
                let v_len=v_len-1
                local one_pid="0"
                for i in $(seq 0 $v_len ); do
                    one_pid=$(echo "${v_pid[$i]}");
                    log "killing $1 pid= $one_pid"
                    kill "$one_pid" &>/dev/null || true
                    sleep 0.1;
                done
            fi
            return 0
        ;;
        debug)
            if [ $(pgrep -lfc "$1") -ge 1 ] ; then
                log "$1 need to be terminated"
            else
                log "$1 not found"
            fi
            return 0
        ;;
        *)
            log "2nd argument must be: stop or debug";
            return 1
        ;;
    esac
}

# xset required
# check for a running X server
function is_running_X(){
    if ! xset q &>/dev/null; then
        return 1
    fi
    return 0
}

# builtin sleep in bash
function snore(){
    local IFS
    [[ -n "${_snore_fd:-}" ]] || exec {_snore_fd}<> <(:)
    read ${1:+-t "$1"} -u $_snore_fd || :
}

# required awk, bc
function findJPGPath(){
    if [ -z "$1" ] || [ -z "$2" ]; then
        echo ""
        return 1
    fi
    local iconJPG="${2}.jpg"
    cd "${1}"
    find . -name "${iconJPG}" | grep "16" | cut -c 2- | tail -n 1
    return 0
}

function findPNGPath(){
    if [ -z "$1" ] || [ -z "$2" ]; then
        echo ""
        return 1
    fi
    local iconPNG="${2}.png"
    cd "${1}"
    find . -name "${iconPNG}" | grep "16" | cut -c 2- | tail -n 1
    return 0
}

function findSVGPath(){
    if [ -z "$1" ] || [ -z "$2" ]; then
        echo ""
        return 1
    fi
    local iconSVG="${2}.svg"
    cd "${1}"
    find . -name "${iconSVG}" | cut -c 2- | tail -n 1
    return 0
}

function findIconThemeName(){
    local tn=""
    tn=$(gsettings get org.mate.interface icon-theme | tr -d "'")
    [ -z "$tn" ] && tn=$(gsettings get org.gnome.desktop.interface icon-theme | tr -d "'")
    echo "$tn"
    return 0
}

function findIconThemePath(){
    if [ -z "$1" ]; then
        echo ""
        return 1
    fi
    local tn="$1"
    local tp=""
    tp="/usr/share/icons/$tn"
    
    if [ -d "$tp" ]; then
        echo "$tp"
        return 0
    else
        tp="$HOME/.icons/$tn"
        if [ -d "$tp" ]; then
            echo "$tp"
            return 0
        fi
    fi
    echo ""
    return 1
}

function FindIconPath(){
    if [ -z "$1" ] || [ -z "$2" ]; then
        echo ""
        return 1
    fi
    
    local tp="$2"
    local nip=""
    
    nip=$(findSVGPath "$tp" "${1}")
    [ -z "$nip" ] && nip=$(findPNGPath "$tp" "${1}")
    [ -z "$nip" ] && nip=$(findJPGPath "$tp" "${1}")
    if [ -z "$nip" ]; then
        echo ""
        return 1
    fi
    
    echo "$tp$nip"
    return 0
}

function FallbackiconPath(){
    if [ -z "$1" ] || [ -z "$2" ]; then
        echo ""
        return 1
    fi
    
    local tp="$2"
    local seaDirs=( $(grep "nherit" "$tp/index.theme" | cut -d"=" -f2 | xargs -d ",") )
    local tp=""
    local iconPath=""
    
    for i in "${seaDirs[@]}"; do
        tp=$(findIconThemePath "$i");
        iconPath=$(FindIconPath "$1" "$tp");
        #echo "o i = $i e o tp = $tp e o iconName=$1  e o iconPath = $iconPath"
        if [ ! -z "$iconPath" ]; then
            echo "$iconPath"
            return 0
        fi
    done
    echo ""
    return 1
}

function iconPath(){
    if [ -z "$1" ]; then
        echo ""
        return 1
    fi
    
    local themePath=""
    local iconPath=""
    local themeName=""
    
    themeName=$(findIconThemeName)
    themePath=$(findIconThemePath "$themeName")
    
    if [ -z "$themePath" ]; then
        echo ""
        return 1
    fi
    
    iconPath=$(FindIconPath "$1" "$themePath");
    
    if [ -z "$iconPath" ]; then
        iconPath=$(FallbackiconPath "$1" "$themePath")
        if [ -z "$iconPath" ]; then
            echo ""
            return 1
        fi
    fi
    
    echo "$iconPath"
    return 0
}


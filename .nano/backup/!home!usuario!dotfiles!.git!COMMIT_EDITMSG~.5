
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
#
# No ramo master
# Your branch is up to date with 'origin/master'.
#
# Mudanças a serem submetidas:
#	modified:   .bashrc
#	new file:   .config/goto/goto_db
#	deleted:    .goto
#	new file:   bin/Xtouchpadctl
#	modified:   bin/backlightctl
#	modified:   bin/bashlock
#	new file:   bin/bashtop
#	modified:   bin/cryptIt
#	new file:   bin/dstart
#	new file:   bin/finder
#	new file:   bin/goto.sh
#	modified:   bin/manp
#	new file:   bin/movie2gif
#	modified:   bin/my-motd
#	modified:   bin/mycommon
#	modified:   bin/mycursor
#	modified:   bin/myedit
#	modified:   bin/myexit
#	modified:   bin/myfind
#	modified:   bin/mylightson
#	modified:   bin/mylock
#	modified:   bin/mynotify
#	modified:   bin/myoff
#	modified:   bin/myreboot
#	modified:   bin/myshutdown
#	modified:   bin/mysuspend
#	modified:   bin/mywallchng
#	new file:   bin/nosj
#	modified:   bin/ob_off
#	modified:   bin/ob_root_menu
#	new file:   bin/rofi-manual
#	modified:   bin/rofi-off
#	new file:   bin/torque
#	modified:   bin/touchpadctl
#	modified:   bin/wpctl
#
# ------------------------ >8 ------------------------
# Do not modify or remove the line above.
# Everything below it will be ignored.
diff --git a/.bashrc b/.bashrc
index 732a9ee6..43792377 100644
--- a/.bashrc
+++ b/.bashrc
@@ -1,7 +1,7 @@
 #!/usr/bin/env bash
 
 # Source goto 
-[[ -s "/usr/local/share/goto.sh" ]] && source /usr/local/share/goto.sh
+[[ -s "$HOME/bin/goto.sh" ]] && source ~/bin/goto.sh
 
 # Set Xterm/screen/Tmux title with only a short hostname.
 # Uncomment this (or set SHORT_HOSTNAME to something else),
@@ -28,7 +28,7 @@ export VCPROMPT_EXECUTABLE=~/bin/vcprompt
 export SCM_CHECK=true
 
 # Path to the bash it configuration
-export BASH_IT="/home/usuario/.bash_it"
+export BASH_IT="$HOME/.bash_it"
 
 # Lock and Load a custom theme file
 # location /.bash_it/themes/
diff --git a/.config/goto/goto_db b/.config/goto/goto_db
new file mode 100644
index 00000000..fe2bd380
--- /dev/null
+++ b/.config/goto/goto_db
@@ -0,0 +1,10 @@
+bin /home/usuario/bin
+devshell /home/usuario/Workspace/dev/shell
+devC /home/usuario/Workspace/dev/c
+devPy /home/usuario/Workspace/dev/py
+devJava /home/usuario/Workspace/dev/java
+devC++ /home/usuario/Workspace/dev/c++collections /home/usuario/Workspace/collections
+colldots /home/usuario/Workspace/collections/dotfiles-collection
+collfonts /home/usuario/Workspace/collections/font-collection
+collthemes /home/usuario/Workspace/collections/theme-collection
+devLua /home/usuario/Workspace/dev/lua
diff --git a/.goto b/.goto
deleted file mode 100644
index a1144d25..00000000
--- a/.goto
+++ /dev/null
@@ -1,2 +0,0 @@
-bin /home/usuario/bin
-shell /home/usuario/Workspace/shell
diff --git a/bin/Xtouchpadctl b/bin/Xtouchpadctl
new file mode 100755
index 00000000..b78d8ba3
--- /dev/null
+++ b/bin/Xtouchpadctl
@@ -0,0 +1,111 @@
+#!/usr/bin/env bash
+## $1 = "add" / "remove"
+## $2 = %k from udev
+
+function usage() {
+    echo "Usage: $(basename $0) [Options]"
+    echo "       "
+    echo "Purpose: To enable or disable Touchpad"
+    echo "       "
+    echo "Options"
+    echo "-h | --help : Show this help"
+    echo "-d | --disable: Disable touchpad"
+    echo "-e | --enable: Enable touchpad"
+    echo "-a | --auto: Auto enable|disable on mouse plug(in/off)"
+    echo "-t | --toggle: Toggle touchpad state (enabled/disabled)"
+    return 0;
+}
+
+# Main
+if [ $# -eq 0 ] ; then
+    usage 
+    /usr/bin/logger -t Touchpadctl -- "No parameters."
+    exit 0
+fi
+
+/usr/bin/logger -t Touchpadctl -- "1=$1 2=$2"
+
+# Option strings
+SHORT=":a::d::e::h::t"
+LONG=":auto,disable,enable,help,toggle"
+
+# Read the options
+OPTS=$(getopt --options $SHORT --long $LONG --name "$0" -- "$@")
+if [ $? -ne 0 ] ; then
+    usage ;
+    /usr/bin/logger -t Touchpadctl -- "Wrong parameters.[ $* ]"
+    exit 0
+fi
+
+# Obtain user list
+USERLIST=$(w -h | cut -d' ' -f1 | sort | uniq)
+for CUR_USER in ${USERLIST}; do
+    CUR_USER_XAUTH="$(sudo -Hiu "${CUR_USER}" env | grep -e "^HOME=" | cut -d'=' -f2)/.Xauthority"
+    ## Can't find a way to get another users DISPLAY variable from an isolated root environment. Have to set it manually.
+    CUR_USER_DISPL="$(sudo -Hiu "${CUR_USER}" env | grep -e "^DISPLAY=" | cut -d'=' -f2)"
+    [ -z "$CUR_USER_DISPL" ] && CUR_USER_DISPL=":0"
+    
+    export XAUTHORITY="${CUR_USER_XAUTH}"
+    export DISPLAY="${CUR_USER_DISPL}"
+    
+    # Check running X
+    if ! xset q &>/dev/null; then
+        /usr/bin/logger -t Touchpadctl -- "Xserver is not running."
+        exit 0
+    fi
+    
+    if [ -f "${CUR_USER_XAUTH}" ]; then
+        declare -i TOUCH_ID
+        TOUCH_ID=$(/usr/bin/xinput list | \egrep -Eo 'Touchpad\s*id\=[0-9]{1,2}' | \egrep -Eo '[0-9]{1,2}')
+        declare -i STATE
+        STATE=$(/usr/bin/xinput list-props $TOUCH_ID | \grep 'Device Enabled' | \awk '{print $4}')
+        
+        case "$1" in
+            -a | --auto )
+                xinput list | \egrep -Eo '[Mm]ouse\s*id\=[0-9]{1,2}' | \egrep -Eo '[0-9]{1,2}' &>/dev/null
+                if [ $? -eq 0 ] ; then
+                    /usr/bin/xinput disable $TOUCH_ID
+                    /usr/bin/logger -t Touchpadctl -- "Additional external mice found. Touchpad disabled for $CUR_USER. ($XAUTHORITY - $DISPLAY)"
+                else
+                    /usr/bin/xinput enable $TOUCH_ID
+                    /usr/bin/logger -t Touchpadctl -- "Additional external mice not found. Touchpad enabled for $CUR_USER. ($XAUTHORITY - $DISPLAY)"
+                fi
+            ;;
+            -d | --disable )
+                if [ $STATE -eq 1 ]; then
+                    /usr/bin/xinput disable $TOUCH_ID
+                    /usr/bin/logger -t Touchpadctl -- "Disabling touchpad for $CUR_USER. ($XAUTHORITY - $DISPLAY)"
+                else
+                    /usr/bin/logger -t Touchpadctl -- "Touchpad already disabled for $CUR_USER. ($XAUTHORITY - $DISPLAY)"
+                fi
+            ;;
+            -e | --enable )
+                if [ $STATE -eq 0 ]; then
+                    /usr/bin/xinput enable $TOUCH_ID
+                    /usr/bin/logger -t Touchpadctl -- "Enabling touchpad for $CUR_USER. ($XAUTHORITY - $DISPLAY)"
+                else
+                    /usr/bin/logger -t Touchpadctl -- "Touchpad already enabled for $CUR_USER. ($XAUTHORITY - $DISPLAY)"
+                fi
+            ;;
+            -t | --toggle )
+                if [ $STATE -eq 0 ]; then
+                    /usr/bin/xinput enable $TOUCH_ID
+                    /usr/bin/logger -t Touchpadctl -- "Enabling touchpad for $CUR_USER. ($XAUTHORITY - $DISPLAY)"
+                else
+                    /usr/bin/xinput disable $TOUCH_ID
+                    /usr/bin/logger -t Touchpadctl -- "Disabling touchpad for $CUR_USER. ($XAUTHORITY - $DISPLAY)"
+                fi
+            ;;
+            *)  usage; exit;;
+        esac
+    fi
+done
+unset CUR_USER 
+unset CUR_USER_DISPL
+unset CUR_USER_XAUTH
+unset LONG
+unset STATE
+unset SHORT
+unset TOUCH_ID
+unset USERLIST
+unset OPTS
\ No newline at end of file
diff --git a/bin/backlightctl b/bin/backlightctl
index a84b818b..81cad3d8 100755
--- a/bin/backlightctl
+++ b/bin/backlightctl
@@ -25,7 +25,7 @@ if [ -f "$HOME/bin/mycommon" ]; then
 fi
 
 # Usage information
-usage () {
+function usage () {
     echo "Usage: ${0##*/} [OPTION]"
     echo
     echo
@@ -42,10 +42,9 @@ usage () {
     echo
 }
 
-
 function main(){
-    precheck xbacklight
-    precheck bc
+    precheck "xbacklight"
+    precheck "bc"
     
     # Get current value
     local current="$(xbacklight -get)"
@@ -55,10 +54,10 @@ function main(){
     local stepsize="$(echo "sqrt ( $value )" | bc -l | cut -d"." -f 1)"
     
     # Force minimum step size of "1" if determined stepsize would equal 0
-    if [ "$stepsize" -eq 0 ]; then stepsize=1; fi
+    [ "$stepsize" -eq 0 ] && stepsize=1
     
     # Force small steps in low light environments to allow fine adjustments
-    if [ "$stepsize" -eq 2 ]; then stepsize=1; fi
+    [ "$stepsize" -eq 2 ] && stepsize=1
     
     # Parse arguments
     case "$1" in
@@ -74,12 +73,11 @@ function main(){
             echo "${current%%.*}"
         ;;
         ''|*)
-            echo "Usage error."
-            echo
             usage
+            exit 0
         ;;
     esac
-    
+    exit 0
 }
 
 main "$@"
diff --git a/bin/bashlock b/bin/bashlock
index e31d92fc..867a43f5 100755
--- a/bin/bashlock
+++ b/bin/bashlock
@@ -67,7 +67,13 @@ function authenticate() {
     done
 }
 
-trap onexit 1 2 3 15 18 20 ERR
-authenticate
-unset MAXRETRIES
-unset RETRYSLEEP
+function main(){
+    trap onexit 1 2 3 15 18 20 ERR
+    authenticate
+    unset MAXRETRIES
+    unset RETRYSLEEP
+    exit 0
+}
+
+main "$@"
+
diff --git a/bin/bashtop b/bin/bashtop
new file mode 100755
index 00000000..0b2acf04
--- /dev/null
+++ b/bin/bashtop
@@ -0,0 +1,3446 @@
+#!/usr/bin/env bash
+# indent type=tab
+# tab size=4
+# shellcheck disable=SC2034 #Unused variables
+# shellcheck disable=SC2068 #Double quote array warning
+# shellcheck disable=SC2086 # Double quote warning
+## shellcheck disable=SC2120
+# shellcheck disable=SC2162 #Read without -r
+# shellcheck disable=SC2206 #Word split warning
+# shellcheck disable=SC2178 #Array to string warning
+# shellcheck disable=SC2102 #Ranges only match single
+# shellcheck disable=SC2004 #arithmetic brackets warning
+# shellcheck disable=SC2207 #split array warning
+
+
+# Copyright 2020 Aristocratos
+
+#    Licensed under the Apache License, Version 2.0 (the "License");
+#    you may not use this file except in compliance with the License.
+#    You may obtain a copy of the License at
+
+#        http://www.apache.org/licenses/LICENSE-2.0
+
+#    Unless required by applicable law or agreed to in writing, software
+#    distributed under the License is distributed on an "AS IS" BASIS,
+#    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#    See the License for the specific language governing permissions and
+#    limitations under the License.
+
+declare -x LC_MESSAGES="C" LC_NUMERIC="C"
+shopt -qu failglob globstar
+shopt -qs extglob globasciiranges
+
+declare -a banner banner_colors
+
+banner=(
+"██████╗  █████╗ ███████╗██╗  ██╗████████╗ ██████╗ ██████╗ "
+"██╔══██╗██╔══██╗██╔════╝██║  ██║╚══██╔══╝██╔═══██╗██╔══██╗"
+"██████╔╝███████║███████╗███████║   ██║   ██║   ██║██████╔╝"
+"██╔══██╗██╔══██║╚════██║██╔══██║   ██║   ██║   ██║██╔═══╝ "
+"██████╔╝██║  ██║███████║██║  ██║   ██║   ╚██████╔╝██║     "
+"╚═════╝ ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝   ╚═╝    ╚═════╝ ╚═╝     ")
+declare version="0.6.11"
+declare banner_width=${#banner[0]}
+banner_colors=("#E62525" "#CD2121" "#B31D1D" "#9A1919" "#801414")
+
+#? Start default variables------------------------------------------------------------------------------>
+#? These values are used to create "$HOME/.config/bashtop/bashtop.cfg"
+#? Any changes made here will be ignored if config file exists
+aaa_config() { : ; } #! Do not remove this line!
+
+#* Update time in milliseconds, increases automatically if set below internal loops processing time, recommended 2000 ms or above for better sample times for graphs
+update_ms="2500"
+
+#* Processes sorting, "pid" "program" "arguments" "threads" "user" "memory" "cpu lazy" "cpu responsive"
+#* "cpu lazy" upates sorting over time, "cpu responsive" updates sorting directly at a cpu usage cost
+proc_sorting="cpu lazy"
+
+#* Reverse sorting order, "true" or "false"
+proc_reversed="false"
+
+#* Check cpu temperature, only works if "sensors" command is available and have values for "Package" and "Core"
+check_temp="true"
+
+#* Draw a clock at top of screen, formatting according to strftime, empty string to disable
+draw_clock="%X"
+
+#* Update main ui when menus are showing, set this to false if the menus is flickering too much for comfort
+background_update="true"
+
+#* Custom cpu model name, empty string to disable
+custom_cpu_name=""
+
+#* Enable error logging to "$HOME/.config/bashtop/error.log", "true" or "false"
+error_logging="true"
+
+aaz_config() { : ; } #! Do not remove this line!
+#? End default variables-------------------------------------------------------------------------------->
+
+declare -a menu_options menu_help menu_quit
+
+menu_options=(
+"┌─┐┌─┐┌┬┐┬┌─┐┌┐┌┌─┐"
+"│ │├─┘ │ ││ ││││└─┐"
+"└─┘┴   ┴ ┴└─┘┘└┘└─┘")
+menu_help=(
+"┬ ┬┌─┐┬  ┌─┐"
+"├─┤├┤ │  ├─┘"
+"┴ ┴└─┘┴─┘┴  ")
+menu_quit=(
+"┌─┐ ┬ ┬ ┬┌┬┐"
+"│─┼┐│ │ │ │ "
+"└─┘└└─┘ ┴ ┴ ")
+
+menu_options_selected=(
+"╔═╗╔═╗╔╦╗╦╔═╗╔╗╔╔═╗"
+"║ ║╠═╝ ║ ║║ ║║║║╚═╗"
+"╚═╝╩   ╩ ╩╚═╝╝╚╝╚═╝")
+menu_help_selected=(
+"╦ ╦╔═╗╦  ╔═╗"
+"╠═╣║╣ ║  ╠═╝"
+"╩ ╩╚═╝╩═╝╩  ")
+menu_quit_selected=(
+"╔═╗ ╦ ╦ ╦╔╦╗ "
+"║═╬╗║ ║ ║ ║  "
+"╚═╝╚╚═╝ ╩ ╩  ")
+
+declare -A cpu mem swap proc net box
+declare -a cpu_usage cpu_graph_a cpu_graph_b color_meter color_temp color_cpu color_cpu_graph cpu_history color_mem_graph color_swap_graph
+declare -a mem_history swap_history net_history_download net_history_upload mem_graph swap_graph proc_array download_graph upload_graph trace_array
+declare resized=1 size_error clock tty_width tty_height hex="16#" cpu_p_box swap_on=1 draw_out esc_character boxes_out last_screen clock_out update_string
+declare -a options_array=("update_ms" "proc_sorting" "proc_reversed" "check_temp" "draw_clock" "background_update" "error_logging" "custom_cpu_name")
+declare -a save_array=("${options_array[@]}")
+declare -a sorting=( "pid" "program" "arguments" "threads" "user" "memory" "cpu lazy" "cpu responsive" )
+declare -a pid_history detail_graph detail_history detail_mem_history
+declare time_left timestamp_start timestamp_end timestamp_input_start timestamp_input_end time_string mem_out proc_misc prev_screen pause_screen filter input_to_filter
+declare no_epoch proc_det proc_misc2 sleeping=0 detail_mem_graph proc_det2 proc_out
+declare esc_character tab backspace sleepy late_update skip_process_draw winches quitting
+declare -a disks_free disks_total disks_name disks_free_percent saved_key
+printf -v esc_character "\u1b"
+printf -v tab "\u09"
+printf -v backspace "\u7F"
+printf -v enter_key "\uA"
+
+read tty_height tty_width < <(stty size)
+
+#* Symbols for graphs
+declare -a graph_symbol
+graph_symbol=(" " "⡀" "⣀" "⣄" "⣤" "⣦" "⣴" "⣶" "⣷" "⣾" "⣿")
+graph_symbol+=( " " "⣿" "⢿" "⡿" "⠿" "⠻" "⠟"  "⠛" "⠙" "⠉" "⠈")
+box[boxes]="cpu mem net processes"
+box[cpu_color]="#3d7b46"
+box[mem_color]="#8a882e"
+box[net_color]="#423ba5"
+box[processes_color]="#923535"
+
+cpu[threads]=0
+
+#* Symbols for subscript function
+subscript=("₀" "₁" "₂" "₃" "₄" "₅" "₆" "₇" "₈" "₉")
+
+#* Symbols for create_box function
+box[single_hor_line]="─"
+box[single_vert_line]="│"
+box[single_left_corner_up]="┌"
+box[single_right_corner_up]="┐"
+box[single_left_corner_down]="└"
+box[single_right_corner_down]="┘"
+box[single_title_left]="├"
+box[single_title_right]="┤"
+
+box[double_hor_line]="═"
+box[double_vert_line]="║"
+box[double_left_corner_up]="╔"
+box[double_right_corner_up]="╗"
+box[double_left_corner_down]="╚"
+box[double_right_corner_down]="╝"
+box[double_title_left]="╟"
+box[double_title_right]="╢"
+
+#* If using bash version 5, set timestamps with EPOCHREALTIME variable
+if [[ -n $EPOCHREALTIME ]]; then
+	get_ms() { #? Set given variable to current epoch millisecond with EPOCHREALTIME varialble
+		local -n ms_out=$1
+		ms_out=$((${EPOCHREALTIME/[.,]/}/1000))
+	}
+
+#* If not, use date command
+else
+	get_ms() { #? Set given variable to current epoch millisecond with date command
+		local -n ms_out=$1
+		ms_out="$(date +%s%3N)"
+	}
+fi
+
+
+init_() { #? Collect needed information and set options before startig main loop
+	local i
+	#* Set terminal options, save and clear screen
+	tput smcup
+	stty -echo
+	tput civis
+
+	#* Check if "sensors" command is available, if not, disable temperature collection
+	if [[ $check_temp != false ]] && command -v sensors >/dev/null 2>&1; then check_temp="true"; else check_temp="false"; fi
+
+	#* Get number of cores and cpu threads
+	get_cpu_info
+
+	#* Get processor BCLK
+	local param_var
+	if [[ -e /usr/include/asm-generic/param.h ]]; then
+		param_var="$(</usr/include/asm-generic/param.h)"
+		get_value -v cpu[hz] -sv "param_var" -k "define HZ" -i
+	else 
+		cpu[hz]="100"
+	fi
+
+	#* Get max pid value and length
+	proc[pid_max]="$(</proc/sys/kernel/pid_max)"
+	proc[pid_len]=${#proc[pid_max]}
+	if [[ ${proc[pid_len]} -lt 5 ]]; then proc[pid_len]=5; fi
+
+	#* Call init for cpu data collection
+	collect_cpu init
+
+	#* Call init for memory data collection and check if swap is available
+	mem[counter]=10
+	collect_mem init
+
+	#* Get default network device from "ip route" command and call init for net collection
+	get_value -v net[device] -ss "$(ip route get 1.1.1.1)" -k "dev" -mk 1
+	collect_net init
+
+	#* Draw banner to banner array
+	local letter b_color banner_line y=0
+	local -a banner_out
+	print -v banner_out[0] -rs
+	for banner_line in "${banner[@]}"; do
+		#* Read banner array letter by letter to set correct color for filled vs outline characters
+		while read -rN1 letter; do 
+			if [[ $letter == "█" ]]; then b_color="${banner_colors[$y]}"
+			else b_color=$((80-y*6)); fi
+			if [[ $letter == " " ]]; then
+				print -v banner_out[y] -r 1
+			else
+				print -v banner_out[y] -fg ${b_color} "${letter}"
+			fi
+		done <<<"$banner_line"
+		((++y))
+	done
+	print -v banner_out[y] -rs -fg cc -trans -b "← esc" -fg cc -i -b -trans -r 37 "Version: ${version}" -rs
+	unset 'banner[@]'
+	banner=("${banner_out[@]}")
+
+
+	#* Create values for temperature color array
+	local red=50 green=120 blue=250
+	for ((i=0;i<=100;i++)); do
+		color_temp[i]="${red} ${green} ${blue}"
+		if ((i>70)); then 
+			red=$((red+6)); blue=$((blue-6)); green=$((green-8))
+		elif ((i>40)); then
+			blue=$((blue-2)); red=$((red+5)); green=$((green+2))
+		elif ((i>20)); then
+			green=$((green+3)); ((blue--))
+		else ((red++)); ((green++)); ((blue--))
+		fi
+		if ((red>255)); then red=255; fi
+		if ((green>255)); then green=255; fi
+		if ((blue<20)); then blue=20; fi
+	done
+
+	#* Create values for cpu meter color array
+	local red=80 green=240 blue=150
+	for ((i=0;i<=100;i++)); do
+		color_cpu[i]="${red} ${green} ${blue}"
+		if ((i>75)); then 
+			red=$((red+6)); blue=$((blue-4)); green=$((green-9))
+		elif ((i>55)); then
+			blue=$((blue-2)); ((green++))
+		elif ((i>35)); then
+			red=$((red+5)); ((green++))
+		else
+			((red++)); ((green--)); ((blue--))
+		fi
+		if ((green<0)); then green=0; fi
+		if ((red>255)); then red=255; fi
+		if ((blue<20)); then blue=20; fi
+	done
+
+	#* Create values for cpu graph color array
+	local red=80 green=240 blue=150
+	for ((i=0;i<=100;i++)); do
+		color_cpu_graph[i]="${red} ${green} ${blue}"
+		if ((i>65)); then 
+			red=$((red+6)); blue=$((blue-4)); green=$((green-9))
+
+		elif ((i>55)); then
+			blue=$((blue-2)); ((green++))
+		elif ((i>20)); then
+			red=$((red+4))
+		else
+			red=$((red+4)); ((green--)); ((blue--))
+		fi
+		if ((green<0)); then green=0; fi
+		if ((red>255)); then red=255; fi
+		if ((blue<20)); then blue=20; fi
+	done
+
+	#* Create values for free color array
+	local red=35 green=54 blue=4
+	for ((i=0;i<=100;i++)); do
+		color_free_graph[i]="${red} ${green} ${blue}"
+		red=$((red+3)); green=$((green+3)); blue=$((blue+2))
+		if ((green>255)); then green=255; fi
+		if ((red>255)); then red=255; fi
+		if ((blue>255)); then blue=255; fi
+	done
+
+	#* Create values for cached color array
+	local red=15 green=34 blue=54
+	for ((i=0;i<=100;i++)); do
+		color_cached_graph[i]="${red} ${green} ${blue}"
+		red=$((red+2)); green=$((green+3)); blue=$((blue+3))
+		if ((green>255)); then green=255; fi
+		if ((red>255)); then red=255; fi
+		if ((blue>255)); then blue=255; fi
+	done
+
+	#* Create values for available color array
+	local red=54 green=35 blue=15
+	for ((i=0;i<=100;i++)); do
+		color_available_graph[i]="${red} ${green} ${blue}"
+		red=$((red+3)); green=$((green+3)); blue=$((blue+2))
+		if ((green>255)); then green=255; fi
+		if ((red>255)); then red=255; fi
+		if ((blue>255)); then blue=255; fi
+	done
+
+	#* Create values for used color array
+	local red=54 green=20 blue=15
+	for ((i=0;i<=100;i++)); do
+		color_used_graph[i]="${red} ${green} ${blue}"
+		red=$((red+3)); green=$((green+2)); blue=$((blue+2))
+		if ((green>255)); then green=255; fi
+		if ((red>255)); then red=255; fi
+		if ((blue>255)); then blue=255; fi
+	done
+
+	#* Create values for download graph color array
+	local red=27 green=20 blue=75
+	for ((i=0;i<=100;i++)); do
+		color_download_graph[i]="${red} ${green} ${blue}"
+		red=$((red+2)); green=$((green+2)); blue=$((blue+2))
+		if ((green>255)); then green=255; fi
+		if ((red>255)); then red=255; fi
+		if ((blue>255)); then blue=255; fi
+	done
+
+	#* Create values for upload graph color array
+	local red=58 green=4 blue=60
+	for ((i=0;i<=100;i++)); do
+		color_upload_graph[i]="${red} ${green} ${blue}"
+		red=$((red+2)); green=$((green+2)); blue=$((blue+2))
+		if ((green>255)); then green=255; fi
+		if ((red>255)); then red=255; fi
+		if ((blue>255)); then blue=255; fi
+	done
+
+	#* Set up internals for quick processes sorting switching
+	for((i=0;i<${#sorting[@]};i++)); do
+		if [[ ${sorting[i]} == "${proc_sorting}" ]]; then
+			proc[sorting_int]=$i
+			break
+		fi
+	done
+	if [[ -z ${proc[sorting_int]} ]]; then
+		proc[sorting_int]=0
+		proc_sorting="${sorting[0]}"
+	fi
+
+	if [[ ${proc_reversed} == true ]]; then
+		proc[reverse]="+"
+	else
+		unset 'proc[reverse]'
+	fi
+
+	#* Wait for resize if terminal size is smaller then 80x25
+	if (($tty_width<80 | $tty_height<25)); then resized; fi
+	
+	#* Calculate sizes of boxes
+	calc_sizes
+	
+
+	#* Call init for processes data collection
+	proc[selected]=0
+	proc[page]=1
+	collect_processes init
+	
+}
+
+quit_() { #? Clean exit
+	#* Restore terminal options and screen
+	tput rmcup
+	stty echo
+	tput cnorm
+
+	#* Save any changed values to config file
+	if [[ $config_file != "/dev/null" ]]; then
+		save_config "${save_array[@]}"
+	fi
+	
+	exit 0
+}
+
+traperr() { #? Function for reporting error line numbers
+	local match len trap_muted err="${BASH_LINENO[0]}"
+
+	len=$((${#trace_array[@]}))
+	if ((len-->=1)); then
+		while ((len>=${#trace_array[@]}-2)); do		
+			if [[ $err == "${trace_array[$((len--))]}" ]]; then ((++match)) ; fi
+		done
+		if ((match==2 & len != -2)); then return
+		elif ((match>=1)); then trap_muted="(MUTED!)"
+		fi
+	fi
+	if ((len>100)); then unset 'trace_array[@]'; fi
+	trace_array+=("$err")
+	echo "$(printf "%(%X)T") ERROR: On line $err $trap_muted" >> "${config_dir}/error.log"
+	
+}
+
+resized() { #? Get new terminal size if terminal is resized
+	resized=1
+	unset winches
+	while ((++winches<5)); do
+		read tty_height tty_width < <(stty size)
+		if (($tty_width<80 | $tty_height<25)); then 
+			size_error_msg
+			winches=0
+		else
+			create_box -w 30 -h 3 -c 1 -l 1 -lc "#EE3355" -title "resizing"
+			print -jc 28 "New size: ${tty_height}x${tty_width}"
+			sleep 0.2
+			if [[ $(stty size) != "$tty_height $tty_width" ]]; then winches=0; fi
+		fi
+	done
+}
+
+size_error_msg() { #? Shows error message if terminal size is below 80x25
+	local width=$tty_width
+	local height=$tty_height
+	tput clear
+	create_box -full -lc "#EE3355" -title "resize window"
+	print -rs -m $((tty_height/2-1)) 2 -fg cc -c -l 11 "Current size: " -fg dd3050 -d 1 -c "${tty_height}x${tty_width}"
+	print -d 1 -fg cc -c -l 15 "Need to be atleast:" -fg 30dd50 -d 1 -c "80x25"
+	while [[ $(stty size) == "$tty_height $tty_width" ]]; do sleep 0.2; done
+	
+}
+
+draw_banner() { #? Draw banner, usage: draw_banner <line> [output variable]
+	local y letter b_color x_color xpos ypos=$1 banner_out
+	if [[ -n $2 ]]; then local -n banner_out=$2; fi
+	xpos=$(( (tty_width/2)-(banner_width/2) ))
+	
+	for banner_line in "${banner[@]}"; do
+		print -v banner_out -rs -move $((ypos+++y)) $xpos -t "${banner_line}"
+	done
+	
+	if [[ -z $2 ]]; then echo -en "${banner_out}"; fi
+}
+
+create_config() { #? Creates a new config file with default values from above
+	local c_line c_read this_file
+	this_file="$(realpath "$0")"
+	echo "#? Config file for bashtop v. ${version}" > "$config_file"
+	while IFS= read -r c_line; do
+		if [[ $c_line =~ aaz_config() ]]; then break
+		elif [[ $c_read == "1" ]]; then echo "$c_line" >> "$config_file"
+		elif [[ $c_line =~ aaa_config() ]]; then c_read=1; fi
+	done < "$this_file"
+}
+
+save_config() { #? Saves variables to config file if not same, usage: save_config "var1" ["var2"] ["var3"]...
+	if [[ -z $1 || $config_file == "/dev/null" ]]; then return; fi
+	local var tmp_conf tmp_value quote original new
+	tmp_conf="$(<"$config_file")"
+	for var in "$@"; do
+		if [[ ${tmp_conf} =~ ${var} ]]; then
+			get_value -v "tmp_value" -sv "tmp_conf" -k "${var}="
+			if [[ ${tmp_value//\"/} != "${!var}" ]]; then
+				original="${var}=${tmp_value}"
+				new="${var}=\"${!var}\""
+				sed -i "s/${original}/${new}/" "${config_file}"
+			fi
+		else
+			echo "${var}=\"${!var}\"" >> "$config_file"
+		fi
+	done
+}
+
+set_font() { #? Take a string and generate a string of unicode characters of given font, usage; set_font "font-name [bold] [italic]" "string"
+	local i letter letter_hex new_hex add_hex start font="$1" string_in="$2" string_out hex="16#"
+	if [[ -z $font || -z $string_in ]]; then return; fi
+	case "$font" in
+		"sans-serif") lower_start="1D5BA"; upper_start="1D5A0"; digit_start="1D7E2";;
+		"sans-serif bold") lower_start="1D5EE"; upper_start="1D5D4"; digit_start="1D7EC";;
+		"sans-serif italic") lower_start="1D622"; upper_start="1D608"; digit_start="1D7E2";;
+		#"sans-serif bold italic") start="1D656"; upper_start="1D63C"; digit_start="1D7EC";;
+		"script") lower_start="1D4B6"; upper_start="1D49C"; digit_start="1D7E2";;
+		"script bold") lower_start="1D4EA"; upper_start="1D4D0"; digit_start="1D7EC";;
+		"fraktur") lower_start="1D51E"; upper_start="1D504"; digit_start="1D7E2";;
+		"fraktur bold") lower_start="1D586"; upper_start="1D56C"; digit_start="1D7EC";;
+		"monospace") lower_start="1D68A"; upper_start="1D670"; digit_start="1D7F6";;
+		"double-struck") lower_start="1D552"; upper_start="1D538"; digit_start="1D7D8";;
+		*) echo -n "${string_in}"; return;;
+	esac
+
+	for((i=0;i<${#string_in};i++)); do
+		letter=${string_in:i:1}
+		if [[ $letter =~ [a-z] ]]; then #61
+			printf -v letter_hex '%X\n' "'$letter"
+			printf -v add_hex '%X' "$((${hex}${letter_hex}-${hex}61))"
+			printf -v new_hex '%X' "$((${hex}${lower_start}+${hex}${add_hex}))"
+			string_out="${string_out}\U${new_hex}"
+			#if [[ $font =~ sans-serif && $letter =~ m|w ]]; then string_out="${string_out} "; fi
+			#\U205F
+		elif [[ $letter =~ [A-Z] ]]; then #41
+			printf -v letter_hex '%X\n' "'$letter"
+			printf -v add_hex '%X' "$((${hex}${letter_hex}-${hex}41))"
+			printf -v new_hex '%X' "$((${hex}${upper_start}+${hex}${add_hex}))"
+			string_out="${string_out}\U${new_hex}"
+			#if [[ $font =~ sans-serif && $letter =~ M|W ]]; then string_out="${string_out} "; fi
+		elif [[ $letter =~ [0-9] ]]; then #30
+			printf -v letter_hex '%X\n' "'$letter"
+			printf -v add_hex '%X' "$((${hex}${letter_hex}-${hex}30))"
+			printf -v new_hex '%X' "$((${hex}${digit_start}+${hex}${add_hex}))"
+			string_out="${string_out}\U${new_hex}"
+		else
+			string_out="${string_out} \e[1D${letter}"
+		fi
+	done
+	
+	echo -en "${string_out}"
+}
+
+sort_array_int() {	#? Copy and sort an array of integers from largest to smallest value, usage: sort_array_int "input array" "output array"
+	#* Return if given array has no values
+	if [[ -z ${!1} ]]; then return; fi
+	local start_n search_n tmp_array
+	
+	#* Create pointers to arrays
+	local -n in_arr="$1"
+	local -n out_arr="$2"
+
+	#* Create local copy of array
+	local array=("${in_arr[@]}")
+	
+	#* Start sorting
+    for ((start_n=0;start_n<=${#array[@]}-1;++start_n)); do
+        for ((search_n=start_n+1;search_n<=${#array[@]}-1;++search_n)); do
+            if ((array[start_n]<array[search_n])); then
+                tmp_array=${array[start_n]}
+                array[start_n]=${array[search_n]}
+                array[search_n]=$tmp_array
+            fi
+        done
+    done
+	
+	#* Write the sorted array to output array
+	out_arr=("${array[@]}")	
+}
+
+subscript() { #? Convert an integer to a string of subscript numbers
+	local i out int=$1
+	for((i=0;i<${#int};i++)); do
+		out="${out}${subscript[${int:$i:1}]}"
+	done
+	echo -n "${out}"
+}
+
+spaces() { #? Prints back spaces, usage: spaces "number of spaces"
+	printf "%${1}s" "" 
+}
+
+floating_humanizer() { 	#? Convert integer to floating point and scale up in steps of 1024 to highest positive unit
+						#? Usage: floating_humanizer <-b,-bit|-B,-Byte> [-ps,-per-second] [-s,-start "1024 multiplier start"] [-v,-variable-output] <input>
+	local value selector per_second unit_mult decimals out_var ext_var
+	local -a unit
+	until (($#==0)); do
+		case "$1" in
+			-b|-bit) unit=(bit Kib Mib Gib Tib Pib); unit_mult=8;;
+			-B|-Byte) unit=(Byte KiB MiB GiB TiB PiB); unit_mult=1;;
+			-ps|-per-second) per_second=1;;
+			-s|-start) selector="$2"; shift;;
+			-v|-variable-output) local -n out_var="$2"; ext_var=1; shift;;
+			*) if [[ $1 =~ ^[0-9]*$ ]]; then value=$1; break; fi;;
+		esac
+		shift
+	done
+	
+	if [[ -z $value || $value -lt 0 || -z $unit_mult ]]; then return; fi
+
+	if ((per_second==1 & unit_mult==1)); then per_second="/s"
+	elif ((per_second==1)); then per_second="ps"; fi
+
+	if ((value>0)); then
+		value=$((value*100*unit_mult))
+
+		until ((${#value}<6)); do
+			value=$((value>>10))
+			((++selector))
+		done
+
+		if ((${#value}<5 & ${#value}>=2 & selector>0)); then
+			decimals=$((5-${#value}))
+			value="${value::-2}.${value:(-${decimals})}"
+		elif ((${#value}>=2)); then
+			value="${value::-2}"
+		fi
+	fi
+
+	out_var="${value} ${unit[$selector]}${per_second}"
+	if [[ -z $ext_var ]]; then echo -n "${out_var}"; fi
+}
+
+get_cpu_info() {
+	local lscpu_var param_var
+	lscpu_var="$(lscpu)"
+	if [[ -z ${cpu[threads]} || -z ${cpu[cores]} ]]; then
+		get_value -v cpu[threads] -sv "lscpu_var" -k "CPU(s):" -i
+		get_value -v cpu[cores] -sv "lscpu_var" -k "Core(s)" -i
+	fi
+	if [[ -z $custom_cpu_name ]]; then
+		if ! get_value -v cpu[model] -sv "lscpu_var" -k "Model name:" -a -b -k "CPU" -mk -1; then
+			get_value -v cpu[model] -sv "lscpu_var" -k "Model name:" -r "  "
+		fi
+	else
+		cpu[model]="${custom_cpu_name}"
+	fi
+}
+
+get_value() { #? Get a value from a file, variable or array by searching for a non spaced "key name" on the same line
+	local match line_pos=1 int reg key all tmp_array input found input_line line_array line_val ext_var line_nr current_line match_key math removing ext_arr
+	local -a remove
+	until (($#==0)); do
+		until (($#==0)); do
+			case "$1" in
+				-k|-key) key="$2"; shift;;														#? Key "string" on the same line as target value
+				-m|-match) match="$2"; shift;;													#? If multiple matches on a line, match occurrence "x"
+				-mk|-match-key) match_key=$2; line_pos=0; shift;;								#? Match in relation to key position, -1 for previous value, 1 for next value
+				-b|-break) shift; break;;														#? Break up arguments for multiple searches
+				-a|-all) all=1;;																#? Prints back found line including key
+				-l|-line) line_nr="$2"; shift;;													#? Set target line if no key is available
+				-ss|-source-string) input="$2"; shift;;											#? Argument string as source
+				-sf|-source-file) input="$(<"$2")"; shift;;  									#? File as source
+				-sv|-source-var) input="${!2}"; shift;;											#? Variable as source
+				-sa|-source-array) local -n tmp_array=$2; input="${tmp_array[*]}"; shift;;		#? Array as source
+				-fp|-floating-point) reg="[0-9]?(\.|\,)[0-9]*"; match=1;;						#? Match floating point value
+				-math) math="$2"; shift;;														#? Perform math on a integer value, "x" represents value, only works if "integer" argument is given
+				-i|-integer) reg="[0-9]+(\.|\,)?[0-9]*"; int=1; match=1;;						#? Match integer value
+				-r|-remove) remove+=("$2"); shift;;												#? Format output by removing entered regex, can be used multiple times
+				-v|-variable-out) local -n found="$2"; ext_var=1; shift;;						#? Output to variable
+				-map|-map-array) local -n array_out="$2"; ext_var=1; ext_arr=1; shift;;			#? Map output to array
+			esac
+			shift
+		done
+
+		if [[ -z $input ]]; then return 1; fi
+		if [[ -z $line_nr && -z $key ]]; then line_nr=1; fi
+
+		while IFS='' read -r input_line; do
+			((++current_line))
+			if [[ -n $line_nr && $current_line -eq $line_nr || -z $line_nr && -n $key && ${input_line/${key}/} != "$input_line" ]]; then
+				if [[ -n $all ]]; then 
+					found="${input_line}"
+					break
+
+				elif [[ -z $match && -z $match_key && -z $reg ]]; then
+					found="${input_line/${key}/}"
+					break
+
+				else 
+					line_array=(${input_line/${key}/${key// /}})
+
+				fi
+
+				for line_val in "${line_array[@]}"; do
+					if [[ -n $match_key && $line_val == "${key// /}" ]]; then
+						if ((match_key<0 & line_pos+match_key>=0)) || ((match_key>=0 & line_pos+match_key<${#line_array[@]})); then
+							found="${line_array[$((line_pos+match_key))]}"
+							break 2
+						else 
+							return 1
+						fi
+
+					elif [[ -n $match_key ]]; then
+						((++line_pos))
+
+					elif [[ -n $reg && $line_val =~ ^${reg}$ || -z $reg && -n $match ]]; then
+						if ((line_pos==match)); then
+							found=${line_val}
+							break 2
+						fi
+						((++line_pos))
+					fi
+				done
+			fi
+		done <<<"${input}"
+
+		if [[ -z $found ]]; then return 1; fi
+
+		if [[ -n ${remove[*]} ]]; then
+			for removing in "${remove[@]}"; do
+				found="${found//${removing}/}"
+			done
+		fi
+
+		if [[ -n $int && $found =~ . ]]; then
+			found=${found%.*}
+		fi
+
+		if [[ -n $math && -n $int ]]; then
+			math="${math//x/$found}"
+			found=$((${math}))
+		fi
+
+		if (($#>0)); then
+			input="${found}"
+			unset key match match_key all reg found int 'remove[@]' current_line
+			line_pos=1
+		fi
+
+	done
+	
+	if [[ -z $ext_var ]]; then echo "${found}"; fi
+	if [[ -n $ext_arr ]]; then array_out=(${found}); fi
+}
+
+cur_pos() { #? Get cursor postion, argument "line" prints current line, argument "col" prints current column, no argument prints both in format "line column"
+    local line col 
+    IFS=';' read -sdR -p $'\E[6n' line col
+    if [[ -z $1 || $1 == "line" ]]; then echo -n "${line#*[}${1:-" "}"; fi
+	if [[ -z $1 || $1 == "col" ]]; then echo -n "$col"; fi
+}
+
+create_box() { #? Draw a box with an optional titlebar and title at given location
+	local width height col line title ltype hpos vpos i hlines vlines color line_color sm_title c_rev=0 box_out ext_var fill
+	until (($#==0)); do
+		case $1 in
+			-f|-full) col=1; line=1; width=$((tty_width)); height=$((tty_height));;							#? Use full terminal size for box 
+			-c|-col) if [[ $2 =~ ^[0-9]*$ ]]; then col=$2; shift; fi;; 										#? Column position to start box
+			-l|-line) if [[ $2 =~ ^[0-9]*$ ]]; then line=$2; shift; fi;; 									#? Line position to start box
+			-w|-width) if [[ $2 =~ ^[0-9]*$ ]]; then width=$2; shift; fi;; 									#? Width of box
+			-h|-height) if [[ $2 =~ ^[0-9]*$ ]]; then height=$2; shift; fi;; 								#? Height of box
+			-tb|-titlebar) if [[ -n $2 ]]; then title="$2"; shift; fi;;										#? Draw titlebar and title
+			-t|-title) if [[ -n $2 ]]; then title="$2"; sm_title=1; shift; fi;;								#? Draw title without titlebar
+			-s|-single) ltype="single";;																	#? Use single lines
+			-d|-double) ltype="double";;																	#? Use double lines
+			-lc|-line-color) line_color=$2; shift;;															#? Color of the lines
+			-fill) fill=1;;
+			-v|-variable) local -n box_out=$2; ext_var=1; shift;;											#? Output box to a variable
+		esac
+		shift
+	done
+	if [[ -z $col || -z $line || -z $width || -z $height ]]; then return; fi
+
+	ltype=${ltype:-"single"}
+	vlines+=("$col" "$((col+width-1))")
+	hlines+=("$line" "$((line+height-1))")
+
+	print -v box_out -rs
+
+	#* Fill box if enabled
+	if [[ -n $fill ]]; then
+		for((i=line+1;i<line+height-1;i++)); do
+			print -v box_out -m $i $((col+1)) -rp $((width-2)) -t " "
+		done
+	fi
+
+	#* Draw all horizontal lines
+	print -v box_out -fg ${line_color:-66}
+	for hpos in "${hlines[@]}"; do
+		print -v box_out -m $hpos $col -rp $((width-1)) -t "${box[${ltype}_hor_line]}"
+	done
+
+	#* Draw all vertical lines
+	for vpos in "${vlines[@]}"; do
+		print -v box_out -m $line $vpos
+		for((hpos=line;hpos<=line+height-1;hpos++)); do
+			print -v box_out -m $hpos $vpos -t "${box[${ltype}_vert_line]}"
+		done
+	done
+
+	#* Draw corners
+	print -v box_out -m $line $col -t "${box[${ltype}_left_corner_up]}"
+	print -v box_out -m $line $((col+width-1)) -t "${box[${ltype}_right_corner_up]}"
+	print -v box_out -m $((line+height-1)) $col -t "${box[${ltype}_left_corner_down]}"
+	print -v box_out -m $((line+height-1)) $((col+width-1)) -t "${box[${ltype}_right_corner_down]}"
+
+	#* Draw titlebar and print title if set
+	if [[ -n $title && -z $sm_title ]]; then
+		print -v box_out -m $((line+2)) $col
+		print -v box_out -rp $((width-1)) -t "${box[single_hor_line]}"
+		print -v box_out -m $((line+2)) $col -t "${box[${ltype}_title_left]}"
+		print -v box_out -m $((line+2)) $((col+width-1)) -t "${box[${ltype}_title_right]}"
+		print -v box_out -m $((line+1)) $((col+1))
+		color=0
+		for((i=2;i<width;i++)); do
+			print -v box_out -bg $color 0 0 -t " "
+			if ((c_rev==0)); then ((color++)); if ((color>=width/2)); then c_rev=1; fi
+			elif ((c_rev==1)); then ((--color)); if ((color<=0)); then c_rev=0; fi; fi
+		done
+		print -v box_out -m $((line+1)) $((col+1)) -bg $((width/2)) 0 0 -fg ee -b -jc $((width-2)) -trans -t "$title"
+
+	#* Draw small title without titlebar
+	elif [[ -n $title && -n $sm_title ]]; then
+		print -v box_out -m $line $((col+2)) -t "┤" -fg ee -b -t "$title" -rs -fg ${line_color:-66} -t "├"
+	fi
+
+	print -v box_out -rs -m $((line+1)) $((col+1))
+
+	if [[ -z $ext_var ]]; then echo -en "${box_out}"; fi	
+	
+	
+}
+
+create_meter() { 	#? Create a horizontal percentage meter, usage; create_meter <value 0-100>
+					#? Optional arguments: [-p, -place <line> <col>] [-w, -width <columns>] [-b, -block-size "small"|"big"] [-f, -fill-empty] 
+					#? [-c, -color "array-name"] [-i, -invert-color] [-v, -variable "variable-name"]
+	if [[ -z $1 ]]; then return; fi
+	local val width colors color block_size block i fill_empty col line var ext_var out meter_var print_var invert
+
+	#* Argument parsing
+	until (($#==0)); do
+		case $1 in
+			-p|-place) if [[ $2 =~ ^[0-9]+$ && $3 =~ ^[0-9]+$ ]]; then line=$2; col=$3; shift 2; fi;;			#? Placement for meter
+			-w|-width) width=$2; shift;;																		#? Width of meter in columns
+			-c|-color) local -n colors=$2; shift;;																#? Name of an array containing colors from index 0-100
+			-i|-invert) invert=1;;																				#? Invert meter
+			-b|-block-size) block_size=$2; shift;;																#? Size of blocks used, small or big
+			-f|-fill-empty) fill_empty=1;;																		#? Fill unused space with dark blocks
+			-v|-variable) local -n meter_var=$2; ext_var=1; shift;;												#? Output meter to a variable
+			*) if [[ $1 =~ ^[0-9]+$ ]]; then val=$1; fi;;
+		esac
+		shift
+	done
+
+	if [[ -z $val ]]; then return; fi
+
+	#* Set default width if not given and set block size
+	width=${width:-10}
+	if [[ $block_size == "big" ]]; then block="■"; bg_color=30
+	else block="￭"; bg_color=30; fi
+
+	#* If no color array was given, create a simple greyscale array
+	if [[ -z $colors ]]; then
+		for ((i=0,ic=50;i<=100;i++,ic=ic+2)); do
+			colors[i]="${ic} ${ic} ${ic}"
+		done
+	fi
+
+	#* Create the meter
+	meter_var=""
+	if [[ -n $line && -n $col ]]; then print -v meter_var -rs -m $line $col
+	else print -v meter_var -rs; fi
+
+	if [[ -n $invert ]]; then print -v meter_var -r $((width+1)); fi
+	for((i=1;i<=width;i++)); do
+		if [[ -n $invert ]]; then print -v meter_var -l 2; fi
+
+		if ((val>=i*100/width)); then 
+			print -v meter_var -fg ${colors[$((i*100/width))]} -t "${block}"
+		elif ((fill_empty==1)); then
+			if [[ -n $invert ]]; then print -v meter_var -l $((width-i)); fi
+			print -v meter_var -fg $bg_color -rp $((1+width-i)) -t "${block}"; break
+		else
+			if [[ -n $invert ]]; then break; print -v meter_var -l $((1+width-i))
+			else print -v meter_var -r $((1+width-i)); break; fi
+		fi
+	done
+	if [[ -z $ext_var ]]; then echo -en "${meter_var}"; fi	
+}
+
+create_graph() { 	#? Create a graph from an array of percentage values, usage; 	create_graph <options> <value-array>
+					#? Create a graph from an array of non percentage values:       create_graph <options> <-max "max value"> <value-array>
+					#? Add a value to existing graph; 								create_graph [-i, -invert] [-max "max value"] -add-value "graph_array" <value>
+					#? Add last value from an array to existing graph; 				create_graph [-i, -invert] [-max "max value"] -add-last "graph_array" "value-array"
+					#? Options: < -d, -dimensions <line> <col> <height> <width> > [-i, -invert] [-n, -no-guide] [-c, -color "array-name"] [-o, -output-array "variable-name"]
+	if [[ -z $1 ]]; then return; fi
+	local val col s_col line s_line height s_height width s_width colors color i var ext_var out side_num side_nums=1 add add_array invert no_guide max
+	local -a graph_array input_array
+
+	#* Argument parsing
+	until (($#==0)); do
+		case $1 in
+			-d|-dimensions) if [[ $2 =~ ^[0-9]+$ && $3 =~ ^[0-9]+$ && $3 =~ ^[0-9]+$ && $4 =~ ^[0-9]+$ ]]; then 				#? Graph dimensions
+					line=$2; col=$3; height=$4; width=$5; shift 4; fi;;
+			-c|-color) local -n colors=$2; shift;;																				#? Name of an array containing colors from index 0-100
+			-o|-output-array) local -n output_array=$2; ext_var=1; shift;;														#? Output meter to an array				
+			-add-value) if [[ $3 =~ ^[0-9]+$ ]]; then 																			#? Add a value to existing graph
+					local -n output_array=$2; add=$3; break
+					else return; fi;;
+			-add-last) local -n output_array=$2; local -n add_array=$3; add=${add_array[-1]}; break;;							#? Add last value from array to existing graph
+			-i|-invert) invert=1;;																								#? Invert graph, drawing from top to bottom
+			-n|-no-guide) no_guide=1;;																							#? Don't print side and bottom guide lines
+			-max) if [[ $2 =~ ^[0-9]+$ ]]; then max=$2; shift; fi;;																#? Needed max value for non percentage arrays
+			*) local -n tmp_in_array=$1; input_array=("${tmp_in_array[@]}");;
+		esac
+		shift
+	done
+
+	if [[ -z $no_guide ]]; then 
+		((--height))
+	else
+		if [[ -n $invert ]]; then ((line--)); fi
+	fi
+
+
+	if ((width<3)); then width=3; fi
+	if ((height<1)); then height=1; fi
+
+
+	#* If argument "add" was passed check for existing graph and make room for new value(s)
+	local add_start add_end
+	if [[ -n $add ]]; then
+		local cut_left search
+		if [[ -n ${input_array[0]} ]]; then return; fi
+		if [[ -n $output_array ]]; then
+			graph_array=("${output_array[@]}")
+			if [[ -z ${graph_array[0]} ]]; then return; fi
+		else 
+			return
+		fi
+		height=$((${#graph_array[@]}-1))
+		input_array[0]=${add}
+
+		#* Remove last value in current graph
+
+		for ((i=0;i<height;i++)); do
+			cut_left="${graph_array[i]%m*}"
+			search=$((${#cut_left}+1))
+			graph_array[i]="${graph_array[i]::$search}${graph_array[i]:$((search+1))}"
+		done
+
+	fi
+
+	#* Initialize graph if no "add" argument was given
+	if [[ -z $add ]]; then
+		#* Scale down graph one line if height is even
+		local inv_offset h_inv normal_vals=1
+		local -a side_num=(100 0) g_char=(" ⡇" " ⠓" "⠒") g_index
+
+		if [[ -n $invert ]]; then
+			for((i=height;i>=0;i--)); do
+				g_index+=($i)
+			done
+			
+		else
+			for((i=0;i<=height;i++)); do
+				g_index+=($i)
+			done
+		fi
+			
+		if [[ -n $no_guide ]]; then unset normal_vals
+		elif [[ -n $invert ]]; then g_char=(" ⡇" " ⡤" "⠤")
+		fi
+
+		#* Set up graph array print side numbers and lines
+		print -v graph_array[0] -rs 
+		print -v graph_array[0] -m $((line+g_index[0])) ${col} ${normal_vals:+-jr 3 -fg ee -b -t "${side_num[0]}" -rs -fg 90 -t "${g_char[0]}"} -fg ${colors[100]}
+		for((i=1;i<height;i++)); do
+			print -v graph_array[i] -m $((line+g_index[i])) ${col} ${normal_vals:+-r 3 -fg 90 -t "${g_char[0]}"} -fg ${colors[$((100-i*100/height))]}
+		done
+		
+		if [[ -z $no_guide ]]; then width=$((width-5)); fi
+		
+		graph_array[height]=""
+		if [[ -z $no_guide ]]; then
+			print -v graph_array[$height] -m $((line+g_index[(-1)])) ${col} -jr 3 -fg ee -b -t "${side_num[1]}" -rs -fg 90 -t "${g_char[1]}" -rp ${width} -t "${g_char[2]}"
+		fi
+		
+		#* If no color array was given, create a simple greyscale array
+		if [[ -z $colors ]]; then
+			for ((i=0,ic=50;i<=100;i++,ic=ic+2)); do
+				colors[i]="${ic} ${ic} ${ic}"
+			done
+		fi
+	fi
+
+	#* Create the graph
+	local value_width x y a cur_value prev_value=100 symbol tmp_out compare found count virt_height=$((height*10))
+	if [[ -n $add ]]; then
+		value_width=1
+	elif ((${#input_array[@]}<=width)); then 
+		value_width=${#input_array[@]}; 
+	else
+		value_width=${width}
+		input_array=("${input_array[@]:(-$width)}")
+	fi
+	
+	if [[ -n $invert ]]; then
+		y=$((height-1))
+		done_val="-1"
+	else
+		y=0
+		done_val=$height
+	fi
+
+	#* Convert input array to percentage values of max if a max value was given
+	if [[ -n $max ]]; then
+		for((i=0;i<${#input_array[@]};i++)); do
+			if ((input_array[i]>=max)); then
+				input_array[i]=100
+			else
+				input_array[i]=$((input_array[i]*100/max))
+			fi		
+		done
+	fi
+		
+	until ((y==done_val)); do
+
+		#* Print spaces to right-justify graph if number of values is less than graph width
+		if [[ -z $add ]] && ((value_width<width)); then print -v graph_array[y] -rp $((width-value_width)) -t " "; fi
+		
+		cur_value=$(( virt_height-(y*10) ))
+		next_value=$(( virt_height-((y+1)*10) ))
+
+		count=0
+		x=0
+
+		#* Create graph by walking through all values for each line, speed up by counting similar values and print once, when difference is met
+		while ((x<value_width)); do
+
+			#* Print empty space if current value is less than percentage for current line
+			while ((x<value_width & input_array[offset+x]*virt_height/100<next_value)); do
+				((++count))
+				((++x))
+			done
+			if ((count>0)); then
+				print -v graph_array[y] -rp ${count} -t " "
+				count=0
+			fi
+
+			#* Print current value in percent relative to graph size if current value is less than line percentage but greater than next line percentage
+			while ((x<value_width & input_array[x]*virt_height/100<cur_value & input_array[x]*virt_height/100>=next_value)); do
+				print -v graph_array[y] -t "${graph_symbol[${invert:+-}$(( (input_array[x]*virt_height/100)-next_value ))]}"
+				((++x))
+			done
+
+			#* Print full block if current value is greater than percentage for current line
+			while ((x<value_width & input_array[x]*virt_height/100==cur_value)) || ((x<value_width & input_array[x]*virt_height/100>cur_value)); do
+				((++count))
+				((++x))
+			done
+			if ((count>0)); then
+				print -v graph_array[y] -rp ${count} -t "${graph_symbol[10]}"
+				count=0
+			fi
+		done
+	
+	if [[ -n $invert ]]; then
+		((y--)) || true
+	else
+		((++y))
+	fi
+	done
+	
+	#* Echo out graph if no argument for a output array was given
+	if [[ -z $ext_var && -z $add ]]; then echo -en "${graph_array[*]}"
+	else output_array=("${graph_array[@]}"); fi	
+}
+
+create_mini_graph() { 	#? Create a one line high graph from an array of percentage values, usage; 	create_mini_graph <options> <value-array>
+						#? Add a value to existing graph; 						create_mini_graph [-i, -invert] [-nc, -no-color] [-c, -color "array-name"] -add-value "graph_variable" <value>
+						#? Add last value from an array to existing graph; 		create_mini_graph [-i, -invert] [-nc, -no-color] [-c, -color "array-name"] -add-last "graph_variable" "value-array"
+						#? Options: [-w, -width <width>] [-i, -invert] [-nc, -no-color] [-c, -color "array-name"] [-o, -output-variable "variable-name"]
+	if [[ -z $1 ]]; then return; fi
+	local val col s_col line s_line height s_height width s_width colors color i var ext_var out side_num side_nums=1 add invert no_guide graph_var no_color color_value
+
+	#* Argument parsing
+	until (($#==0)); do
+		case $1 in
+			-w|-width) if [[ $2 =~ ^[0-9]+$ ]]; then width=$2; shift; fi;;									 				#? Graph width
+			-c|-color) local -n colors=$2; shift;;																			#? Name of an array containing colors from index 0-100
+			-nc|-no-color) no_color=1;;																						#? Set no color
+			-o|-output-variable) local -n output_var=$2; ext_var=1; shift;;													#? Output graph to a variable
+			-add-value) if [[ $3 =~ ^[0-9]+$ ]]; then 																		#? Add a value to existing graph
+					local -n output_var=$2; add=$3; break
+					else return; fi;;
+			-add-last) local -n output_var=$2 add_array=$3; add="${add_array[-1]}"; break;; 								#? Add last value from array to existing graph
+			-i|-invert) invert=1;;																							#? Invert graph, drawing from top to bottom
+			*) local -n input_array=$1;;
+		esac
+		shift
+	done
+
+	if ((width<1)); then width=1; fi
+
+	#* If argument "add" was passed check for existing graph and make room for new value(s)
+	local add_start add_end
+	if [[ -n $add ]]; then
+		local cut_left search
+		#if [[ -n ${input_array[0]} ]]; then return; fi
+		if [[ -n $output_var ]]; then
+			graph_var="${output_var}"
+			if [[ -z ${graph_var} ]]; then return; fi
+		else 
+			return
+		fi
+		
+		declare -a input_array
+		input_array[0]=${add}
+
+		#* Remove last value in current graph
+		if [[ -n ${graph_var} && -z $no_color ]]; then
+			if [[ ${graph_var::5} == "\e[1C" ]]; then
+				graph_var="${graph_var#'\e[1C'}"
+			else
+				cut_left="${graph_var%%m*}"
+				search=$((${#cut_left}+1))
+				graph_var="${graph_var:$((search+1))}"
+			fi
+		elif [[ -n ${graph_var} && -n $no_color ]]; then
+			if [[ ${graph_var::5} == "\e[1C" ]]; then
+				#cut_left="${graph_var%%C*}"
+				#search=$((${#cut_left}+1))
+				#graph_var="${graph_var:$((search))}"
+				graph_var="${graph_var#'\e[1C'}"
+			else
+				graph_var="${graph_var:1}"
+			fi
+		fi
+	fi
+
+	
+	#* If no color array was given, create a simple greyscale array
+	if [[ -z $colors && -z $no_color ]]; then
+		for ((i=0,ic=50;i<=100;i++,ic=ic+2)); do
+			colors[i]="${ic} ${ic} ${ic}"
+		done
+	fi
+	
+
+	#* Create the graph
+	local value_width x=0 y a cur_value virt_height=$((height*10)) offset=0 org_value
+	if [[ -n $add ]]; then
+		value_width=1
+	elif ((${#input_array[@]}<=width)); then 
+		value_width=${#input_array[@]}; 
+	else
+		value_width=${width}
+		offset=$((${#input_array[@]}-width))
+	fi
+
+	#* Print spaces to right-justify graph if number of values is less than graph width
+		if [[ -z $add && -z $no_color ]] && ((value_width<width)); then print -v graph_var -rp $((width-value_width)) -t "\e[1C"	
+		elif [[ -z $add && -n $no_color ]] && ((value_width<width)); then print -v graph_var -rp $((width-value_width)) -t "\e[1C"; fi		
+		#* Create graph
+		while ((x<value_width)); do
+			#* Round current input_array value divided by 10 to closest whole number
+			org_value=${input_array[offset+x]}
+			if ((org_value==100)); then cur_value=10
+			elif [[ ${#org_value} -gt 1 && ${org_value:(-1)} -ge 5 ]]; then cur_value=$((${org_value::1}+1))
+			elif [[ ${#org_value} -gt 1 && ${org_value:(-1)} -lt 5 ]]; then cur_value=$((${org_value::1}))
+			elif [[ ${org_value:(-1)} -ge 5 ]]; then cur_value=1
+			else cur_value=0
+			fi
+			if [[ -z $no_color ]]; then
+				color="-fg ${colors[$org_value]} "
+			else
+				color=""
+			fi
+
+			if [[ $cur_value == 0 ]]; then
+				print -v graph_var -t "\e[1C"
+			else
+				print -v graph_var ${color}-t "${graph_symbol[${invert:+-}$cur_value]}"
+			fi
+			((++x))
+		done	
+	
+	#* Echo out graph if no argument for a output array was given
+	if [[ -z $ext_var && -z $add ]]; then echo -en "${graph_var}"
+	else output_var="${graph_var}"; fi	
+}
+
+print() {	#? Print text, set true-color foreground/background color, add effects, center text, move cursor, save cursor position and restore cursor postion
+			#? Effects: [-fg, -foreground <RGB Hex>|<R Dec> <G Dec> <B Dec>] [-bg, -background <RGB Hex>|<R Dec> <G Dec> <B Dec>] [-rs, -reset] [-/+b, -/+bold] [-/+da, -/+dark]
+			#? [-/+ul, -/+underline] [-/+i, -/+italic] [-/+bl, -/+blink] [-f, -font "sans-serif|script|fraktur|monospace|double-struck"]
+			#? Manipulation: [-m, -move <line> <column>] [-l, -left <x>] [-r, -right <x>] [-u, -up <x>] [-d, -down <x>] [-c, -center] [-sc, -save] [-rc, -restore]
+			#? [-jl, -justify-left <width>] [-jr, -justify-right <width>] [-jc, -justify-center <width>] [-rp, -repeat <x>]
+			#? Text: [-v, -variable "variable-name"] [-stdin] [-t, -text "string"] ["string"]
+	
+	#* Return if no arguments is given
+	if [[ -z $1 ]]; then return; fi
+
+	#* Just echo and return if only one argument and not a valid option
+	if [[ $# -eq 1 && ${1::1} != "-"  ]]; then echo -en "$1"; return; fi
+	
+	local effect color add_command text text2 esc center clear fgc bgc fg_bg_div tmp tmp_len bold italic custom_font val var out ext_var hex="16#"
+	local justify_left justify_right justify_center repeat r_tmp trans
+	
+	
+	#* Loop function until we are out of arguments
+	until (($#==0)); do
+
+		#* Argument parsing
+		until (($#==0)); do
+			case $1 in
+				-t|-text) if [[ -n $2 ]]; then text="$2"; shift 2; break; fi;;																#? String to print
+				-stdin) text="$(</dev/stdin)"; shift; break;;																				#? Print from stdin
+				-fg|-foreground)	#? Set text foreground color, accepts either 6 digit hexadecimal "#RRGGBB", 2 digit hex (greyscale) or decimal RGB "<0-255> <0-255> <0-255>"
+					if [[ ${2::1} == "#" ]]; then val=${2:1}; else val=${2}; fi
+					if [[ $2 =~ ^[0-9]+$ && $3 =~ ^[0-9]+$ && $4 =~ ^[0-9]+$ ]]; then fgc="\e[38;2;$2;$3;$4m"; shift 3
+					elif [[ ${#val} == 6 && $val =~ ^[0-9a-fA-F]*$ ]]; then fgc="\e[38;2;$((${hex}${val:0:2}));$((${hex}${val:2:2}));$((${hex}${val:4:2}))m"; shift
+					elif [[ ${#val} == 2 && $val =~ ^[0-9a-fA-F]*$ ]]; then fgc="\e[38;2;$((${hex}${val:0:2}));$((${hex}${val:0:2}));$((${hex}${val:0:2}))m"; shift
+					fi
+					;;										
+				-bg|-background)	#? Set text background color, accepts either 6 digit hexadecimal "#RRGGBB", 2 digit hex (greyscale) or decimal RGB "<0-255> <0-255> <0-255>"
+					if [[ ${2::1} == "#" ]]; then val=${2:1}; else val=${2}; fi
+					if [[ $2 =~ ^[0-9]+$ && $3 =~ ^[0-9]+$ && $4 =~ ^[0-9]+$ ]]; then bgc="\e[48;2;$2;$3;$4m"; shift 3
+					elif [[ ${#val} == 6 && $val =~ ^[0-9a-fA-F]*$ ]]; then bgc="\e[48;2;$((${hex}${val:0:2}));$((${hex}${val:2:2}));$((${hex}${val:4:2}))m"; shift
+					elif [[ ${#val} == 2 && $val =~ ^[0-9a-fA-F]*$ ]]; then bgc="\e[48;2;$((${hex}${val:0:2}));$((${hex}${val:0:2}));$((${hex}${val:0:2}))m"; shift
+					fi
+					;;
+				-c|-center) center=1;;																										#? Center text horizontally on screen
+				-rs|-reset) effect="0${effect}";;																							#? Reset text colors and effects
+				-b|-bold) effect="${effect}${effect:+;}1"; bold=1;;																			#? Enable bold text
+				+b|+bold) effect="${effect}${effect:+;}21"; bold=0;;																		#? Disable bold text
+				-da|-dark) effect="${effect}${effect:+;}2";;																				#? Enable dark text
+				+da|+dark) effect="${effect}${effect:+;}22";;																				#? Disable dark text
+				-i|-italic) effect="${effect}${effect:+;}3"; italic=1;;																		#? Enable italic text
+				+i|+italic) effect="${effect}${effect:+;}23"; italic=0;;																	#? Disable italic text
+				-ul|-underline) effect="${effect}${effect:+;}4";;																			#? Enable underlined text
+				+ul|+underline) effect="${effect}${effect:+;}24";;																			#? Disable underlined text
+				-bl|-blink) effect="${effect}${effect:+;}5";;																				#? Enable blinking text
+				+bl|+blink) effect="${effect}${effect:+;}25";;																				#? Disable blinking text
+				-f|-font) if [[ $2 =~ ^(sans-serif|script|fraktur|monospace|double-struck)$ ]]; then custom_font="$2"; shift; fi;;			#? Set custom font			
+				-m|-move) if [[ $2 =~ ^[0-9\-]+$ && $3 =~ ^[0-9\-]+$ ]]; then add_command="${add_command}\e[${2};${3}f"; shift 2; fi;;		#? Move to postion "LINE" "COLUMN"
+				-l|-left) if [[ $2 =~ ^[0-9\-]+$ ]]; then add_command="${add_command}\e[${2}D"; shift; fi;;									#? Move left x columns
+				-r|-right) if [[ $2 =~ ^[0-9\-]+$ ]]; then add_command="${add_command}\e[${2}C"; shift; fi;;								#? Move right x columns
+				-u|-up) if [[ $2 =~ ^[0-9\-]+$ ]]; then add_command="${add_command}\e[${2}A"; shift; fi;;									#? Move up x lines
+				-d|-down) if [[ $2 =~ ^[0-9\-]+$ ]]; then add_command="${add_command}\e[${2}B"; shift; fi;;									#? Move down x lines
+				-jl|-justify-left) if [[ $2 =~ ^[0-9\-]+$ ]]; then justify_left="${2}"; shift; fi;;								#? Justify string left within given width
+				-jr|-justify-right) if [[ $2 =~ ^[0-9\-]+$ ]]; then justify_right="${2}"; shift; fi;;							#? Justify string right within given width
+				-jc|-justify-center) if [[ $2 =~ ^[0-9\-]+$ ]]; then justify_center="${2}"; shift; fi;;							#? Justify string center within given width
+				-rp|-repeat) if [[ $2 =~ ^[0-9]+$ ]]; then repeat=${2}; shift; fi;;															#? Repeat next string x number of times
+				-sc|-save) add_command="\e[s${add_command}";;																				#? Save cursor position
+				-rc|-restore) add_command="${add_command}\e[u";;																			#? Restore cursor position
+				-trans) trans=1;;																											#? Make whitespace transparent
+				-v|-variable) local -n var=$2; ext_var=1; shift;;																			#? Send output to a variable, appending if not unset	
+				*) text="$1"; shift; break;;																								#? Assumes text string if no argument is found
+			esac
+			shift
+		done
+
+		#* Repeat string if repeat is enabled
+		if [[ -n $repeat ]]; then
+			printf -v r_tmp "%${repeat}s" ""
+			text="${r_tmp// /$text}"
+		fi
+
+		#* Set correct placement for screen centered text
+		if ((center==1 & ${#text}>0 & ${#text}<tty_width-4)); then
+			add_command="${add_command}\e[${tty_width}D\e[$(( (tty_width/2)-(${#text}/2) ))C"
+		fi
+
+		#* Convert text string to custom font if set and remove non working effects
+		if [[ -n $custom_font ]]; then
+			unset effect
+			text=$(set_font "${custom_font}${bold:+" bold"}${italic:+" italic"}" "${text}")
+		fi
+
+		#* Set text justification if set
+		if [[ -n $justify_left ]] && ((${#text}<justify_left)); then
+			printf -v text "%s%$((justify_left-${#text}))s" "${text}" ""
+		elif [[ -n $justify_right ]] && ((${#text}<justify_right)); then
+			printf -v text "%$((justify_right-${#text}))s%s" "" "${text}"
+		elif [[ -n $justify_center ]] && ((${#text}<justify_center)); then
+			printf -v text "%$(( (justify_center/2)-(${#text}/2) ))s%s" "" "${text}"
+			printf -v text "%s%-$((justify_center-${#text}))s" "${text}" ""
+		fi
+
+		if [[ -n $trans ]]; then
+			text="${text// /'\e[1C'}"
+		fi
+
+		#* Create text string
+		if [[ -n $effect ]]; then effect="\e[${effect}m"; fi
+		out="${out}${add_command}${effect}${bgc}${fgc}${text}"
+		unset add_command effect fgc bgc center justify_left justify_right justify_center custom_font text repeat trans justify
+	done
+
+	#* Print the string to stdout if variable out hasn't been set
+	if [[ -z $ext_var ]]; then echo -en "$out"
+	else var="${var}${out}"; fi
+
+}
+
+collect_cpu() { #? Collects cpu stats from /proc/stat and compares with previously collected sample to get cpu usage
+				#? Returns cpu usage in array "cpu_usage", index 0 is usage for all threads, following indices corresponds to thread usage in multicore/hyperthreading cpus
+	local stat_array freq thread i threads=${cpu[threads]}
+
+	#* Get values from /proc/stat, compare to get cpu usage
+	thread=0
+	while ((thread<threads+1)) && read -ra stat_array; do
+	cpu[new_${thread}]=$((stat_array[1]+stat_array[2]+stat_array[3]+stat_array[4]))
+	cpu[idle_new_${thread}]=${stat_array[4]}
+	if [[ -n ${cpu[old_${thread}]} ]]; then cpu_usage[${thread}]=$(( ( 100*(${cpu[old_${thread}]}-${cpu[new_${thread}]}-${cpu[idle_old_${thread}]}+${cpu[idle_new_${thread}]}) ) / (${cpu[old_${thread}]}-${cpu[new_${thread}]}) )); fi
+	cpu[old_${thread}]=${cpu[new_${thread}]}
+	cpu[idle_old_${thread}]=${cpu[idle_new_${thread}]}
+	((++thread))
+	done </proc/stat
+
+	#* Copy cpu usage for cpu package and cores to cpu history arrays and trim earlier entries
+	if ((${#cpu_history[@]}>tty_width*2)); then
+		cpu_history=( "${cpu_history[@]:$tty_width}" "${cpu_usage[0]}")
+	else
+		cpu_history+=("${cpu_usage[0]}")
+	fi
+
+	# threads=${box[testing]} #! For testing, remove <--------------
+
+	for((i=1;i<=threads;i++)); do
+		local -n cpu_core_history="cpu_core_history_$i"
+		if ((${#cpu_core_history[@]}>20)); then
+			cpu_core_history=( "${cpu_core_history[@]:10}" "${cpu_usage[$i]}")
+		else
+			cpu_core_history+=("${cpu_usage[$i]}")
+		fi
+	done
+	
+
+	#* Get current cpu frequency from "/proc/cpuinfo" and convert to appropriate unit
+	if [[ -z ${cpu[no_cpu_info]} ]] && ! get_value -v cpu[freq] -sf "/proc/cpuinfo" -k "cpu MHz" -i; then
+		cpu[no_cpu_info]=1
+	fi
+	
+	#* If getting cpu frequency from "proc/cpuinfo" was unsuccessfull try "/sys/devices/../../scaling_cur_freq"
+	if [[ -n ${cpu[no_cpu_info]} ]]; then
+		get_value -v cpu[freq] -sf "/sys/devices/system/cpu/cpu$((${cpu[threads]}-1))/cpufreq/scaling_cur_freq" -i -math "x/1000"
+	fi
+
+	if ((${#cpu[freq]}>3)); then cpu[freq_string]="${cpu[freq]::-3}.${cpu[freq]:(-3):1} GHz"
+	else cpu[freq_string]="${cpu[freq]} MHz"; fi
+
+
+	#* Collect cpu temps if enabled
+	if [[ $check_temp == true ]]; then collect_cpu_temps; fi
+}
+
+collect_cpu_temps() { #? Collect cpu temperatures
+	local unit i it c div threads=${cpu[threads]} sens_var
+
+	#* Fetch output from "sensors" command to a variable
+	sens_var="$(sensors)"
+
+	#* Get CPU package temp
+	if get_value -v cpu[temp_0] -sv "sens_var" -k "Package*:" -mk 1; then
+
+		#* If successful get temperature unit, convert temp to integer and get high, crit and core temps
+		cpu[temp_unit]=${cpu[temp_0]:(-2)}; cpu[temp_0]=${cpu[temp_0]%.*}; if [[ ${cpu[temp_0]::1} == "+" ]]; then cpu[temp_0]=${cpu[temp_0]#+}; fi
+		if [[ -z ${cpu[temp_high]} ]]; then 
+			get_value -v "cpu[temp_high]" -sv "sens_var" -k "Package*high =" -m 2 -r "[^0-9.]" -b -i
+			get_value -v "cpu[temp_crit]" -sv "sens_var" -k "Package*crit =" -m 2 -r "[^0-9.]" -b -i
+		fi
+		for((i=0,it=1;i<threads;i++,it++)); do
+			if ! get_value -v "cpu[temp_${it}]" -sv "sens_var" -k "Core ${i}:" -mk 1 -r "[^0-9.-]" -b -i; then break; fi
+			#* If number of cores is less than number of threads copy current temp to "current core id"+"total cores"
+			if ((cpu[cores]<cpu[threads])); then
+				cpu[temp_$((it+cpu[cores]))]=${cpu[temp_${it}]}
+			fi
+		done
+
+		for((i=0;i<=threads;i++)); do
+			local -n cpu_temp_history="cpu_temp_history_$i"
+			if ((${#cpu_temp_history[@]}>15)); then
+				cpu_temp_history=( "${cpu_temp_history[@]:10}" "$(( (${cpu[temp_${i}]}-15)*100/(cpu[temp_crit]-15) ))")
+			else
+				cpu_temp_history+=("$(( (${cpu[temp_${i}]}-15)*100/(cpu[temp_crit]-15) ))")
+			fi
+		done
+		
+
+	#* If unsuccessful turn off temperature checking
+	else
+		check_temp="false"
+	fi
+}
+
+collect_mem() { #? Collect memory information from "/proc/meminfo"
+	((++mem[counter]))
+
+	if ((mem[counter]<10)); then return; fi
+	mem[counter]=0
+
+	local i tmp value array mem_info
+	local -a mem_array swap_array available=("mem")
+
+	#* Get memory and swap information from "/proc/meminfo" and calculate percentages
+	mem_info="$(</proc/meminfo)"
+	
+	get_value -v mem[total] -sv "mem_info" -k "MemTotal:" -i
+	get_value -v mem[available] -sv "mem_info" -k "MemAvailable:" -i
+	mem[available_percent]=$((mem[available]*100/mem[total]))
+	
+	mem[used]=$((mem[total]-mem[available]))
+	mem[used_percent]=$((mem[used]*100/mem[total]))
+	
+	get_value -v mem[free] -sv "mem_info" -k "MemFree:" -i
+	mem[free_percent]=$((mem[free]*100/mem[total]))
+	
+	get_value -v mem[cached] -sv "mem_info" -k "Cached:" -i
+	mem[cached_percent]=$((mem[cached]*100/mem[total]))
+
+	if [[ -n $swap_on ]] && get_value -v swap[total] -sv "mem_info" -k "SwapTotal:" -i && ((swap[total]>0)); then
+		get_value -v swap[free] -sv "mem_info" -k "SwapFree:" -i
+		swap[free_percent]=$((swap[free]*100/swap[total]))
+		
+		swap[used]=$((swap[total]-swap[free]))
+		swap[used_percent]=$((swap[used]*100/swap[total]))
+		
+		available+=("swap")
+	else
+		unset swap_on
+	fi
+
+	#* Convert values to floating point and humanize
+	for array in ${available[@]}; do
+		for value in total used free available cached; do
+			if [[ $array == "swap" && $value == "available" ]]; then break 2; fi
+			local -n this_value="${array}[${value}]" this_string="${array}[${value}_string]"
+			floating_humanizer -v this_string -s 1 -B "${this_value}"
+		done
+	done
+
+	#* Get disk information from "df" command
+	local df_array df_line line_array
+	unset 'disks_free[@]' 'disks_total[@]' 'disks_name[@]' 'disks_free_percent[@]'
+	readarray -t df_array < <(df -x squashfs -x tmpfs -x devtmpfs -x overlay)
+	for df_line in "${df_array[@]:1}"; do
+		line_array=(${df_line})
+
+		if [[ ${line_array[5]} == "/" ]]; then disks_name+=("root")
+		else disks_name+=("${line_array[5]##*/}"); fi
+		disks_total+=("$(floating_humanizer -s 1 -B ${line_array[1]})")
+		disks_used+=("$(floating_humanizer -s 1 -B ${line_array[2]})")
+		disks_used_percent+=("${line_array[4]%'%'}")
+		disks_free+=("$(floating_humanizer -s 1 -B ${line_array[3]})")
+		disks_free_percent+=("$((100-${line_array[4]%'%'}))")
+
+	done
+
+
+
+}
+
+collect_processes() { #? Collect process information and calculate accurate cpu usage
+	local argument="$1"
+	if [[ -n $skip_process_draw && $argument != "now" ]]; then return; fi
+	local width=${box[processes_width]} height=${box[processes_height]} format_args format_cmd readline sort symbol="▼" cpu_title options pid_string tmp selected
+	local -a grep_array
+
+	if [[ $argument == "now" ]]; then skip_process_draw=1; fi
+
+	if [[ -n ${proc[reverse]} ]]; then symbol="▲"; fi
+	case ${proc_sorting} in
+		"pid") selected="Pid:"; sort="pid";;
+		"program") selected="Program:"; sort="comm";;
+		"arguments") selected="Arguments:"; sort="args";;
+		"threads") selected="Threads:"; sort="thcount";;
+		"user") selected="User:"; sort="euser";;
+		"memory") selected="Mem%"; sort="pmem";;
+		"cpu lazy"|"cpu responsive") sort="pcpu"; selected="Cpu%";;
+	esac
+
+
+	#* Collect output from ps command to array
+	if ((width>60)); then format_args=",args:$(( width-(47+proc[pid_len]) ))=Arguments:"; format_cmd=15
+	else format_cmd=$(( width-(31+proc[pid_len]) )); fi
+	unset 'proc_array[@]' 'pid_array[@]'
+
+	if ((proc[detailed]==0)) && [[ -n ${proc[detailed_name]} ]]; then
+		unset 'proc[detailed_name]' 'proc[detailed_killed]' 'proc[detailed_cpu_int]' 'proc[detailed_cmd]'
+		unset 'proc[detailed_mem]' 'proc[detailed_mem_int]' 'proc[detailed_user]' 'proc[detailed_threads]'
+		unset 'detail_graph[@]' 'detail_mem_graph' 'detail_history[@]' 'detail_mem_history[@]'
+		unset 'proc[detailed_runtime]' 'proc[detailed_mem_string]' 'proc[detailed_parent_pid]' 'proc[detailed_parent_name]'
+	fi
+
+	unset 'proc[detailed_cpu]'
+
+	if [[ -z $filter ]]; then
+	 	options="-t"
+	fi
+
+	readarray ${options} proc_array < <(ps ax -o pid:${proc[pid_len]}=Pid:,comm:${format_cmd}=Program:${format_args},thcount:3=Tr:,euser:6=User:,pmem=Mem%,pcpu:10=Cpu% --sort ${proc[reverse]:--}${sort})
+	
+	proc_array[0]="${proc_array[0]/      Tr:/ Threads:}"
+	proc_array[0]="${proc_array[0]/ ${selected}/${symbol}${selected}}"
+
+	if [[ -n $filter ]]; then
+		grep_array[0]="${proc_array[0]}"
+	 	readarray -O 1 -t grep_array < <(echo -e " ${proc_array[*]:1}" | grep -e "${filter}" ${proc[detailed_pid]:+-e ${proc[detailed_pid]}} | cut -c 2- || true)
+		proc_array=("${grep_array[@]}")
+	fi
+
+	proc[pages]=$(( (${#proc_array[@]}-1)/(height-3)+1 ))
+	if ((proc[page]>proc[pages])); then proc[page]=${proc[pages]}; fi
+
+
+	#* Get accurate cpu usage by fetching and comparing values in /proc/"pid"/stat
+	local operations operation utime stime count time_elapsed cpu_percent_string rgb=231 step add proc_out tmp_value_array i pcpu_usage cpu_int tmp_percent breaking
+	local -a cpu_percent statfile work_array
+
+	#* Timestamp the values in milliseconds to accurately calculate cpu usage
+	get_ms proc[new_timestamp]
+	
+	for readline in "${proc_array[@]:1}"; do
+		 ((++count))
+
+		if ((count==height-3)); then
+			if [[ -n $filter || $proc_sorting == "cpu responsive" || ${proc[selected]} -gt 0 || ${proc[page]} -gt 1 ]]; then :
+			else breaking=1; fi
+		fi
+
+		get_key -save
+		if ((${#saved_key[@]}>0)); then return; fi
+
+		work_array=(${readline})
+
+		pid="${work_array[0]}"
+		pcpu_usage="${work_array[-1]}"
+
+
+		if [[ ! ${pid_history[*]} =~ ${pid} ]]; then
+			pid_history+=("${pid}")
+		fi
+
+		if [[ -n $filter || $proc_sorting == "cpu responsive" ]] && [[ ${proc_array[count]:${proc[pid_len]}:1} != " " ]]; then
+			unset pid_string
+			printf -v pid_string "%${proc[pid_len]}s" "${pid}"
+			proc_array[count]="${pid_string}${proc_array[count]#*${pid}}"
+		fi
+
+		if [[ -r "/proc/${pid}/stat" ]] && read -ra statfile </proc/${pid}/stat 2>/dev/null; then
+
+			utime=${statfile[13]}
+			stime=${statfile[14]}
+			
+			proc[new_${pid}_ticks]=$((utime+stime))
+		
+
+			if [[ -n ${proc[old_${pid}_ticks]} ]]; then
+
+				time_elapsed=$((proc[new_timestamp]-proc[old_timestamp]))
+				
+				#* Calculate current cpu usage for process, * 1000 (for conversion from ms to seconds) * 1000 (for conversion to floating point)
+				cpu_percent[count]=$(( ( ( ${proc[new_${pid}_ticks]}-${proc[old_${pid}_ticks]} ) * 1000 * 1000 ) / ( cpu[hz]*time_elapsed*cpu[threads] ) ))
+
+				if ((cpu_percent[count]<0)); then cpu_percent[count]=0
+				elif ((cpu_percent[count]>1000)); then cpu_percent[count]=1000; fi
+				
+				if ((${#cpu_percent[count]}<=3)); then
+					printf -v cpu_percent_string "%01d%s" "${cpu_percent[count]::-1}" ".${cpu_percent[count]:(-1)}"
+				else
+					cpu_percent_string=${cpu_percent[count]::-1}
+				fi
+
+				printf -v cpu_percent_string "%5s" "${cpu_percent_string::4}"
+
+				proc_array[count]="${proc_array[count]::-5}${cpu_percent_string}"
+
+
+				pid_graph="pid_${pid}_graph"
+				local -n pid_count="pid_${pid}_count"
+
+				printf -v cpu_int "%01d" "${cpu_percent[count]::-1}"
+
+				#* Get info for detailed box if enabled
+				if [[ ${pid} == "${proc[detailed_pid]}" ]]; then
+					if [[ -z ${proc[detailed_name]} ]]; then
+						local get_mem
+						local -a det_array
+						read -r proc[detailed_name] </proc/${pid}/comm ||true
+						proc[detailed_cmd]="$(tr '\000' ' ' </proc/${pid}/cmdline)"						
+						proc[detailed_name]="${proc[detailed_name]::15}"
+						det_array=($(ps -o ppid:4,euser:15 --no-headers -p $pid || true))	
+						proc[detailed_parent_pid]="${det_array[0]}"
+						proc[detailed_user]="${det_array[*]:1}"
+						proc[detailed_parent_name]="$(ps -o comm --no-headers -p ${det_array[0]} || true)"
+						get_mem=1
+					fi
+					proc[detailed_cpu]="${cpu_percent_string// /}"
+					proc[detailed_cpu_int]="${cpu_int}"
+					proc[detailed_threads]="${work_array[-4]}"
+					proc[detailed_runtime]="$(ps -o etime:4 --no-headers -p $pid || true)"
+
+					if [[ ${proc[detailed_mem]} != "${work_array[-2]}" || -n $get_mem ]] || ((++proc[detailed_mem_count]>5)); then
+						proc[detailed_mem_count]=0
+						proc[detailed_mem]="${work_array[-2]}"
+						proc[detailed_mem_int]="${proc[detailed_mem]/./}"
+						if [[ ${proc[detailed_mem_int]::1} == "0" ]]; then proc[detailed_mem_int]="${proc[detailed_mem_int]:1}0"; fi
+						#* Scale up low mem values to see any changes on mini graph
+						if ((proc[detailed_mem_int]>900)); then proc[detailed_mem_int]=$((proc[detailed_mem_int]/10))
+						elif ((proc[detailed_mem_int]>600)); then proc[detailed_mem_int]=$((proc[detailed_mem_int]/8))
+						elif ((proc[detailed_mem_int]>300)); then proc[detailed_mem_int]=$((proc[detailed_mem_int]/5))
+						elif ((proc[detailed_mem_int]>100)); then proc[detailed_mem_int]=$((proc[detailed_mem_int]/2))
+						elif ((proc[detailed_mem_int]<50)); then proc[detailed_mem_int]=$((proc[detailed_mem_int]*2)); fi
+						unset 'proc[detailed_mem_string]'
+						floating_humanizer -v proc[detailed_mem_string] -B -s 1 "$(ps -o rss:1 --no-headers -p ${pid} || true)"
+						if [[ -z ${proc[detailed_mem_string]} ]]; then proc[detailed_mem_string]="? Byte"; fi
+					fi
+					
+					#* Copy process cpu usage to history array and trim earlier entries
+					if ((${#detail_history[@]}>box[details_width]*2)); then
+						detail_history=( "${detail_history[@]:${box[details_width]}}" "$((cpu_int+4))")
+					else
+						detail_history+=("$((cpu_int+4))")
+					fi
+
+					#* Copy process mem usage to history array and trim earlier entries
+					if ((${#detail_mem_history[@]}>box[details_width])); then
+						detail_mem_history=( "${detail_mem_history[@]:$((box[details_width]/2))}" "${proc[detailed_mem_int]}")
+					else
+						detail_mem_history+=("${proc[detailed_mem_int]}")
+					fi
+
+					#* Remove selected process from array if process is excluded by filtering or not on first page
+					if [[ -n $filter && ! ${proc[detailed_name]} =~ $filter ]]; then
+						unset 'proc_array[count]'
+						cpu_int=0; pid_count=0
+					fi
+				fi
+
+				#* Create small graphs for all visible processes using more than 1% cpu time
+				if [[ ${cpu_int} -gt 0 ]]; then pid_count=5; fi
+
+				if [[ -z ${!pid_graph} && ${cpu_int} -gt 0 ]]; then
+						tmp_value_array=("$((cpu_int+4))")
+					create_mini_graph -o "pid_${pid}_graph" -nc -w 5 "tmp_value_array"
+				elif [[ ${pid_count} -gt 0 ]]; then
+					if [[ ${cpu_int} -gt 9 ]]; then
+						create_mini_graph -nc -add-value "pid_${pid}_graph" "$((cpu_int+20))"
+					else
+						create_mini_graph -nc -add-value "pid_${pid}_graph" "$((cpu_int+4))"
+					fi
+					
+					pid_count=$((${pid_count}-1))
+				elif [[ ${pid_count} == "0" ]]; then
+					unset "pid_${pid}_graph"
+					unset "pid_${pid}_count"
+				fi
+			else
+				tmp_percent="${proc_array[count]:(-5)}"; tmp_percent="${tmp_percent// /}"; if [[ ${tmp_percent//./} != "$tmp_percent" ]]; then tmp_percent="${tmp_percent::-2}"; fi
+				if ((tmp_percent>100)); then
+					proc_array[count]="${proc_array[count]::-5}  100"
+				fi
+			fi
+
+			proc[old_${pid}_ticks]=${proc[new_${pid}_ticks]}
+			
+		fi
+
+		if ((breaking==1)); then 
+			if [[ ${proc[detailed]} == "1" && -z ${proc[detailed_cpu]} ]] && ps ${proc[detailed_pid]} >/dev/null 2>&1; then
+				readarray ${options} -O ${#proc_array[@]} proc_array < <(ps -o pid:${proc[pid_len]}=Pid:,comm:${format_cmd}=Program:${format_args},thcount:3=Tr:,euser:6=User:,pmem=Mem%,pcpu:10=Cpu% --no-headers -p ${proc[detailed_pid]})
+			else
+				break
+			fi
+		fi
+
+	done
+
+
+	proc[old_timestamp]=${proc[new_timestamp]}
+
+	if ((proc[detailed]==1)) && [[ -z ${proc[detailed_cpu]} && -z ${proc[detailed_killed]} ]]; then proc[detailed_killed]=1; proc[detailed_change]=1
+	elif [[ -n ${proc[detailed_cpu]} ]]; then unset 'proc[detailed_killed]'; fi
+
+	#* Sort output array based on cpu usage if "cpu responsive" is selected
+	if [[ ${proc_sorting} == "cpu responsive" ]]; then
+		local -a sort_array
+		if [[ -z ${proc[reverse]} ]]; then local sort_rev="-r"; fi
+		sort_array[0]="${proc_array[0]}"
+		readarray -O 1 -t sort_array < <(printf "%s\n" "${proc_array[@]:1}" | awk '{ print $NF, $0 }' | sort -n -k1 ${sort_rev}| sed 's/^[0-9\.]* //')
+		proc_array=("${sort_array[@]}")
+	fi
+
+	#* Clear up memory by removing variables and graphs of no longer running processes
+	((++proc[general_counter]))
+	if ((proc[general_counter]>100)); then
+		proc[general_counter]=0
+		for ((i=0;i<${#pid_history[@]};i++)); do
+			if [[ -n ${pid_history[$i]} && ! -e /proc/${pid_history[$i]} ]]; then
+				unset "pid_${pid_history[i]}_graph"
+				unset "pid_${pid_history[i]}_count"
+				unset "proc[new_${pid_history[i]}_ticks]"
+				unset "proc[old_${pid_history[i]}_ticks]"
+				unset "pid_history[${i}]"
+			fi
+		done
+		pid_history=(${pid_history[@]})
+	fi
+
+}
+
+collect_net() { #? Collect information from "/proc/net/dev"
+	local operations operation direction index unit_selector speed speed_B total
+	local -a net_dev history_sorted history_last
+
+	if [[ $1 == "init" ]]; then 
+		for direction in "download" "upload"; do
+		net[${direction}_max]=0
+		net[${direction}_new_low]=0
+		net[${direction}_new_max]=0
+		net[${direction}_max_current]=0
+		net[${direction}_graph_max]=$((50<<10))
+		done
+	fi
+
+	#* Get the line with relevant net device from /proc/net/dev into array net_dev, index 1 is download, index 9 is upload
+	get_value -map net_dev -sf "/proc/net/dev" -k "${net[device]}" -a
+
+	#* Timestamp the values to accurately calculate values in seconds
+	get_ms net[new_timestamp]
+	for direction in "download" "upload"; do
+		if [[ $direction == "download" ]]; then index=1
+		else index=9; fi
+
+		net[new_${direction}]=${net_dev[index]}
+
+		if [[ -n ${net[old_${direction}]} ]]; then
+			#* Get total, convert to floating point and format string to best fitting unit in Bytes
+			floating_humanizer -Byte -v net[total_${direction}] ${net[new_${direction}]}
+			
+			#* Calculate current speeds: ("New value" - "Old value") * 1000(for ms to seconds) / ("new_timestamp" - "old_timestamp")
+			net[speed_${direction}]=$(( (${net[new_${direction}]}-${net[old_${direction}]})*1000/(net[new_timestamp]-net[old_timestamp]) ))
+
+			#* Convert to floating point and format string to best fitting unit in Bytes and Bits per second
+			floating_humanizer -Byte -per-second -v net[speed_${direction}_byteps] ${net[speed_${direction}]}
+			floating_humanizer -bit -per-second -v net[speed_${direction}_bitps] ${net[speed_${direction}]}
+
+			#* Update download and upload max values for graph
+			if ((${net[speed_${direction}]}>${net[${direction}_max]})); then
+				net[${direction}_max]=${net[speed_${direction}]}
+			fi
+
+			if ((${net[speed_${direction}]}>${net[${direction}_graph_max]})); then
+					((++net[${direction}_new_max]))
+					if ((net[${direction}_new_low]>0)); then ((net[${direction}_new_low]--)); fi
+			elif ((${net[${direction}_graph_max]}>10<<10 & ${net[speed_${direction}]}<${net[${direction}_graph_max]}/8)); then
+				((++net[${direction}_new_low]))
+				if ((net[${direction}_new_max]>0)); then ((net[${direction}_new_max]--)); fi
+			# else
+			# 	net[${direction}_new_low]=0
+			# 	net[${direction}_new_max]=0
+			fi
+
+			#* Copy download and upload speed to history arrays and trim earlier entries
+			local -n history="net_history_${direction}"
+			if ((${#history[@]}>box[net_width]*2)); then
+				history=( "${history[@]:${box[net_width]}}" "${net[speed_${direction}]}")
+			else
+				history+=("${net[speed_${direction}]}")
+			fi
+
+			#* Check for new max value and set flag to adjust resolution of graph if needed
+			if ((${net[${direction}_new_max]}>=5)); then
+				net[${direction}_graph_max]=$((${net[${direction}_max]}+(${net[${direction}_max]}/2) ))
+				net[${direction}_redraw]=1
+				net[${direction}_new_max]=0
+
+			#* If current max value isn't relevant, sort array to get the next largest value to set graph resolution
+			elif ((${net[${direction}_new_low]}>=5 & ${#history[@]}>5)); then
+				history_last=("${history[@]:(-5)}")
+				sort_array_int "history_last" "history_sorted"
+				net[${direction}_max]=${history_sorted[0]}
+				net[${direction}_graph_max]=$(( ${net[${direction}_max]}*3 ))
+				if ((${net[${direction}_graph_max]}<10<<10)); then net[${direction}_graph_max]=$((10<<10)); fi
+				net[${direction}_redraw]=1
+				net[${direction}_new_low]=0
+			fi	
+		fi
+
+		net[old_${direction}]=${net[new_${direction}]}
+	done
+
+	net[old_timestamp]=${net[new_timestamp]}
+
+}
+
+calc_sizes() { #? Calculate width and height of all boxes
+	local pos calc_size calc_total percent threads=${cpu[threads]}
+	
+	#* Calculate heights
+	for pos in ${box[boxes]/processes/}; do
+		if [[ $pos = "cpu" ]]; then percent=32; 
+		elif [[ $pos = "mem" ]]; then percent=40; 
+		else percent=28; fi
+
+		#* Multiplying with 10 to convert to floating point
+		calc_size=$(( (tty_height*10)*(percent*10)/100 ))
+
+		#* Round down if last 2 digits of value is below "50" and round up if above
+		if ((${calc_size:(-2):1}==0)); then calc_size=$((calc_size+10)); fi
+		if ((${calc_size:(-2)}<50)); then
+			calc_size=$((${calc_size::-2}))
+		else 
+			calc_size=$((${calc_size::-2}+1))
+		fi
+
+		#* Subtract from last value if the total of all rounded numbers is larger then terminal height
+		while ((calc_total+calc_size>tty_height)); do ((--calc_size)); done
+		calc_total=$((calc_total+calc_size))
+
+		#* Set calculated values in box array
+		box[${pos}_line]=$((calc_total-calc_size+1))
+		box[${pos}_col]=1
+		box[${pos}_height]=$calc_size
+		box[${pos}_width]=$tty_width
+	done
+
+
+	#* Calculate widths
+	unset calc_total
+	for pos in net processes; do
+		if [[ $pos = "net" ]]; then percent=45; else percent=55; fi
+		
+		#* Multiplying with 10 to convert to floating point
+		calc_size=$(( (tty_width*10)*(percent*10)/100 ))
+
+		#* Round down if last 2 digits of value is below "50" and round up if above
+		if ((${calc_size:(-2)}<50)); then
+			calc_size=$((${calc_size::-2}))
+		else 
+			calc_size=$((${calc_size::-2}+1))
+		fi
+
+		#* Subtract from last value if the total of all rounded numbers is larger then terminal width
+		while ((calc_total+calc_size>tty_width)); do ((--calc_size)); done
+		calc_total=$((calc_total+calc_size))
+
+		#* Set calculated values in box array
+		box[${pos}_col]=$((calc_total-calc_size+1))
+		box[${pos}_width]=$calc_size
+	done
+
+	#* Copy numbers around to get target layout
+	box[mem_width]=${box[net_width]}
+	box[processes_line]=${box[mem_line]}
+	box[processes_height]=$((box[mem_height]+box[net_height]))
+
+	#  threads=${box[testing]} #! For testing, remove <--------------
+
+	#* Recalculate size of process box if currently showing detailed process information
+	if ((proc[detailed]==1)); then
+		box[details_line]=${box[processes_line]}
+		box[details_col]=${box[processes_col]}
+		box[details_width]=${box[processes_width]}
+		box[details_height]=8
+		box[processes_line]=$((box[processes_line]+box[details_height]))
+		box[processes_height]=$((box[processes_height]-box[details_height]))
+	fi
+	
+	#* Calculate number of columns and placement of cpu meter box
+	local cpu_line=$((box[cpu_line]+1)) cpu_width=$((box[cpu_width]-2)) cpu_height=$((box[cpu_height]-2))
+	if ((threads>(cpu_height-3)*3 && tty_width>=200)); then box[p_width]=114; box[p_height]=$((threads/4+3))
+	elif ((threads>(cpu_height-3)*2 && tty_width>=150)); then box[p_width]=84; box[p_height]=$((threads/3+4))
+	elif ((threads>cpu_height-3 && tty_width>=100)); then box[p_width]=54; box[p_height]=$((threads/2+3))
+	else box[p_width]=24; box[p_height]=$((threads+3))
+	fi
+
+	if [[ $check_temp == true ]]; then
+		box[p_width]=$(( box[p_width]+13+( ( ( box[p_width]-24 ) /24 ) *7 ) ))
+	fi
+	
+	if ((box[p_height]>cpu_height)); then box[p_height]=$cpu_height; fi	
+	box[p_col]="$((cpu_width-box[p_width]+2))"
+	box[p_line]="$((cpu_line+(cpu_height/2)-(box[p_height]/2)+1))"
+
+	#* Calculate placement of mem divider
+	local mem_line=$((box[mem_line]+1)) mem_width=$((box[mem_width]-2)) mem_height=$((box[mem_height]-2)) mem_col=$((box[mem_col]+1))
+	box[m_width]=$((mem_width/2))
+	box[m_width2]=${box[m_width]}
+	if ((box[m_width]+box[m_width2]<mem_width)); then ((box[m_width]++)); fi
+	box[m_height]=$mem_height
+	box[m_col]=$((mem_col+1))
+	box[m_line]=$mem_line
+
+	#* Calculate placement of net value box
+	local net_line=$((box[net_line]+1)) net_width=$((box[net_width]-2)) net_height=$((box[net_height]-2))
+	box[n_width]=24
+	if ((net_height>9)); then box[n_height]=9
+	else box[n_height]=$net_height; fi
+	box[n_col]="$((net_width-box[n_width]+2))"
+	box[n_line]="$((net_line+(net_height/2)-(box[n_height]/2)+1))"
+	
+
+}
+
+draw_bg() { #? Draw all box outlines
+	local this_box cpu_p_width i cpu_model_len
+
+	unset boxes_out
+	for this_box in ${box[boxes]}; do
+		create_box -v boxes_out -col ${box[${this_box}_col]} -line ${box[${this_box}_line]} -width ${box[${this_box}_width]} -height ${box[${this_box}_height]} -fill -lc "${box[${this_box}_color]}" -title ${this_box}
+	done
+
+	#* Misc cpu box
+	if [[ $check_temp == true ]]; then cpu_model_len=18; else cpu_model_len=9; fi
+	create_box -v boxes_out -col $((box[p_col]-1)) -line $((box[p_line]-1)) -width ${box[p_width]} -height ${box[p_height]} -lc 30 -t "${cpu[model]:0:${cpu_model_len}}"
+	print -v boxes_out -m ${box[cpu_line]} $((box[cpu_col]+10)) -rs \
+	-fg ${box[cpu_color]} -t "┤" -b -fg "90" -t "m" -fg "#ee" -t "enu" -rs -fg ${box[cpu_color]} -t "├"
+	# -fg ${box[cpu_color]} -t "┤" -b -fg "90" -t "h" -fg "#ee" -t "elp" -rs -fg ${box[cpu_color]} -t "├"\
+	# -fg ${box[cpu_color]} -t "┤" -b -fg "90" -t "q" -fg "#ee" -t "uit" -rs -fg ${box[cpu_color]} -t "├"
+	
+
+	#* Misc mem
+	print -v boxes_out -m ${box[mem_line]} $((box[mem_col]+box[m_width]+2)) -rs -fg ${box[mem_color]} -t "┤" -fg ee -b -t "disks" -rs -fg ${box[mem_color]} -t "├"
+	print -v boxes_out -m ${box[mem_line]} $((box[mem_col]+box[m_width])) -rs -fg ${box[mem_color]} -t "┬"
+	print -v boxes_out -m $((box[mem_line]+box[mem_height]-1)) $((box[mem_col]+box[m_width])) -fg ${box[mem_color]} -t "┴"
+	for((i=1;i<=box[mem_height]-2;i++)); do
+	print -v boxes_out -m $((box[mem_line]+i)) $((box[mem_col]+box[m_width])) -fg 30 -t "│"
+	done
+
+
+	#* Misc net box
+	create_box -v boxes_out -col $((box[n_col]-1)) -line $((box[n_line]-1)) -width ${box[n_width]} -height ${box[n_height]} -lc 30 -t "Download"
+	print -v boxes_out -m $((box[n_line]+box[n_height]-2)) $((box[n_col]+1)) -rs -fg 30 -t "┤" -fg ee -b -t "Upload" -rs -fg 30 -t "├"
+
+
+	if [[ $1 == "quiet" ]]; then draw_out="${boxes_out}"
+	else echo -en "${boxes_out}"; fi
+	draw_update_string $1
+}
+
+draw_cpu() { #? Draw cpu and core graphs and print percentages
+	local cpu_out i name cpu_p_color temp_color y pt_line pt_col p_normal_color="#CC" threads=${cpu[threads]}
+	local meter meter_size meter_width temp_var cpu_out_var core_name temp_name temp_width
+
+	#* Get variables from previous calculations
+	local col=$((box[cpu_col]+1)) line=$((box[cpu_line]+1)) width=$((box[cpu_width]-2)) height=$((box[cpu_height]-2))
+	local p_width=${box[p_width]} p_height=${box[p_height]} p_col=${box[p_col]} p_line=${box[p_line]}
+	
+	#* If resized recreate cpu meter/graph box, cpu graph and core graphs
+	if ((resized>0)); then
+		local graph_a_size graph_b_size
+		graph_a_size=$((height/2)); graph_b_size=${graph_a_size}
+		if ((graph_a_size*2<height)); then ((graph_a_size++)); fi
+		# create_graph -o cpu_graph_a -d ${line} ${col} ${height} $((width-p_width-2)) -c color_cpu_graph cpu_history
+		create_graph -o cpu_graph_a -d ${line} ${col} ${graph_a_size} $((width-p_width-2)) -c color_cpu_graph -n cpu_history
+		create_graph -o cpu_graph_b -d $((line+graph_a_size)) ${col} ${graph_b_size} $((width-p_width-2)) -c color_cpu_graph -i -n cpu_history
+		# threads=${box[testing]} #! For testing, remove <--------------
+		for((i=1;i<=threads;i++)); do
+			create_mini_graph -o "cpu_core_graph_$i" -w 10 -c color_cpu_graph "cpu_core_history_$i"
+		done
+
+		if [[ $check_temp == true ]]; then
+			for((i=0;i<=threads;i++)); do
+				create_mini_graph -o "cpu_temp_graph_$i" -w 5 -c color_temp "cpu_temp_history_$i"
+			done
+		fi
+		((resized++))
+	fi
+
+	#* Add new values to cpu and core graphs unless just resized
+	if ((resized==0)); then
+		create_graph -add-last cpu_graph_a cpu_history
+		create_graph -i -add-last cpu_graph_b cpu_history
+		for((i=1;i<=threads;i++)); do
+			declare -n core_hist="cpu_core_history_${i}[-1]"
+			create_mini_graph -w 10 -c color_cpu_graph -add-value "cpu_core_graph_$i" ${core_hist}
+		done
+		if [[ $check_temp == true ]]; then
+			for((i=0;i<=threads;i++)); do
+				declare -n temp_hist="cpu_temp_history_${i}[-1]"
+				create_mini_graph -w 5 -c color_temp -add-value "cpu_temp_graph_$i" ${temp_hist}
+			done
+		fi
+	fi
+
+	#* Print CPU total and all cpu core percentage meters in box
+	for((i=0;i<=threads;i++)); do
+		if ((i==0)); then name="CPU"; else name="Core${i}"; fi
+		
+		#* Get color of cpu text depending on current usage
+		cpu_p_color="${color_cpu[cpu_usage[i]]}" 
+		
+		pt_col=$p_col; pt_line=$p_line; meter_size="small"; meter_width=10
+		
+		#* Set temperature string if "sensors" is available
+		if [[ $check_temp == true ]]; then
+			#* Get color of temperature text depending on current temp vs factory high temp
+			declare -n temp_hist="cpu_temp_history_${i}[-1]"
+			temp_color="${color_temp[${temp_hist}]}"
+			temp_name="cpu_temp_graph_$i"
+			temp_width=13
+		fi
+
+		if ((i==0 & p_width>24+temp_width)); then 
+			name="CPU Total "; meter_width=$((p_width-17-temp_width)); meter_size="big"
+		elif ((i==0)); then meter_size="big"
+		fi
+		
+
+		#* Create cpu usage meter
+		if ((i==0)); then
+			create_meter -v meter -b $meter_size -w $meter_width -f -c color_cpu ${cpu_usage[i]}
+		else
+			core_name="cpu_core_graph_$i"
+			meter="${!core_name}"
+		fi
+		
+		if ((p_width>84+temp_width & i>=(p_height-2)*3-2)); then pt_line=$((p_line+i-y*4)); pt_col=$((p_col+84+temp_width))
+		elif ((p_width>54+temp_width & i>=(p_height-2)*2-1)); then pt_line=$((p_line+i-y*3)); pt_col=$((p_col+54+temp_width))
+		elif ((p_width>24+temp_width & i>=p_height-2)); then pt_line=$((p_line+i-y*2)); pt_col=$((p_col+24+temp_width))
+		else y=$i; fi
+
+		print -v cpu_out_var -m $((pt_line+y)) $pt_col -rs -fg $p_normal_color -jl 7 -t "$name" -fg 30 "⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀" -l 10 -t "$meter"\
+		-fg $cpu_p_color -jr 4 -t "${cpu_usage[i]}" -fg $p_normal_color -t "%"
+		if [[ $check_temp == true ]]; then
+			print -v cpu_out_var -fg 30 "  ⡀⡀⡀⡀⡀" -l 7 -t "  ${!temp_name}" -fg $temp_color -jr 4 -t ${cpu[temp_${i}]} -fg $p_normal_color -t ${cpu[temp_unit]}
+		fi
+
+		if (( i>(p_height-2)*( p_width/(24+temp_width) )-( p_width/(24+temp_width) )-1 )); then break; fi	
+	done
+
+	#* Print current CPU frequency right of the title in the meter box
+	print -v cpu_out_var -m $((p_line-1)) $((p_col+p_width-5-${#cpu[freq_string]})) -fg 30 -t "┤" -fg ee -b -t "${cpu[freq_string]}" -rs -fg 30 -t "├"
+	
+	#* Print created text, graph and meters to output variable
+	draw_out="${draw_out}${cpu_graph_a[*]}${cpu_graph_b[*]}${cpu_out_var}"
+
+}
+
+draw_mem() { #? Draw mem, swap and disk statistics
+
+	if ((mem[counter]>0 & resized==0)); then return; fi
+
+	local i swap_used_meter swap_free_meter mem_available_meter mem_free_meter mem_used_meter mem_cached_meter normal_color="#CC" value_text
+	local meter_mod_w meter_mod_pos value type m_title meter_options
+	local -a types=("mem")
+	unset mem_out
+
+	if [[ -n $swap_on ]]; then types+=("swap"); fi
+
+	#* Get variables from previous calculations
+	local col=$((box[mem_col]+1)) line=$((box[mem_line]+1)) width=$((box[mem_width]-2)) height=$((box[mem_height]-2))
+	local m_width=${box[m_width]} m_height=${box[m_height]} m_col=${box[m_col]} m_line=${box[m_line]} mem_line=$((box[mem_col]+box[m_width]))
+
+	#* Create text and meters for memory and swap and adapt sizes based on available height
+	local y_pos=$m_line v_height=8 list value meter inv_meter
+	for type in ${types[@]}; do
+		local -n type_name="$type"
+		if [[ $type == "mem" ]]; then 
+			m_title="memory"
+		else 
+			m_title="$type"
+			if ((height>14)); then ((y_pos++)); fi
+		fi
+
+		#* Print name of type and total amount in humanized base 2 bytes
+		print -v mem_out -m $y_pos $m_col -rs -fg $normal_color -b -jl 9 -t "${m_title^}:" -m $((y_pos++)) $((mem_line-10)) -jr 9 -trans -t " ${type_name[total_string]::$((m_width-11))}"
+
+		for value in "used" "available" "cached" "free"; do
+			if [[ $type == "swap" && $value == "available" ]]; then value="free"
+			elif [[ $type == "swap" && $value == "cached" ]]; then break 2; fi
+
+			value_text="${value::$((m_width-12))}"
+			if ((height<14)); then value_text="${value_text::5}"; fi
+			
+			#* Print name of value and value amount in humanized base 2 bytes
+			print -v mem_out -m $y_pos $m_col -rs -fg $normal_color -jl 9 -t "${value_text^}:" -m $((y_pos++)) $((mem_line-10)) -jr 9 -trans -t " ${type_name[${value}_string]::$((m_width-11))}"
+			
+			#* Create meter for value and calculate size and placement depending on terminal size
+			if ((height>v_height++ | tty_width>100)); then
+				if ((height<=v_height & tty_width<150)); then
+					meter_mod_w=12
+					meter_mod_pos=7
+					((y_pos--))
+				elif ((height<=v_height)); then
+					print -v mem_out -m $((--y_pos)) $((m_col+5)) -jr 4 -t "${type_name[${value}_percent]}%"
+					meter_mod_w=14
+					meter_mod_pos=10
+				fi
+				create_meter -v ${type}_${value}_meter -w $((m_width-7-meter_mod_w)) -f -c color_${value}_graph ${type_name[${value}_percent]}
+				
+				meter="${type}_${value}_meter"
+				print -v mem_out -m $((y_pos++)) $((m_col+meter_mod_pos)) -t "${!meter}" -rs -fg $normal_color
+
+				if [[ -z $meter_mod_w ]]; then print -v mem_out  -jr 4 -t "${type_name[${value}_percent]}%"; fi
+			fi
+		done
+	 done
+
+
+	#* Create text and meters for disks and adapt sizes based on available height
+	local disk_num disk_name disk_value v_height2
+	y_pos=$m_line
+	m_col=$((m_col+m_width))
+	m_width=${box[m_width2]}
+	v_height=$((${#disks_name[@]}))
+	unset meter_mod_w meter_mod_pos
+
+	for disk_name in "${disks_name[@]}"; do
+		if ((y_pos>m_line+height-2)); then break; fi
+
+		#* Print folder disk is mounted on and total size in humanized base 2 bytes
+		print -v mem_out -m $((y_pos++)) $m_col -rs -fg $normal_color -b -jl 9 -t "${disks_name[disk_num]::10}" -jr $((m_width-11)) -t "${disks_total[disk_num]::$((m_width-11))}"
+
+		for value in "used" "free"; do
+			if ((height<v_height*3)) && [[ $value == "free" ]]; then break; fi
+			local -n disk_value="disks_${value}"
+
+			#* Print name of value and value amount in humanized base 2 bytes
+			print -v mem_out -m $((y_pos++)) $m_col -rs -fg $normal_color -jl 9 -t "${value^}:" -jr $((m_width-11)) -t "${disk_value[disk_num]::$((m_width-11))}"
+
+			#* Create meter for value and calculate size and placement depending on terminal size
+			if ((height>=v_height*5 | tty_width>100)); then
+				local -n disk_value_percent="disks_${value}_percent"
+				if ((height<=v_height*5 & tty_width<150)); then
+					meter_mod_w=12
+					meter_mod_pos=7
+					((y_pos--))
+				elif ((height<=v_height*5)); then
+					print -v mem_out -m $((--y_pos)) $((m_col+5)) -jr 4 -t "${disk_value_percent[disk_num]}%"
+					meter_mod_w=14
+					meter_mod_pos=10
+				fi
+				create_meter -v disk_${disk_num}_${value}_meter -w $((m_width-7-meter_mod_w)) -f -c color_${value}_graph ${disk_value_percent[disk_num]}
+
+				meter="disk_${disk_num}_${value}_meter"
+				print -v mem_out -m $((y_pos++)) $((m_col+meter_mod_pos)) -t "${!meter}" -rs -fg $normal_color
+
+				if [[ -z $meter_mod_w ]]; then print -v mem_out -jr 4 -t "${disk_value_percent[disk_num]}%"; fi
+			fi
+			if ((y_pos>m_line+height-1)); then break; fi
+		done
+		if ((height>=v_height*4 & height<v_height*5 | height>=v_height*6)); then ((y_pos++)); fi
+		((++disk_num))
+	done
+
+	if ((resized>0)); then ((resized++)); fi
+	#* Print created text, graph and meters to output variable
+	draw_out="${draw_out}${mem_graph[*]}${swap_graph[*]}${mem_out}"
+
+}
+
+draw_processes() { #? Draw processes and values to screen
+	local argument="$1"
+	if [[ -n $skip_process_draw && $argument != "now" ]]; then return; fi
+	local line=${box[processes_line]} col=${box[processes_col]} width=${box[processes_width]} height=${box[processes_height]} out_line y=1 rgb=231 step add checker=2 page_string
+	local reverse_string reverse_pos order_left="───────────┤" filter_string current_num detail_location det_no_add
+	local pid=0 pid_graph pid_r=13 pid_g=231 pid_b=86 p_step p_add bg_add bg_step rgb_d=70 d_step proc_start up_fg down_fg page_up_fg page_down_fg this_box=processes
+	local d_width=${box[details_width]} d_height=${box[details_height]} d_line=${box[details_line]} d_col=${box[details_col]}
+	local detail_graph_width=$((d_width/3+2)) detail_graph_height=$((d_height-1)) kill_fg det_mod
+	local right_width=$((d_width-detail_graph_width-2))
+	local right_col=$((d_col+detail_graph_width+4))
+
+	if [[ $argument == "now" ]]; then skip_process_draw=1; fi
+
+	add=$((200/height))
+	p_add=$((110/height))
+	d_add=$((rgb_d/height))
+
+	unset proc_out
+
+	#* Details box
+	if ((proc[detailed_change]>0)) || ((proc[detailed]>0 & resized>0)); then
+		proc[detailed_change]=0
+		proc[order_change]=1
+		proc[page_change]=1
+		if ((proc[detailed]==1)); then
+			unset proc_det
+			local enter_fg enter_a_fg misc_fg misc_a_fg i det_y=6 dets cmd_y
+
+			if [[ ${#detail_history[@]} -eq 1 ]] || ((resized>0)); then
+				unset proc_det2 
+				#detail_mem_graph ${#detail_history[@]} -lt 2
+				create_graph -o detail_graph -d $((d_line+1)) $((d_col+1)) ${detail_graph_height} ${detail_graph_width} -c color_cpu_graph -n detail_history
+				if ((tty_width>120)); then create_mini_graph -o detail_mem_graph -w $((right_width/3-3)) -nc detail_mem_history; fi
+				det_no_add=1
+			
+				for detail_location in "${d_line}" "$((d_line+d_height))"; do
+					print -v proc_det2 -m ${detail_location} $((d_col+1)) -rs -fg ${box[processes_color]} -rp $((d_width-2)) -t "─"
+				done
+				for((i=1;i<d_height;i++)); do
+					print -v proc_det2 -m $((d_line+i)) $((d_col+3+detail_graph_width)) -rp $((right_width-1)) -t " "
+					print -v proc_det2 -m $((d_line+i)) ${d_col} -fg ${box[processes_color]} -t "│" -r $((detail_graph_width+1)) -fg 30 -t "│" -r $((right_width+1)) -fg ${box[processes_color]} -t "│"
+				done
+
+				print -v proc_det2 -m ${d_line} ${d_col} -t "┌" -m ${d_line} $((d_col+d_width)) -t "┐"
+				print -v proc_det2 -m ${d_line} $((d_col+2+detail_graph_width)) -t "┬" -m $((d_line+d_height)) $((d_col+detail_graph_width+2)) -t "┴"
+				print -v proc_det2 -m $((d_line+d_height)) ${d_col} -t "├" -r 1 -t "┤" -fg "ee" -b -t "${this_box}" -rs -fg ${box[processes_color]} -t "┤" -r $((d_width-5-${#this_box})) -t "┤"
+				print -v proc_det2 -m ${d_line} $((d_col+2)) -t "┤" -fg "ee" -b -t "${proc[detailed_name],,}" -rs -fg ${box[processes_color]} -t "├"
+				if ((tty_width>128)); then print -v proc_det2 -m -r 1 -t "┤" -fg "ee" -b -t "${proc[detailed_pid]}" -rs -fg ${box[processes_color]} -t "├"; fi
+
+
+				
+				if ((${#proc[detailed_cmd]}>(right_width-6)*2)); then ((det_y--)); dets=2
+				elif ((${#proc[detailed_cmd]}>right_width-6)); then dets=1; fi
+				
+
+
+				#print -v proc_det2 -m $((d_line+det_y++)) ${right_col} -fg ee -b -jc $((right_width-4)) -t "Start command:"
+				print -v proc_det2 -fg ee -b
+				for i in C M D; do
+					print -v proc_det2 -m $((d_line+5+cmd_y++)) $right_col -t "$i"
+				done
+				
+				
+				print -v proc_det2 -m $((d_line+det_y++)) $((right_col+1)) -jc $((right_width-4)) -rs -fg ee -t "${proc[detailed_cmd]::$((right_width-6))}"
+				if ((dets>0)); then print -v proc_det2 -m $((d_line+det_y++)) $((right_col+2)) -jl $((right_width-6)) -t "${proc[detailed_cmd]:$((right_width-6)):$((right_width-6))}"; fi
+				if ((dets>1)); then print -v proc_det2 -m $((d_line+det_y)) $((right_col+2)) -jl $((right_width-6)) -t "${proc[detailed_cmd]:$(( (right_width-6)*2 )):$((right_width-6))}"; fi
+				
+			fi
+			
+			
+			if ((proc[selected]>0)); then enter_fg="50"; enter_a_fg="50"; else enter_fg="ee"; enter_a_fg="90"; fi
+			if [[ -n ${proc[detailed_killed]} ]]; then misc_fg="50"; misc_a_fg="50"
+			else misc_fg=$enter_fg; misc_a_fg=$enter_a_fg; fi
+			print -v proc_det -m ${d_line} $((d_col+d_width-11)) -fg ${box[processes_color]} -t "┤" -fg $enter_fg -b -t "close " -fg $enter_a_fg -t "↲" -rs -fg ${box[processes_color]} -t "├"
+			if ((tty_width<129)); then det_mod="-8"; fi
+			
+			print -v proc_det -m ${d_line} $((d_col+detail_graph_width+4+det_mod)) -t "┤" -fg $misc_a_fg -b -t "t" -fg $misc_fg -t "erminate" -rs -fg ${box[processes_color]} -t "├"
+			print -v proc_det -r 1 -t "┤" -fg $misc_a_fg -b -t "k" -fg $misc_fg -t "ill" -rs -fg ${box[processes_color]} -t "├"
+			if ((tty_width>104)); then print -v proc_det -r 1 -t "┤" -fg $misc_a_fg -b -t "i" -fg $misc_fg -t "nterrupt" -rs -fg ${box[processes_color]} -t "├"; fi
+			
+
+			proc_det="${proc_det2}${proc_det}"
+			proc_out="${proc_det}"
+
+		elif ((resized==0)); then
+			unset proc_det
+			create_box -v proc_out -col ${box[${this_box}_col]} -line ${box[${this_box}_line]} -width ${box[${this_box}_width]} -height ${box[${this_box}_height]} -fill -lc "${box[${this_box}_color]}" -title ${this_box}
+		fi	
+	fi
+
+	if [[ ${proc[detailed]} -eq 1 ]]; then
+		local det_status status_color det_columns=3
+		if ((tty_width>140)); then ((det_columns++)); fi
+		if ((tty_width>150)); then ((det_columns++)); fi
+		if [[ -z $det_no_add && $1 != "now" && -z ${proc[detailed_killed]} ]]; then 
+			create_graph -add-last detail_graph detail_history
+			if ((tty_width>120)); then create_mini_graph -w $((right_width/3-3)) -nc -add-last detail_mem_graph detail_mem_history; fi
+		fi
+		
+		print -v proc_out -fg ee -b
+		cmd_y=0
+		for i in C P U; do
+			print -v proc_out -m $((d_line+3+cmd_y++)) $((d_col+1)) -t "$i"
+		done
+		print -v proc_out -m $((d_line+1)) $((d_col+1)) -fg "dd" -t "${proc[detailed_cpu]}%"
+		
+		if [[ -n ${proc[detailed_killed]} ]]; then det_status="stopped"; status_color="ee3030"
+		else det_status="running"; status_color="30ee30"; fi
+		print -v proc_out -m $((d_line+1)) ${right_col} -fg ee -b -jc $((right_width/det_columns-1)) -t "Status:" -jc $((right_width/det_columns)) -t "Elapsed:" -jc $((right_width/det_columns)) -t "Parent:"
+		if ((det_columns>=4)); then print -v proc_out -jc $((right_width/det_columns-1)) -t "User:"; fi
+		if ((det_columns>=5)); then print -v proc_out -jc $((right_width/det_columns-1)) -t "Threads:"; fi
+		print -v proc_out -m $((d_line+2)) ${right_col} -rs -fg ${status_color} -jc $((right_width/det_columns-1)) -t "${det_status}" -jc $((right_width/det_columns)) -fg ee -t "${proc[detailed_runtime]::$((right_width/det_columns-1))}" -jc $((right_width/det_columns)) -t "${proc[detailed_parent_name]::$((right_width/det_columns-2))}"
+		if ((det_columns>=4)); then print -v proc_out -jc $((right_width/det_columns-1)) -t "${proc[detailed_user]::$((right_width/det_columns-2))}"; fi
+		if ((det_columns>=5)); then print -v proc_out -jc $((right_width/det_columns-1)) -t "${proc[detailed_threads]}"; fi
+
+		print -v proc_out -m $((d_line+4)) ${right_col} -fg ee -b -jr $((right_width/3+2)) -t "Memory: ${proc[detailed_mem]}%" -t " " 
+		if ((tty_width>120)); then print -v proc_out -rs -fg 30 -rp $((right_width/3-3)) "⡀" -l $((right_width/3-3)) -fg 13 231 86 -t "${detail_mem_graph}" -t " "; fi
+		print -v proc_out -fg ee -b -t "${proc[detailed_mem_string]}"
+		#if ((tty_width>120)); then print -v proc_out -m $((d_line+4)) ${right_col} -r $((right_width/3-2)) -rs -t "${detail_mem_graph}"; fi
+
+	fi
+
+	#*	proc[detailed_name] proc[detailed_cpu] proc[detailed_cpu_int] proc[detailed_cmd] detail_history
+	#*	proc[detailed_mem] proc[detailed_mem_int] proc[detailed_user] proc[detailed_threads]
+	#* proc[detailed_runtime] proc[detailed_mem_string] proc[detailed_parent_pid] proc[detailed_parent_name]
+
+	if ((proc[page]==1)); then proc_start=1
+	else proc_start=$(( (height-3)*(proc[page]-1)+1 )); fi
+
+	if ((proc_start+proc[selected]>${#proc_array[@]})); then proc[selected]=$((${#proc_array[@]}-proc_start)); fi
+
+	if ((proc[selected]>1)); then
+		rgb="$(( 231-( add*(proc[selected]-1) ) ))"
+		rgb_d="$(( 70-( d_add*(proc[selected]-1) ) ))"
+		pid_g="$(( 231-( p_add*(proc[selected]-1) ) ))"
+		pid_b="$(( 86-( p_add*(proc[selected]-1) ) ))"
+	fi
+ 
+	current_num=1
+	
+	print -v proc_out -rs -m $((line+y++)) $((col+1)) -fg 235 235 235 -b -t "${proc_array[0]::$((width-3))} " -rs
+
+
+	for out_line in "${proc_array[@]:$proc_start}"; do
+		pid="${out_line::$((proc[pid_len]+1))}"; pid="${pid// /}"
+		pid_graph="pid_${pid}_graph"
+
+		if ((current_num==proc[selected])); then print -v proc_out -bg "#7e2626" -b; proc[selected_pid]="$pid"
+
+		else print -v proc_out -rs; fi
+
+		print -v proc_out -m $((line+y)) $((col+1)) -fg $((rgb-step)) $((rgb-step)) $((rgb-step)) -t "${out_line::$((width-3))} "
+		
+		if ((current_num==proc[selected])); then print -v proc_out -rs -bg "#7e2626"; fi
+		print -v proc_out -m $((line+y)) $((col+width-12)) -fg $((rgb_d-d_step)) $((rgb_d-d_step)) $((rgb_d-d_step)) -t "⡀⡀⡀⡀⡀"
+
+		if [[ -n ${!pid_graph} ]]; then
+			print -v proc_out -m $((line+y)) $((col+width-12)) -fg $pid_r $((pid_g-p_step)) $(( pid_b-(p_step/2) )) -t "${!pid_graph}"
+		fi
+		
+		((y++))
+		((current_num++))
+		if ((y>height-2)); then break; fi
+		if ((current_num<proc[selected]+1)); then
+			step=$((step-add))
+			p_step=$((p_step-p_add))
+			d_step=$((d_step-d_add))
+		elif ((current_num>=proc[selected])); then
+			step=$((step+add))
+			p_step=$((p_step+p_add))
+			d_step=$((d_step+d_add))
+		fi
+			
+	done
+		print -v proc_out -rs
+		while ((y<=height-2)); do 
+			print -v proc_out -m $((line+y++)) $((col+1)) -rp $((width-2)) -t " "
+		done
+
+	if ((proc[order_change]==1 | proc[filter_change]==1 | resized>0)); then
+		unset proc_misc
+		proc[order_change]=0
+		proc[filter_change]=0
+		proc[page_change]=1
+		print -v proc_misc -m $line $((col+13)) -fg ${box[processes_color]} -rp $((box[processes_width]-14)) -t "─" -rs
+
+		if ((proc[detailed]==1)); then
+			print -v proc_misc -m $((d_line+d_height)) $((d_col+detail_graph_width+2)) -fg ${box[processes_color]} -t "┴" -rs
+		fi
+
+		if ((tty_width>100)); then
+			reverse_string="-fg ${box[processes_color]} -t ┤ -fg 90${proc[reverse]:+ -ul} -b -t r -fg ee -t everse -rs -fg ${box[processes_color]} -t ├"
+			reverse_pos=9
+			#unset order_left
+		fi
+		print -v proc_misc -m $line $((col+width-${#proc_sorting}-8-reverse_pos)) -rs ${reverse_string}\
+		-fg ${box[processes_color]} -t "┤" -fg 90 -b -t "‹" -fg ee -t " ${proc_sorting} "  -fg 90 -t "›" -rs -fg ${box[processes_color]} -t "├"
+		
+		if [[ -z $filter && -z $input_to_filter ]]; then
+			print -v proc_misc -m $line $((col+14)) -fg ${box[processes_color]} -t "┤" -fg 90 -b -t "f" -fg ee -t "ilter" -rs -fg ${box[processes_color]} -t "├"
+		elif [[ -n $input_to_filter ]]; then
+			if [[ ${#filter} -le $((width-35-reverse_pos)) ]]; then filter_string="${filter}"
+			elif [[ ${#filter} -gt $((width-35-reverse_pos)) ]]; then filter_string="${filter: (-$((width-35-reverse_pos)))}"
+			fi
+			print -v proc_misc -m $line $((col+14)) -fg ${box[processes_color]} -t "┤" -fg ee -b -t "${filter_string}" -fg aa -bl -t "█" -rs -fg ${box[processes_color]} -t "├"
+		elif [[ -n $filter ]]; then
+			if [[ ${#filter} -le $((width-35-reverse_pos-4)) ]]; then filter_string="${filter}"
+			elif [[ ${#filter} -gt $((width-35-reverse_pos-4)) ]]; then filter_string="${filter::$((width-35-reverse_pos-4))}"
+			fi
+			print -v proc_misc -m $line $((col+14)) -fg ${box[processes_color]} -t "┤" -fg 90 -b -t "f" -fg ee -t " ${filter_string} " -fg 90 -t "c" -rs -fg ${box[processes_color]} -t "├"
+		fi
+
+		
+	
+		proc_out="${proc_out}${proc_misc}"
+	fi
+
+	if ((proc[page_change]==1 | resized>0)); then
+		unset proc_misc2
+		proc[page_change]=0
+		if ((proc[selected]>0)); then up_fg=bb; kill_fg=70; else up_fg=40; kill_fg=30; fi
+		if ((proc[selected]==${#proc_array[@]}-proc_start)); then down_fg=40; else down_fg=bb; fi
+
+		if ((proc[page]>1)); then page_up_fg=bb; else page_up_fg=40; fi
+		if ((proc[page]<proc[pages])); then page_down_fg=bb; else page_down_fg=40; fi
+		page_string="${proc[page]}/${proc[pages]}"
+		print -v proc_misc2 -m $((line+height-1)) $((col+width-20)) -fg ${box[processes_color]} -rp 19 -t "─"
+		print -v proc_misc2 -m $((line+height-1)) $((col+width-${#page_string}-12)) -fg ${box[processes_color]} -t "┤" -b -fg $page_up_fg -t "pg↑" -fg bb -t " $page_string " -fg $page_down_fg -t "pg↓" -rs -fg ${box[processes_color]} -t "├"
+
+		print -v proc_misc2 -m $((line+height-1)) $((col+2)) -fg ${box[processes_color]} -t "┤" -fg $up_fg -b -t "↑" -fg bb -t " select " -fg $down_fg -t "↓" -rs -fg ${box[processes_color]} -t "├"
+		print -v proc_misc2 -r 1 -fg ${box[processes_color]} -t "┤" -fg $up_fg -b -t "info ↲" -rs -fg ${box[processes_color]} -t "├"
+		if ((tty_width>100)); then print -v proc_misc2 -r 1 -t "┤" -fg $kill_fg -b -t "t" -fg $up_fg -t "erminate" -rs -fg ${box[processes_color]} -t "├"; fi
+		if ((tty_width>111)); then print -v proc_misc2 -r 1 -t "┤" -fg $kill_fg -b -t "k" -fg $up_fg -t "ill" -rs -fg ${box[processes_color]} -t "├"; fi
+		if ((tty_width>126)); then print -v proc_misc2 -r 1 -t "┤" -fg $kill_fg -b -t "i" -fg $up_fg -t "nterrupt" -rs -fg ${box[processes_color]} -t "├"; fi
+
+
+
+
+		proc_out="${proc_out}${proc_misc2}"
+	fi
+
+	#page_string="1/$((${#proc_array[@]}/(height-2)))"
+	#print -v proc_out -m $line $((col+width-${#page_string}-6)) -rs -fg ${box[processes_color]} -t "──┤" -fg ee -b -t "${page_string}" -rs -fg ${box[processes_color]} -t "├"
+
+	#draw_out="${draw_out}${detail_graph[*]}${proc_out}"
+
+	proc_out="${detail_graph[*]}${proc_out}"
+
+	if ((resized>0)); then ((resized++)); fi
+
+	if [[ $argument == "now" ]]; then
+		echo -en "${proc_out}"
+	#else
+	#	draw_out="${draw_out}${detail_graph[*]}${proc_out}"
+	fi
+
+}
+
+draw_net() { #? Draw net information and graphs to screen
+	local net_out
+	#* Get variables from previous calculations
+	local col=$((box[net_col]+1)) line=$((box[net_line]+1)) width=$((box[net_width]-2)) height=$((box[net_height]-2))
+	local n_width=${box[n_width]} n_height=${box[n_height]} n_col=${box[n_col]} n_line=${box[n_line]}
+	
+	#* If resized recreate net meter box and net graphs
+	if ((resized>0)); then
+		local graph_a_size graph_b_size
+		graph_a_size=$(( (height)/2 )); graph_b_size=${graph_a_size}
+		if ((graph_a_size*2<height)); then ((graph_a_size++)); fi
+		net[graph_a_size]=$graph_a_size
+		net[graph_b_size]=$graph_b_size
+
+		create_graph -o download_graph -d $line $col $graph_a_size $((width-n_width-2)) -c color_download_graph -n -max "${net[download_graph_max]}" net_history_download
+		create_graph -o upload_graph -d $((line+graph_a_size)) $col $graph_b_size $((width-n_width-2)) -c color_upload_graph -i -n -max "${net[upload_graph_max]}" net_history_upload
+
+		net[download_redraw]=0 
+		net[upload_redraw]=0
+		((resized++))
+	fi
+	
+	#* Update graphs if graph resolution update is needed or just resized, otherwise just add new values
+	if ((net[download_redraw]==1 | resized>0)); then
+		create_graph -o download_graph -d $line $col ${net[graph_a_size]} $((width-n_width-2)) -c color_download_graph -n -max "${net[download_graph_max]}" net_history_download
+	else
+		create_graph -max "${net[download_graph_max]}" -add-last download_graph net_history_download
+	fi
+	if ((net[upload_redraw]==1 | resized>0)); then
+		create_graph -o upload_graph -d $((line+net[graph_a_size])) $col ${net[graph_b_size]} $((width-n_width-2)) -c color_upload_graph -i -n -max "${net[upload_graph_max]}" net_history_upload
+	else
+		create_graph -max "${net[upload_graph_max]}" -i -add-last upload_graph net_history_upload
+	fi
+
+	#* Create text depening on box height
+	local ypos=$n_line
+
+	print -v net_out -fg cc -m $((ypos++)) $n_col -jl 10 -t "▼ Byte:" -jr 12 -t "${net[speed_download_byteps]}"
+	if ((height>4)); then print -v net_out -fg cc -m $((ypos++)) $n_col -jl 10 -t "▼ Bit:" -jr 12 -t "${net[speed_download_bitps]}"; fi
+	if ((height>6)); then print -v net_out -fg cc -m $((ypos++)) $n_col -jl 10 -t "▼ Total:" -jr 12 -t "${net[total_download]}"; fi
+	
+	if ((height>8)); then ((ypos++)); fi
+	print -v net_out -fg cc -m $((ypos++)) $n_col -jl 10 -t "▲ Byte:" -jr 12 -t "${net[speed_upload_byteps]}"
+	if ((height>7)); then print -v net_out -fg cc -m $((ypos++)) $n_col -jl 10 -t "▲ Bit:" -jr 12 -t "${net[speed_upload_bitps]}"; fi
+	if ((height>5)); then print -v net_out -fg cc -m $((ypos++)) $n_col -jl 10 -t "▲ Total:" -jr 12 -t "${net[total_upload]}"; fi
+	
+
+	#* Print graphs and text to output variable
+	draw_out="${draw_out}${download_graph[*]}${upload_graph[*]}${net_out}"
+}
+
+draw_clock() { #? Draw a clock at top of screen
+	if [[ -z $draw_clock ]]; then return; fi
+	if [[ $resized -gt 0 && $resized -lt 5 ]]; then unset clock_out; return; fi
+	local width=${box[cpu_width]} color=${box[cpu_color]} old_time_string="${time_string}"
+	#time_string="$(date ${draw_clock})"
+	printf -v time_string "%(${draw_clock})T"
+	if [[ $old_time_string != "$time_string" || -z $clock_out ]]; then
+		unset clock_out
+		print -v clock_out -m 1 $((width/2-${#time_string}/2)) -rs -fg ${color} -t "┤" -fg ee -b -t "${time_string}" -fg ${color} -t "├"
+	fi
+	if [[ $1 == "now" ]]; then echo -en "${clock_out}"; fi
+	#print -v draw_out -t "${clock_out}"
+}
+
+draw_update_string() {
+	unset update_string
+	print -v update_string -m ${box[cpu_line]} $((box[cpu_col]+box[cpu_width]-${#update_ms}-14)) -rs -fg ${box[cpu_color]} -t "────┤"  -fg "aa" -b -t "+" -fg "ee" -b -t " ${update_ms}ms "  -fg "aa" -b -t "-" -rs -fg ${box[cpu_color]} -t "├"
+	if [[ $1 == "quiet" ]]; then draw_out="${draw_out}${update_string}"
+	else echo -en "${update_string}"; fi
+}
+
+pause_() { #? Pause input and draw a darkened version of main ui
+	local pause_out ext_var
+	if [[ -n $1 && $1 != "off" ]]; then local -n pause_out=${1}; ext_var=1; fi
+	if [[ $1 != "off" ]]; then
+		prev_screen="${boxes_out}${proc_det}${last_screen}${mem_out}${detail_graph[*]}${proc_out}${proc_misc}${proc_misc2}${update_string}${clock_out}"
+		if [[ -n $skip_process_draw ]]; then
+			prev_screen="${prev_screen}${proc_out}"
+			unset skip_process_draw proc_out
+		fi
+		
+		pause_screen="\e[1;38;5;236m$(echo -n "${prev_screen}" | sed -E 's/\\e\[[0-9;\-]*m//g')\e[0m"
+		
+		if [[ -z $ext_var ]]; then echo -en "${pause_screen}"
+		else pause_out="${pause_screen}"; fi
+
+	elif [[ $1 == "off" ]]; then
+		echo -en "${prev_screen}"
+		unset pause_screen prev_screen
+	fi
+}
+
+unpause_() { #? Unpause
+	pause_ off
+}
+
+menu_() { #? Shows the main menu overlay
+	local menu i count keypress selected_int=0 selected up local_rez d_banner=1 menu_out bannerd skipped menu_pause out_out wait_string
+	local -a menus=("options" "help" "quit") color
+	
+	until false; do
+
+		#* Put program to sleep if caught ctrl-z
+		if ((sleepy==1)); then sleep_; fi
+
+		if [[ $background_update == true || -z $menu_out ]]; then
+			draw_clock
+			pause_ menu_pause
+		else
+			unset menu_pause
+		fi
+
+		unset draw_out
+
+		if [[ -z ${bannerd} ]]; then
+			draw_banner "$((tty_height/2-10))" bannerd
+			unset d_banner
+		fi
+		if [[ -n ${keypress} || -z ${menu_out} ]]; then
+			unset menu_out
+			print -v menu_out -t "${bannerd}"
+			print -v menu_out -d 1
+			selected="${menus[selected_int]}"
+			unset up
+			for menu in "${menus[@]}"; do
+				if [[ $menu == "$selected" ]]; then
+					local -n menu_array="menu_${menu}_selected"
+					color=("#c55e5e" "#c23d3d" "#a13030" "#8c2626")
+				else
+					local -n menu_array="menu_${menu}"
+					color=("#bb" "#aa" "#99" "#88")
+				fi
+				up=$((up+${#menu_array[@]}))
+				for((i=0;i<${#menu_array[@]};i++)); do
+					print -v menu_out -d 1 -fg ${color[i]} -c -trans -t "${menu_array[i]}"
+				done
+			done
+			print -v menu_out -u ${up}
+		fi
+		unset out_out
+		out_out="${menu_pause}${menu_out}"
+		echo -e "${out_out}"
+		
+		
+		get_ms timestamp_end
+		time_left=$((timestamp_start+update_ms-timestamp_end))
+		if ((time_left>1000)); then wait_string=1; time_left=$((time_left-1000))
+		elif ((time_left>1)); then printf -v wait_string ".%03d" "${time_left}"; time_left=0
+		else wait_string="0.001"; time_left=0; fi
+		
+		get_key -v keypress -w ${wait_string}
+		if [[ $(stty size) != "$tty_height $tty_width" ]]; then resized; fi
+		if ((resized>0)); then 
+			calc_sizes; draw_bg quiet; time_left=0; unset menu_out
+			unset bannerd
+		fi
+
+		case "$keypress" in
+			up|shift_tab) if ((selected_int>0)); then ((selected_int--)); else selected_int=$((${#menus[@]}-1)); fi ;;
+			down|tab) if ((selected_int<${#menus[@]}-1)); then ((++selected_int)); else selected_int=0; fi ;;
+			enter|space)
+				case "$selected" in
+					options) options_ ;;
+					help) help_ ;;
+					quit) quit_ ;;
+				esac
+			;;
+			m|M|escape|backspace) break ;;
+			q|Q) quit_ ;;
+		esac
+		
+		if ((time_left==0)); then get_ms timestamp_start; collect_and_draw; fi
+		if ((resized>=5)); then resized=0; fi
+
+	done				
+	unpause_
+	
+}
+
+help_() { #? Shows the help overlay
+	local tmp from_menu col lineQ y i help_out help_pause redraw=1 wait_string
+	local -a shortcuts descriptions
+
+	shortcuts=(
+		"(Esc, M, m)"
+		"(F2, O, o)"
+		"(F1, H, h)"
+		"(Ctrl-C, Q, q)"
+		"(+, A, a) (-, S, s)"
+		"(Up) (Down)"
+		"(Enter)"
+		"(Pg Up) (Pg Down)"
+		"(Home) (End)"
+		"(Left, Right)"
+		"(R, r)"
+		"(F, f)"
+		"(C, c)"
+		"(T, t)"
+		"(K, k)"
+		"(I, i)"
+	)
+	descriptions=(
+		"Shows main menu."
+		"Shows options."
+		"Shows this window."
+		"Quits program."
+		"Add/Subtract 100ms to/from update timer."
+		"Select in process list."
+		"Show detailed information for selected process."
+		"Jump 1 page in process list."
+		"Jump to first or last page in process list."
+		"Select previous/next sorting column."
+		"Reverse sorting order in processes box."
+		"Input a string to filter processes with."
+		"Clear any entered filter."
+		"Terminate selected process with SIGTERM - 15."
+		"Kill selected process with SIGKILL - 9."
+		"Interrupt selected process with SIGINT - 2."
+	)
+
+	if [[ -n $pause_screen ]]; then from_menu=1; fi
+	
+	until [[ -n $tmp ]]; do
+
+		#* Put program to sleep if caught ctrl-z
+		if ((sleepy==1)); then sleep_; redraw=1; fi
+
+		if [[ $background_update == true || -n $redraw ]]; then
+			draw_clock
+			pause_ help_pause
+		else
+			unset help_pause
+		fi
+
+
+		if [[ -n $redraw ]]; then
+			col=$((tty_width/2-36)); line=$((tty_height/2-4)); y=1
+			unset redraw help_out
+			draw_banner "$((tty_height/2-11))" help_out
+			print -d 1
+			create_box -v help_out -w 72 -h $((${#shortcuts[@]}+3)) -l $((line++)) -c $((col++)) -fill -lc 40 -title "help"
+			((++col))
+
+			print -v help_out -r 1 -fg ee -b -jl 20 -t "Key:" -jl 48 -t "Description:" -m $((line+y++)) $col
+			
+			for((i=0;i<${#shortcuts[@]};i++)); do
+				print -v help_out -fg cc -b -jl 20 -t "${shortcuts[i]}" -rs -fg ee -jl 48 -t "${descriptions[i]}" -m $((line+y++)) $col
+			done
+		fi
+
+
+		unset draw_out
+		echo -en "${help_pause}${help_out}"
+		
+		get_ms timestamp_end
+		time_left=$((timestamp_start+update_ms-timestamp_end))
+		
+		if ((time_left>1000)); then wait_string=1; time_left=$((time_left-1000))
+		elif ((time_left>0)); then printf -v wait_string ".%03d" "${time_left}"; time_left=0
+		else wait_string="0.001"; time_left=0; fi
+		
+		get_key -v tmp -w "${wait_string}"
+		if [[ $(stty size) != "$tty_height $tty_width" ]]; then resized; fi
+		if ((resized>0)); then 
+			sleep 0.5
+			calc_sizes; draw_bg quiet; redraw=1
+			d_banner=1
+			unset bannerd menu_out
+		fi
+		if ((time_left==0)); then get_ms timestamp_start; collect_and_draw; fi
+		if ((resized>0)); then resized=0; fi
+	done
+
+	if [[ -n $from_menu ]]; then pause_
+	else unpause_; fi
+}
+
+options_() { #? Shows the options overlay
+	local keypress from_menu col line y=1 i options_out selected_int=0 ypos option_string options_misc option_value bg fg skipped start_t end_t left_t changed_cpu_name
+	local desc_col right left enter lr inp valid updated_ms local_rez redraw_misc=1 desc_pos desc_height options_pause updated_proc inputting inputting_value inputting_key
+		desc_update_ms=(	"Update time in milliseconds."
+							"Recommended 2000 ms or above for better sample"
+							"times for graphs."
+							" "
+							"Increases automatically if set below internal"
+							"loops processing time."
+							" "
+							"Max value: 86400000 ms = 24 hours.")
+		desc_proc_sorting=(	"Processes sorting."
+							"Valid values are \"pid\", \"program\", \"arguments\","
+							"\"threads\", \"user\", \"memory\", \"cpu lazy\" and"
+							"\"cpu responsive\"."
+							" "
+							"\"cpu lazy\" uses ps commands internal sorting"
+							"and updates top process over a period of time."
+							" "
+							"\"cpu responsive\" updates sorting directly at a"
+							"cost of cpu time.")
+		desc_proc_reversed=("Reverse sorting order."
+							" "
+							"True or false.")
+		desc_check_temp=(	"Check cpu temperature."
+							" "
+							"Only works if sensors command is available"
+							"and show values for Package and Core"
+							"temperatures.")
+		desc_draw_clock=(	"Draw a clock at top of screen."
+							" "
+							"Formatting according to strftime, empty"
+							"string to disable."
+							" "
+							"\"%X\" locale HH:MM:SS"
+							"\"%H\" 24h hour, \"%I\" 12h hour"
+							"\"%M\" minute, \"%S\" second"
+							"\"%d\" day, \"%m\" month, \"%y\" year")
+		desc_background_update=( "Update main ui when menus are showing."
+								" "
+								"True or false."
+								" "
+								"Set this to false if the menus is flickering"
+								"too much for a comfortable experience.")
+		desc_custom_cpu_name=(	"Custom cpu model name in cpu percentage box."
+								" "
+								"Empty string to disable.")
+		desc_error_logging=("Enable error logging to"
+							"\"\$HOME/.config/bashtop/error.log\""
+							" "
+							"True or false."
+							"Takes effect after program restart.")
+	
+
+	if [[ -n $pause_screen ]]; then from_menu=1; fi
+
+	until false; do
+
+		#* Put program to sleep if caught ctrl-z
+		if ((sleepy==1)); then sleep_; fi
+		
+		
+		if [[ $background_update == true || -n $redraw_misc ]]; then
+			draw_clock
+			pause_ options_pause
+		else
+			unset options_pause
+		fi
+
+		if [[ -n $redraw_misc ]]; then
+			unset options_misc
+			col=$((tty_width/2-39))
+			line=$((tty_height/2-4))
+			desc_col=$((col+30))
+			draw_banner "$((tty_height/2-11))" options_misc
+			create_box -v options_misc -w 29 -h $((${#options_array[@]}*2+2)) -l $line -c $((col-1)) -fill -lc 40 -title "options"
+			unset redraw_misc
+		fi
+		
+		
+		if [[ -n $keypress || -z $options_out ]]; then
+			unset options_out desc_height
+			selected="${options_array[selected_int]}"
+			local -n selected_desc="desc_${selected}"
+			unset lr inp valid
+			if [[ $background_update == false ]]; then desc_pos=$line; desc_height=$((${#options_array[@]}*2+2))
+			elif ((selected_int*2+${#selected_desc[@]}<${#options_array[@]}*2)); then desc_pos=$((line+selected_int*2))
+			else desc_pos=$((line+${#options_array[@]}*2-${#selected_desc[@]})); fi
+			create_box -v options_out -w 50 -h ${desc_height:-$((${#selected_desc[@]}+2))} -l $desc_pos -c $((desc_col-1)) -fill -lc 40 -title "description"
+			for((i=0,ypos=1;i<${#options_array[@]};i++,ypos=ypos+2)); do
+				option_string="${options_array[i]}"
+				if [[ -n $inputting && ${option_string} == "${selected}" ]]; then 
+					if [[ ${#inputting_value} -gt 14 ]]; then option_value="${inputting_value:(-14)}_"
+					else option_value="${inputting_value}_"; fi
+				else 
+					option_value="${!option_string}"
+				fi
+				
+				if [[ ${option_string} == "${selected}" ]]; then
+					if [[ $option_value =~ ^[0-9]+$ ]]; then
+						enter="↲"; inp=1
+					fi
+					if [[ $option_value =~ ^[0-9]+$ || $option_value =~ true|false || $selected == "proc_sorting" ]] && [[ -z $inputting ]]; then
+						left="←"; right="→"; lr=1
+					else
+						enter="↲"; inp=1
+					fi
+					bg=" -bg #7e2626"
+					fg="ff"
+				fi
+				option_string="${option_string//_/ }"
+				print -v options_out -m $((line+ypos)) $((col+1)) -rs -fg ${fg:-ee}${bg} -b -jc 25 -t "${option_string^}:"
+				print -v options_out -m $((line+ypos+1)) $((col+1)) -rs -fg ${fg:-cc}${bg} -jc 25 -t "${enter:+ } ${left} \"${option_value::15}\" ${right} ${enter}"
+				unset right left enter bg fg
+			done
+			
+			for((i=0,ypos=1;i<${#selected_desc[@]};i++,ypos++)); do
+				print -v options_out -m $((desc_pos+ypos)) $((desc_col+1)) -rs -fg ee -jl 46 -t "${selected_desc[i]}"
+			done
+		fi
+
+		echo -en "${options_pause}${options_misc}${options_out}"
+		unset draw_out keypress
+		
+		
+		get_ms timestamp_end
+		time_left=$((timestamp_start+update_ms-timestamp_end))
+		if ((time_left>500)); then wait_string=0.5
+		elif ((time_left>0)); then printf -v wait_string ".%03d" "${time_left}"
+		else wait_string="0.001"; time_left=0; fi
+				
+		get_key -v keypress -w ${wait_string}
+		
+		if [[ -n $inputting ]]; then
+			case "$keypress" in
+				escape) unset inputting inputting_value ;;
+				enter|backspace) valid=1 ;;
+				*) if [[ ${#keypress} -eq 1 ]]; then valid=1; fi ;;
+			esac
+		else
+			case "$keypress" in
+				escape|q|backspace) break 1 ;;
+				down|tab) if ((selected_int<${#options_array[@]}-1)); then ((++selected_int)); else selected_int=0; fi ;;
+				up|shift_tab) if ((selected_int>0)); then ((selected_int--)); else selected_int=$((${#options_array[@]}-1)); fi ;;
+				left|right) if [[ -n $lr && -z $inputting ]]; then valid=1; fi ;;
+				enter) if [[ -n $inp ]]; then valid=1; fi ;;
+			esac
+		fi
+	
+
+		if [[ -n $valid ]]; then
+			case "${selected} ${keypress}" in
+				"update_ms right") 
+						if ((update_ms<86399900)); then
+							update_ms=$((update_ms+100))
+							updated_ms=1
+						fi
+					;;
+				"update_ms left")
+						if ((update_ms>100)); then
+							update_ms=$((update_ms-100))
+							updated_ms=1
+						fi
+					;;
+				"update_ms enter")
+						if [[ -z $inputting ]]; then inputting=1; inputting_value="${update_ms}"
+						else 
+							if ((inputting_value<86400000)); then update_ms="${inputting_value:-0}"; updated_ms=1; fi
+							unset inputting inputting_value
+						fi
+					;;
+				"update_ms backspace")
+						if [[ ${#inputting_value} -gt 0 ]]; then
+							inputting_value="${inputting_value::-1}"
+						fi
+					;;
+				"update_ms"*)
+						#if [[ $keypress =~ ^[0-9]$ ]]; then
+							inputting_value="${inputting_value}${keypress//[^0-9]/}"
+						#fi
+					;;
+				"draw_clock enter")
+						if [[ -z $inputting ]]; then inputting=1; inputting_value="${draw_clock}"
+						else draw_clock="${inputting_value}"; unset inputting inputting_value clock_out; fi
+					;;
+				"draw_clock backspace")
+						if [[ ${#inputting_value} -gt 0 ]]; then
+							inputting_value="${inputting_value::-1}"
+						fi
+					;;
+				"draw_clock"*)
+						inputting_value="${inputting_value}${keypress//[\\\$\"\']/}"
+					;;
+				"custom_cpu_name enter")
+						if [[ -z $inputting ]]; then inputting=1; inputting_value="${custom_cpu_name}"
+						else custom_cpu_name="${inputting_value}"; changed_cpu_name=1; unset inputting inputting_value; fi
+					;;
+				"custom_cpu_name backspace")
+						if [[ ${#inputting_value} -gt 0 ]]; then
+							inputting_value="${inputting_value::-1}"
+						fi
+					;;
+				"custom_cpu_name"*)
+						inputting_value="${inputting_value}${keypress//[\\\$\"\']/}"
+					;;		
+				"proc_reversed"*|"check_temp"*|"error_logging"*|"background_update"*)
+						local -n selected_var=${selected}
+						if [[ ${selected_var} == "true" ]]; then
+							selected_var="false"
+							if [[ $selected == "proc_reversed" ]]; then proc[order_change]=1; unset 'proc[reverse]'; fi
+						else
+							selected_var="true"
+							if [[ $selected == "proc_reversed" ]]; then proc[order_change]=1; proc[reverse]="+"; fi
+						fi
+						if [[ $selected == "check_temp" ]]; then resized=1; fi
+					;;
+				"proc_sorting right")
+						if ((proc[sorting_int]<${#sorting[@]}-1)); then ((++proc[sorting_int]))
+						else proc[sorting_int]=0; fi
+						proc_sorting="${sorting[proc[sorting_int]]}"
+						proc[order_change]=1
+					;;
+				"proc_sorting left")
+						if ((proc[sorting_int]>0)); then ((proc[sorting_int]--))
+						else proc[sorting_int]=$((${#sorting[@]}-1)); fi
+						proc_sorting="${sorting[proc[sorting_int]]}"
+						proc[order_change]=1
+					;;
+			esac
+
+		fi
+
+		if [[ -n $changed_cpu_name ]]; then
+			changed_cpu_name=0
+			get_cpu_info
+			calc_sizes
+			draw_bg quiet
+		fi
+
+		if [[ $(stty size) != "$tty_height $tty_width" ]]; then resized; fi
+
+		if ((resized>0)); then 
+			calc_sizes; draw_bg quiet
+			redraw_misc=1; time_left=0
+			unset options_out bannerd menu_out
+		fi
+
+		get_ms timestamp_end
+		time_left=$((timestamp_start+update_ms-timestamp_end))
+		if ((time_left<=0)); then get_ms timestamp_start; collect_and_draw; fi
+		if ((resized>0)); then resized=0; fi
+
+		if  [[ -n $updated_ms ]] && ((updated_ms++==2)); then
+			unset updated_ms
+			draw_update_string quiet
+		fi
+
+	done
+
+	if [[ -n $from_menu ]]; then pause_
+	elif [[ -n ${pause_screen} ]]; then unpause_; draw_update_string; fi
+}
+
+killer_() { #? Kill process with selected signal
+	local kill_op="$1" kill_pid="$2" killer_out killer_box col line program keypress selected selected_int=0 sig confirmed=0 option killer_pause status status_fg msg
+	local -a options=("yes" "no")
+	
+	if ! program="$(ps -o comm --no-header -p ${kill_pid})"; then return; fi
+
+	case $kill_op in
+		t|T) kill_op="terminate"; sig="SIGTERM" ;;
+		k|K) kill_op="kill"; sig="SIGKILL" ;;
+		i|I) kill_op="interrupt"; sig="SIGINT" ;;
+	esac
+	
+	until false; do
+
+		#* Put program to sleep if caught ctrl-z
+		if ((sleepy==1)); then sleep_; fi
+
+		if [[ $background_update == true || -z $killer_box ]]; then
+			draw_clock
+			pause_ killer_pause
+		else
+			unset killer_pause
+		fi
+
+		if [[ -z $killer_box ]]; then
+			col=$((tty_width/2-15)); line=$((tty_height/2-4)); y=1
+			unset redraw killer_box
+			create_box -v killer_box -w 40 -h 9 -l $line -c $((col++)) -fill -lc "#923535" -title "${kill_op}"	
+		fi
+
+		if ((confirmed==0)); then
+			selected="${options[selected_int]}"
+			print -v killer_out -m $((line+2)) $col -fg ee -b -jc 38 -t "${kill_op^} ${program::20}?" -m $((line+4)) $((col+3))
+			for option in "${options[@]}"; do
+				if [[ $option == "${selected}" ]]; then print -v killer_out -bg "#923535"; fi
+				print -v killer_out -fg cc -b -r 5 -t "[  ${option^}  ]" -rs
+			done
+
+		elif ((confirmed==1)); then
+			selected="ok"
+			print -v killer_out -m $((line+2)) $col -fg ee -b -jc 38 -t "Sending signal ${sig} to pid ${kill_pid}!"
+			print -v killer_out -m $((line+4)) $col -fg ${status_fg} -jc 38 -t "${status^}!" -m $((line+6)) $col
+			if [[ -n $msg ]]; then print -v killer_out -m $((line+5)) $col -fg ee -jc 38 -t "${msg}" -m $((line+7)) $col; fi
+			print -v killer_out -fg cc -bg "#923535" -b -r 15 -t "[  Ok  ]" -rs
+		fi
+	
+		echo -en "${killer_pause}${killer_box}${killer_out}"
+		unset killer_out draw_out
+		
+		
+		get_ms timestamp_end
+		time_left=$((timestamp_start+update_ms-timestamp_end))
+		if ((time_left>1000)); then wait_string=1; time_left=$((time_left-1000))
+		elif ((time_left>1)); then printf -v wait_string ".%03d" "${time_left}"; time_left=0
+		else wait_string="0.001"; time_left=0; fi
+		
+		get_key -v keypress -w ${wait_string}
+		if [[ $(stty size) != "$tty_height $tty_width" ]]; then resized; fi
+		if ((resized>0)); then 
+			calc_sizes; draw_bg quiet; time_left=0; unset killer_out killer_box
+		fi
+
+		case "$keypress" in
+			right|shift_tab) if ((selected_int>0)); then ((selected_int--)); else selected_int=$((${#options[@]}-1)); fi ;;
+			left|tab) if ((selected_int<${#options[@]}-1)); then ((++selected_int)); else selected_int=0; fi ;;
+			enter)
+				case "$selected" in
+					yes) confirmed=1 ;;
+					no|ok) confirmed=-1 ;;
+				esac
+			;;
+			q|Q) quit_ ;;
+		esac
+		
+		
+
+		if ((confirmed<0)); then
+			unpause_
+			break
+		elif ((confirmed>0)) && [[ -z $status ]]; then
+			if kill -${sig} ${kill_pid} >/dev/null 2>&1; then 
+				status="success"
+				status_fg="30ee20"
+			else 
+				if ! ps -p ${kill_pid} >/dev/null 2>&1; then
+					msg="Process not running."
+				elif [[ $UID != 0 ]]; then
+					msg="Try restarting with sudo."
+				else
+					msg="Unknown error."
+				fi
+				status="failed"; status_fg="ee3020"; fi
+		fi
+				
+
+		if ((time_left==0)); then get_ms timestamp_start; unset draw_out; collect_and_draw; fi
+		if ((resized>=5)); then resized=0; fi
+
+	done				
+	
+	
+}
+
+get_key() { #? Get one key from standard input and translate key code to readable format
+	local key key_out wait_time esc ext_out save
+
+	if ((quitting==1)); then quit_; fi
+
+	until (($#==0)); do
+		case "$1" in
+			-v|-variable) local -n key_out=$2; ext_out=1; shift;;			#* Output variable
+			-w|-wait) wait_time="$2"; shift;;								#* Time to wait for key
+			-s|-save) save=1;;												#* Save key for later processing
+		esac
+		shift
+	done
+		
+	if [[ -z $save && -n ${saved_key[0]} ]]; then key="${saved_key[0]}"; unset 'saved_key[0]'; saved_key=("${saved_key[@]}")
+	else
+		if ! IFS= read -rsd '' -t ${wait_time:-0.0001} -n 1 key >/dev/null 2>&1; then key_out=""; return; fi
+		
+		
+		#* Read 3 more characters if a leading escape character is detected
+		if [[ $key == "${enter_key}" ]]; then key="enter"
+		elif [[ $key == "${backspace}" ]]; then key="backspace"
+		elif [[ $key == "${tab}" ]]; then key="tab"
+		elif [[ $key == "$esc_character" ]]; then esc=1; read -rsn3 -t 0.001 key || true; fi		
+		if [[ -z $key && $esc -eq 1 ]]; then key="escape"
+		elif [[ $esc -eq 1 ]]; then
+			case "${key}" in
+				'[A') key="up" ;;
+				'[B') key="down" ;;
+				'[D') key="left" ;;
+				'[C') key="right" ;;
+				'[2~') key="insert" ;;
+				'[3~') key="delete" ;;
+				'[H') key="home" ;;
+				'[F') key="end" ;;
+				'[5~') key="page_up" ;;
+				'[6~') key="page_down" ;;
+				'[Z') key="shift_tab" ;;
+				'OP') key="f1";;
+				'OQ') key="f2";;
+				'OR') key="f3";;
+				'OS') key="f4";;
+				'[15') key="f5";;
+				'[17') key="f6";;
+				'[18') key="f7";;
+				'[19') key="f8";;
+				'[20') key="f9";;
+				'[21') key="f10";;
+				'[23') key="f11";;
+				'[24') key="f12";;
+				*) key="" ;;
+			esac
+		fi
+
+		read -srd '' -t 0.00001 -n 10000 || true
+
+		if [[ -n $save ]]; then saved_key+=("${key}"); return; fi
+
+	fi
+	if [[ -n $ext_out ]]; then key_out="${key}"
+	else echo -n "${key}"; fi
+}
+
+process_input() { #? Process keypresses for main ui
+	local wait_time="$1" keypress esc prev_screen anykey filter_change
+
+	#* Wait while reading input
+	get_key -v keypress -w "${wait_time}"
+	if [[ -z $keypress ]]; then return; fi
+
+	if [[ -n $input_to_filter ]]; then
+		filter_change=1
+		case "$keypress" in
+			"enter") unset input_to_filter ;;
+			"backspace") if [[ ${#filter} -gt 0 ]]; then filter="${filter:: (-1)}"; else unset filter_change; fi ;;
+			"escape") unset input_to_filter filter ;;
+			*) if [[ ${#keypress} -eq 1 ]]; then filter="${filter}${keypress//[\\\$\"\']/}"; else unset filter_change; fi ;;
+		esac
+			
+	else
+		case "$keypress" in
+			left) #* Move left in processes sorting column
+				if ((proc[sorting_int]>0)); then ((proc[sorting_int]--))
+				else proc[sorting_int]=$((${#sorting[@]}-1)); fi
+				proc_sorting="${sorting[proc[sorting_int]]}"
+				filter_change=1
+			;;
+			right) #* Move right in processes sorting column
+				if ((proc[sorting_int]<${#sorting[@]}-1)); then ((++proc[sorting_int]))
+				else proc[sorting_int]=0; fi
+				proc_sorting="${sorting[proc[sorting_int]]}"
+				filter_change=1
+			;;
+			up|shift_tab)
+				if [[ ${proc[selected]} -gt 0 ]]; then
+					#if ! ((--proc[selected] & proc[page]==1)); then proc[page_change]=1; fi
+					((proc[selected]--))
+					if ((proc[page]>1 & proc[selected]==0)); then ((--proc[page])); proc[selected]=$((box[processes_height]-3)); fi
+					proc[page_change]=1
+				fi
+			;;
+			down|tab)
+				if ! ((proc[page]==proc[pages] & proc[selected]>=box[processes_height]-3)); then
+					if ((++proc[selected]==1)); then collect_processes now; proc[detailed_change]=1; fi
+					if ((proc[selected]>box[processes_height]-3)); then ((proc[page]++)); proc[selected]=1; fi
+					proc[page_change]=1
+				fi
+			;;
+			enter)
+				if ((proc[selected]>0 & proc[detailed_pid]!=proc[selected_pid])) && ps -p ${proc[selected_pid]} > /dev/null 2>&1; then
+					proc[detailed]=1
+					proc[detailed_change]=1
+					proc[detailed_pid]=${proc[selected_pid]}
+					proc[page]=1
+					proc[selected]=0
+					unset 'proc[detailed_name]' 'detail_history[@]' 'detail_mem_history[@]' 'proc[detailed_killed]'
+					calc_sizes
+					collect_processes now
+				elif ((proc[detailed]==1 & proc[detailed_pid]!=proc[selected_pid])); then
+					proc[detailed]=0
+					proc[detailed_change]=1
+					unset 'proc[detailed_pid]'
+					calc_sizes
+				fi
+			;;
+			page_up)
+				if [[ ${proc[page]} -gt 1 ]]; then
+					((--proc[page]))
+					proc[page_change]=1
+				elif [[ ${proc[selected]} -gt 0 ]]; then
+					proc[selected]=0
+					proc[page_change]=1
+				fi
+			;;
+			page_down)
+				if [[ ${proc[page]} -lt ${proc[pages]} ]]; then
+					if ((proc[page]++==1)); then collect_processes now; fi
+					proc[page_change]=1
+				elif [[ ${proc[selected]} -gt 0 ]]; then
+					proc[selected]=$((box[processes_height]-3))
+					proc[page_change]=1
+				fi
+			;;
+			home)
+					#proc[selected]=1
+					proc[page]=1
+					proc[page_change]=1
+			;;
+			end)
+					if ((proc[selected]==0)); then collect_processes now; fi
+					#proc[selected]=$((box[processes_height]-3))
+					proc[page]=${proc[pages]}
+					proc[page_change]=1
+			;;
+			r|R) #* Reverse order of processes sorting column
+				if [[ -z ${proc[reverse]} ]]; then
+					proc[reverse]="+"
+					proc_reversed="true"
+				else
+					proc_reversed="false"
+					unset 'proc[reverse]'
+				fi
+				filter_change=1
+			;;
+			o|O|f2) #* Options
+				options_
+			;;
+			+|A|a) #* Add 100ms to update timer
+				if ((update_ms<86399900)); then
+					update_ms=$((update_ms+100))
+					draw_update_string
+				fi
+			;;
+			-|S|s) #* Subtract 100ms from update timer
+				if ((update_ms>100)); then
+					update_ms=$((update_ms-100))
+					draw_update_string
+				fi
+			;;
+			h|H|f1) #* Show help
+				help_
+			;;
+			q|Q) #* Quit
+				quit_
+			;;
+			m|M|escape) #* Show main menu
+				menu_
+			;;
+			f|F) #* Start process filtering input
+				input_to_filter=1
+				filter_change=1
+				#filter_proc init
+			;;
+			c|C) #* Clear process filter
+				if [[ -n $filter ]]; then
+					unset input_to_filter filter
+					filter_change=1
+				fi
+			;;
+			t|T|k|K|i|I)
+				if [[ ${proc[selected]} -gt 0 ]]; then
+					killer_ "$keypress" "${proc[selected_pid]}"
+				elif [[ ${proc[detailed]} -eq 1 && -z ${proc[detailed_killed]} ]]; then
+					killer_ "$keypress" "${proc[detailed_pid]}"
+				fi
+			;;
+		esac
+	fi
+
+	if [[ -n $filter_change ]]; then
+		unset filter_change
+		collect_processes now
+		proc[filter_change]=1
+		draw_processes now
+	elif [[ ${proc[page_change]} -eq 1 || ${proc[detailed_change]} == 1 ]]; then
+		if ((proc[selected]==0)); then unset 'proc[selected_pid]'; proc[detailed_change]=1; fi
+		draw_processes now
+	fi
+
+	#* Subtract time since input start from time left if timer is interrupted
+	get_ms timestamp_input_end
+	time_left=$(( (timestamp_start+update_ms)-timestamp_input_end ))
+
+	return 0
+}
+
+collect_and_draw() { #? Run all collect and draw functions
+	local task_int=1
+	for task in processes cpu mem net; do
+		((++task_int))
+		if [[ -n $pause_screen ]]; then 
+			get_key -save
+			if [[ -n ${saved_key[0]} ]]; then return; fi
+		else
+			while ((${#saved_key[@]}>0)); do
+				process_input
+			done
+		fi
+		collect_${task}
+		get_key -save
+		draw_${task}
+		get_key -save
+		draw_clock "$1"
+		if ((resized>0 & resized<task_int)); then return; fi
+	done
+
+	last_screen="${draw_out}"
+}
+
+#? ----------------------------------------------------------------------------------------------------------------------- ?#
+
+main_loop() { #? main loop...
+	local wait_time wait_string
+
+	#* Put program to sleep if caught ctrl-z
+	if ((sleepy==1)); then sleep_; fi
+	
+	#* Timestamp for accurate timer
+	get_ms timestamp_start
+
+	if [[ $(stty size) != "$tty_height $tty_width" ]]; then resized; fi
+
+	if ((resized>0)); then
+		calc_sizes
+		draw_bg
+	fi
+
+	#* Run all collect and draw functions
+	collect_and_draw now
+
+	#* Reset resized variable if resized and all functions have finished redrawing
+	if ((resized>=5)); then resized=0
+	elif ((resized>0)); then unset draw_out proc_out clock_out; return; fi
+	
+	#* Echo everyting out to screen in one command to get a smooth transition between updates
+	echo -en "${draw_out}${proc_out}${clock_out}"
+	unset draw_out
+	
+	#* Compare timestamps to get exact time needed to wait until next loop
+	get_ms timestamp_end
+	time_left=$((timestamp_start+update_ms-timestamp_end))
+	if ((time_left>0)); then
+
+		late_update=0
+
+		#* Divide waiting time in chunks of 500ms and below to keep program responsive while reading input
+		while ((time_left>0 & resized==0)); do
+
+			#* If NOT waiting for input and time left is greater than 500ms, wait 500ms and loop
+			if [[ -z $input_to_filter ]] && ((time_left>=500)); then
+				wait_string="0.5"
+				time_left=$((time_left-500))
+			
+			#* If waiting for input and time left is greater than "50 ms", wait 50ms and loop
+			elif [[ -n $input_to_filter ]] && ((time_left>=50)); then
+				wait_string="0.05"
+				time_left=$((time_left-50))
+
+			#* Else format wait string with padded zeroes if needed and break loop
+			else 
+				printf -v wait_string ".%03d" "${time_left}"
+				time_left=0
+			fi
+
+			#* Wait while reading input			
+			process_input "${wait_string}"
+
+			#* Draw clock if set	
+			draw_clock now
+
+		done
+
+
+
+	#* If time left is too low to process any input more than twice in succession, add 100ms to update timer
+	elif ((++late_update==2)); then
+		update_ms=$((update_ms+100))
+		draw_update_string
+	fi
+	
+	if ((skip_process_draw==1)); then unset skip_process_draw; fi
+}
+
+sleep_() {
+
+	tput rmcup
+	stty echo
+	tput cnorm
+	
+	kill -s SIGSTOP $$
+}
+
+resume_() {
+
+	sleepy=0
+
+	tput smcup
+	stty -echo
+	tput civis
+
+	
+
+	if [[ -n $pause_screen ]]; then
+		echo -en "$pause_screen"
+	else
+		echo -en "${boxes_out}${proc_det}${last_screen}${mem_out}${proc_misc}${proc_misc2}${update_string}${clock_out}"
+	fi
+
+}
+
+#? Pre main loop
+
+#* Read config file or create if non existant
+if [[ -d "$HOME/.config/bashtop" && -w "$HOME/.config/bashtop" ]] || mkdir -p "$HOME/.config/bashtop"; then 
+	config_dir="$HOME/.config/bashtop"
+	config_file="${config_dir}/bashtop.cfg"
+	# shellcheck source=/dev/null
+	if [[ -e $config_file ]]; then
+		source "$config_file"
+
+		#* If current config is from an older version recreate config file and save user changes
+		if [[ $(get_value -sf "${config_file}" -k "bashtop v." -mk 1) != "${version}" ]]; then
+			create_config
+			save_config "${save_array[@]}"
+		fi
+	else create_config; fi
+else
+	#* If anything goes wrong turn off all writing to filesystem
+	echo "ERROR: Could not set config dir!"
+	config_dir="/dev/null"
+	config_file="/dev/null"
+	error_logging="false"
+	unset 'save_array[@]'
+fi
+
+#* Set up traps for ctrl-c, soft kill, window resize and resume from ctrl-z
+trap 'quitting=1; time_left=0' SIGINT SIGQUIT SIGTERM
+trap 'resized=1; time_left=0' SIGWINCH
+trap 'sleepy=1; time_left=0' SIGTSTP 
+trap 'resume_' SIGCONT
+
+
+
+#* Set up error logging to file if enabled
+if [[ $error_logging == true ]]; then
+	set -o errtrace
+	trap 'traperr' ERR
+
+	#* Remove everything but the last 500 lines of error log if larger than 500 lines
+	if [[ -e "${config_dir}/error.log" && $(wc -l <"${config_dir}/error.log") -gt 500 ]]; then
+		tail -n 500 "${config_dir}/error.log" > "${config_dir}/tmp"
+		rm "${config_dir}/error.log"
+		mv "${config_dir}/tmp" "${config_dir}/error.log"
+	fi
+	( echo " " ; echo "New instance of bashtop version: ${version} Pid: $$" ) >> "${config_dir}/error.log"
+	exec 2>>"${config_dir}/error.log"
+	if [[ $1 == "--debug" ]]; then
+		exec 19>"${config_dir}/tracing.log"
+		BASH_XTRACEFD=19
+		set -x
+	fi
+else
+	exec 2>/dev/null
+fi
+
+#* Call init function
+init_
+
+#* Start infinite loop
+until false; do main_loop; done
+
+#* Quit cleanly even if false starts being true...
+quit_
diff --git a/bin/cryptIt b/bin/cryptIt
index a51eb5a7..cff980fa 100755
--- a/bin/cryptIt
+++ b/bin/cryptIt
@@ -1,7 +1,11 @@
 #!/usr/bin/env bash
 
+if [ -f "$HOME/bin/mycommon" ]; then
+    . "$HOME/bin/mycommon"
+fi
+
 # help text
-function usage() {
+function usage(){
     echo "Usage:  cryptIt [options] [filename]."
     echo "Purpose: encrypt/decrypt files."
     echo "       "
@@ -14,16 +18,14 @@ function usage() {
     echo "cryptIt -e  README.txt"
     echo "cryptIt -d  "
     echo "cryptIt -d  README.txt.asc"
-    echo "       "
 }
 
 # Select a file using zenity/yad dialog
-function selcryptfile () {
-    local has_yad=`which yad`
-    if [ -z "$has_yad" ]; then
-        local f=`zenity --title="zcrypt: Select a file to $1" --file-selection`
+function X_selfile(){
+    if [ -z "$(command -v yad)" ]; then
+        local f=$(zenity --title="zcrypt: Select a file to $1" --file-selection)
     else
-        local f=`yad --title="zcrypt: Select a file to $1" --file-selection --center`
+        local f=$(yad --title="zcrypt: Select a file to $1" --file-selection --center)
     fi
     
     [ $? -gt 0 ] && f="";
@@ -32,40 +34,38 @@ function selcryptfile () {
 }
 
 # Encrypt selected file
-function encryptselfile () {
-    local f=`selcryptfile "encrypt"`
+function X_encrypt(){
+    local f="$(X_selfile "encrypt")"
     if [ -z "$f" ]; then
-        zenity --error --title "File Selection" --text "You must select a file to encrypt !"
+        gxmessage --center --ontop --sticky --nofocus --title "File Selection" "You must select a file to encrypt !"
     else
         encryptit "${f}"
-        
         if [ $? -gt 0  ]; then
-            zenity --error --title "File Encrypted" --text "$f has NOT been encrypted"
+            gxmessage --center --ontop --sticky --nofocus --title "File Encrypted" "$f has NOT been encrypted"
         else
-            zenity --info --title "File Encrypted" --text "$f has been encrypted"
+            gxmessage --center --ontop --sticky --nofocus --title "File Encrypted" "$f has been encrypted"
         fi
     fi
 }
 
 # Decrypt selected file
 # NOTE: This will OVERWRITE existing files with the same name !!!
-function decryptselfile () {
-    local f=`selcryptfile "decrypt"`
+function X_decrypt(){
+    local f="$(X_selfile "decrypt")"
     if [ -z "$f" ]; then
-        zenity --error --title "File Selection" --text "You must select a file to encrypt !"
+        gxmessage --center --ontop --sticky --nofocus --title "File Selection" "You must select a file to decrypt !"
     else
         decryptit "${f}"
-        
         if [ $? -gt 0  ]; then
-            zenity --error --title "File Decrypted" --text "$f has NOT been decrypted"
+            gxmessage --center --ontop --sticky --nofocus --title "File Decrypted" "$f has NOT been decrypted"
         else
-            zenity --info --title "File Decrypted" --text "$f has been decrypted"
+            gxmessage --center --ontop --sticky --nofocus --title "File Decrypted" "$f has been decrypted"
         fi
     fi
 }
 
 # Encrypt file using ascii armor and symmetric cipher
-function encryptit () {
+function encryptit(){
     if [ -z "$1" ] || [ ! -f "$1" ]; then
         return 1
     fi
@@ -73,7 +73,6 @@ function encryptit () {
     if [ -z "$2" ] ; then
         gpg -acq --yes "${1}"
         [ $? -gt 0  ] && return 1;
-
     else
         echo "$2" | gpg -acq --batch --yes --passphrase-fd 0 "${1}"
     fi
@@ -82,7 +81,7 @@ function encryptit () {
 
 # Decrypt a file
 # NOTE: This will OVERWRITE existing files with the same name !!!
-function decryptit () {
+function decryptit(){
     if [ -z "$1" ] || [ ! -f "$1" ]; then
         return 1
     fi
@@ -120,9 +119,9 @@ function read_pf() {
 # Encryption helper
 function do_encr() {
     if [ -z "$1" ]; then
-        encryptselfile
+        X_encrypt
     else
-        [ -f "$1" ] || { echo "$1 not found. You must select a file to encrypt !"; return 1; }
+        [ ! -f "$1" ] && echo "$1 not found. You must select a file to encrypt !" && return 1
         local pf=""
         printf "Passphrase: "
         while [ -z "$pf" ]; do
@@ -144,9 +143,9 @@ function do_encr() {
 # Decryption helper
 function do_decr() {
     if [ -z "$1" ]; then
-        decryptselfile
+        X_decrypt
     else
-        [ -f "$1" ] || { echo "$1 not found. You must select a file to decrypt !"; return 1; }
+        [ ! -f "$1" ] && echo "$1 not found. You must select a file to decrypt !" && return 1
         local pf=""
         printf "Passphrase: "
         while [ -z "$pf" ]; do
@@ -166,44 +165,53 @@ function do_decr() {
 }
 
 # Main
-if [ $# -eq 0 ] ; then
-    usage ;
-    exit 0
-fi
-
-# Option strings
-SHORT=":d::e::h"
-LONG=":decrypt,encrypt,help"
-
-# read the options
-OPTS=$(getopt --options $SHORT --long $LONG --name "$0" -- "$@")
-if [ $? -ne 0 ] ; then
-    echo "Wrong parameters $*";
-    usage ;
-    exit 1
-fi
-
-#eval set -- "$OPTS"
-
-if [ $? -ne 0 ] ; then
-    usage ;
-    exit 1
-fi
+function main(){
+    if [ $# -eq 0 ] ; then
+        usage ;
+        exit 1
+    fi
+    
+    # Option strings
+    local SHORT=":d::e::h"
+    local LONG=":decrypt,encrypt,help"
+    
+    # read the options
+    local OPTS=$(getopt --options $SHORT --long $LONG --name "$0" -- "$@")
+    if [ $? -ne 0 ] ; then
+        echo "Wrong parameters $*"
+        usage
+        exit 1
+    fi
+    
+    #eval set -- "$OPTS"
+    
+    if [ $? -ne 0 ] ; then
+        usage ;
+        exit 1
+    fi
+    
+    local fname=""
+    
+    while true ; do
+        case "$1" in
+            -d | --decrypt )
+                [ $# -gt 1 ] && fname="$2" ; shift 2
+                do_decr "$fname"
+                [ $? -gt 0  ] && exit 1 || exit 0
+            ;;
+            -e | --encrypt )
+                [ $# -gt 1 ] && fname="$2" ; shift 2
+                do_encr "$fname"
+                [ $? -gt 0  ] && exit 1 || exit 0
+            ;;
+            -h | --help )
+                usage && exit 0
+            ;;
+            *)  usage && exit 1
+            ;;
+        esac
+    done
+}
 
-fname=""
+main "$@"
 
-while true ; do
-    case "$1" in
-        -d | --decrypt )
-            [ $# -gt 1 ] && fname="$2" ; shift 2
-            do_decr "$fname"
-            [ $? -gt 0  ] && exit 1 || exit 0
-        ;;
-        -e | --encrypt )
-            [ $# -gt 1 ] && fname="$2" ; shift 2
-            do_encr "$fname"
-            [ $? -gt 0  ] && exit 1 || exit 0
-        ;;
-        *)  usage; exit;;
-    esac
-done
diff --git a/bin/dstart b/bin/dstart
new file mode 100755
index 00000000..adac871a
--- /dev/null
+++ b/bin/dstart
@@ -0,0 +1,35 @@
+#!/usr/bin/env bash
+# This script is intended to be run as an autostart/restart helper.
+
+if [ -f "$HOME/bin/mycommon" ]; then
+    . "$HOME/bin/mycommon"
+fi
+
+function main(){
+    precheck "pgrep"
+    precheck "pkill"
+
+    if [ $# -eq 0 ]; then
+        echo "Usage: `basename $0` {executable_name parameters}"
+        exit 0
+    fi
+    local orig_cmd="$1"
+    local cmd="$(command -v "$orig_cmd")"
+    local chkcmd="$(echo "$cmd" | grep "$orig_cmd")"
+    shift
+    kill_it "$orig_cmd"
+    if [ -z "$chkcmd" ]; then
+        echo "Starting $orig_cmd $@"
+        log "Starting $orig_cmd $@"
+        $orig_cmd "$@" &
+        disown
+    else
+        echo "Starting $cmd $@"
+        log "Starting $cmd $@"
+        $cmd "$@" &
+        disown
+    fi
+    exit 0
+}
+
+main "$@"
\ No newline at end of file
diff --git a/bin/finder b/bin/finder
new file mode 100755
index 00000000..8429a1c9
--- /dev/null
+++ b/bin/finder
@@ -0,0 +1,125 @@
+#!/usr/bin/env bash
+
+#PUT THIS FILE IN ~/.local/share/rofi/finder.sh
+#USE: rofi  -show find -modi find:~/.local/share/rofi/finder.sh
+
+function open_it(){
+    coproc ( xdg-open "$@"  > /dev/null 2>&1 )
+    exec 1>&-
+    exit;
+}
+
+function open_qry(){
+    local QUERY="$@"
+    coproc ( xdg-open "${QUERY%\/* \?\?}"  > /dev/null 2>&1 )
+    exec 1>&-
+    exit;
+}
+
+function mainmenu(){
+    echo " Type your search query to find files"
+    echo " Search again type !<search_query>"
+    echo " Search parent directories type ?<search_query>"
+    echo " You can print this help by typing !!"
+}
+
+function subm1(){
+    echo " Type your search query to find files"
+    echo " Search again type !<search_query>"
+    echo " Search parent directories type ?<search_query>"
+    echo " You can print this help by typing !!"
+}
+
+function do_lsearch(){
+    local optt="$1"
+    shift
+    local qr="$@"
+    realopt=""
+    case ${optt} in
+        )
+            echo "opt=$optt qr=$qr"
+        ;;
+        )
+            echo "opt=$optt qr=$qr"
+        ;;
+        )
+            echo "opt=$optt qr=$qr"
+            # LC_ALL=C find / -iname *"${qr#!}"* 2>&1 | grep -v 'Permission denied\|Input/output error'
+        ;;
+        )
+            echo "opt=$optt qr=$qr"
+        ;;
+    esac
+    return 0
+}
+
+function opthnd(){
+    local tmp="0"
+    [ -f "$2" ] && tmp=$(cat "$2" | wc -l)
+    if [ $tmp -ne 0 ]; then
+        cat "$2"
+        return 0
+    fi
+    echo "$1" | awk '{print $1}'
+}
+
+function main(){
+    local lockfile="/tmp/finder.$USER"
+    local QUERY="$@"
+    local opt=""
+    trap '[ -f "$lockfile" ] && rm -f "$lockfile"; exit' INT TERM EXIT ERR
+    if [ ! -z "$QUERY" ]; then
+        opt=$(opthnd "$QUERY" "$lockfile")
+        case ${opt} in
+            )
+                echo "$opt"
+                [ ! -f "$lockfile" ] && touch "$lockfile" && echo "$opt" >> "$lockfile"
+                if [ "$(echo "$QUERY" | awk '{print $1}')" != "$opt" ]; then
+                    LC_ALL=C find . -iname *"${QUERY#!}"* 2>&1 | grep -v 'Permission denied\|Input/output error'
+                fi
+            ;;
+            )
+                echo "$opt"
+                [ ! -f "$lockfile" ] && touch "$lockfile" && echo "$opt" >> "$lockfile"
+                if [ "$(echo "$QUERY" | awk '{print $1}')" != "$opt" ]; then
+                    LC_ALL=C find . -iname *"${QUERY#!}"* 2>&1 | grep -v 'Permission denied\|Input/output error'
+                fi
+            ;;
+            )
+                echo "$opt"
+                [ ! -f "$lockfile" ] && touch "$lockfile" && echo "$opt" >> "$lockfile"
+                if [ "$(echo "$QUERY" | awk '{print $1}')" != "$opt" ]; then
+                    LC_ALL=C find . -iname *"${QUERY#!}"* 2>&1 | grep -v 'Permission denied\|Input/output error'
+                fi
+            ;;
+            )
+                echo "$opt"
+                [ ! -f "$lockfile" ] && touch "$lockfile" && echo "$opt" >> "$lockfile"
+                if [ "$(echo "$QUERY" | awk '{print $1}')" != "$opt" ]; then
+                    LC_ALL=C find . -iname *"${QUERY#!}"* 2>&1 | grep -v 'Permission denied\|Input/output error'
+                fi
+            ;;
+        esac
+        mainmenu
+        #    if [[ "$QUERY" == /* ]]; then
+        #        if [[ "$QUERY" == *\?\? ]]; then
+        #            open_qry "$QUERY"
+        #        else
+        #            open_it "$QUERY"
+        #        fi
+        #    elif [[ "$QUERY" == \!\!* ]]; then
+        #        mainmenu
+        #    elif [[ "$QUERY" == \?* ]]; then
+        #        while read -r line; do
+        #            echo "$line" \?\?
+        #        done <<< $(LC_ALL=C find / -iname *"${QUERY#\?}"* 2>&1 | grep -v 'Permission denied\|Input/output error')
+        #    else
+        #        LC_ALL=C find / -iname *"${QUERY#!}"* 2>&1 | grep -v 'Permission denied\|Input/output error'
+        #    fi
+    else
+        mainmenu
+        #[ -f "$lockfile" ] && rm -f "$lockfile"
+    fi
+}
+
+main "$@"
\ No newline at end of file
diff --git a/bin/goto.sh b/bin/goto.sh
new file mode 100755
index 00000000..456f9dce
--- /dev/null
+++ b/bin/goto.sh
@@ -0,0 +1,431 @@
+#!/usr/bin/env bash
+# shellcheck shell=bash
+# shellcheck disable=SC2039
+# MIT License
+#
+# Copyright (c) 2018 Lazarus Lazaridis
+#
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+#
+# The above copyright notice and this permission notice shall be included in all
+# copies or substantial portions of the Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+# SOFTWARE.
+
+# Changes to the given alias directory
+# or executes a command based on the arguments.
+goto()
+{
+    local target
+    _goto_resolve_db
+
+    if [ -z "$1" ]; then
+        # display usage and exit when no args
+        _goto_usage
+        return
+    fi
+
+    subcommand="$1"
+    shift
+    case "$subcommand" in
+        -c|--cleanup)
+            _goto_cleanup "$@"
+        ;;
+        -r|--register) # Register an alias
+            _goto_register_alias "$@"
+        ;;
+        -u|--unregister) # Unregister an alias
+            _goto_unregister_alias "$@"
+        ;;
+        -p|--push) # Push the current directory onto the pushd stack, then goto
+            _goto_directory_push "$@"
+        ;;
+        -o|--pop) # Pop the top directory off of the pushd stack, then change that directory
+            _goto_directory_pop
+        ;;
+        -l|--list)
+            _goto_list_aliases
+        ;;
+        -x|--expand) # Expand an alias
+            _goto_expand_alias "$@"
+        ;;
+        -h|--help)
+            _goto_usage
+        ;;
+        -v|--version)
+            _goto_version
+        ;;
+        *)
+            _goto_directory "$subcommand"
+        ;;
+    esac
+    return $?
+}
+
+_goto_resolve_db()
+{
+    GOTO_PATH="$HOME/.config/goto"
+    [ ! -d "$GOTO_PATH" ] && mkdir -p "${GOTO_PATH}"
+    GOTO_DB="${GOTO_DB:-$GOTO_PATH/goto_db}"
+    touch -a "$GOTO_DB"
+}
+
+_goto_usage()
+{
+cat <<\USAGE
+usage: goto [<option>] <alias> [<directory>]
+
+default usage:
+  goto <alias> - changes to the directory registered for the given alias
+
+OPTIONS:
+  -r, --register: registers an alias
+    goto -r|--register <alias> <directory>
+  -u, --unregister: unregisters an alias
+    goto -u|--unregister <alias>
+  -p, --push: pushes the current directory onto the stack, then performs goto
+    goto -p|--push <alias>
+  -o, --pop: pops the top directory from the stack, then changes to that directory
+    goto -o|--pop
+  -l, --list: lists aliases
+    goto -l|--list
+  -x, --expand: expands an alias
+    goto -x|--expand <alias>
+  -c, --cleanup: cleans up non existent directory aliases
+    goto -c|--cleanup
+  -h, --help: prints this help
+    goto -h|--help
+  -v, --version: displays the version of the goto script
+    goto -v|--version
+USAGE
+}
+
+# Displays version
+_goto_version()
+{
+    echo "goto version 1.2.3.1"
+}
+
+# Expands directory.
+# Helpful for ~, ., .. paths
+_goto_expand_directory()
+{
+    builtin cd "$1" 2>/dev/null && pwd
+}
+
+# Lists registered aliases.
+_goto_list_aliases()
+{
+    local IFS=$' '
+    if [ -f "$GOTO_DB" ]; then
+        while read -r name directory; do
+            printf '\e[1;36m%20s  \e[0m%s\n' "$name" "$directory"
+        done < "$GOTO_DB"
+    else
+        echo "You haven't configured any directory aliases yet."
+    fi
+}
+
+# Expands a registered alias.
+_goto_expand_alias()
+{
+    if [ "$#" -ne "1" ]; then
+        _goto_error "usage: goto -x|--expand <alias>"
+        return
+    fi
+
+    local resolved
+    resolved=$(_goto_find_alias_directory "$1")
+    if [ -z "$resolved" ]; then
+        _goto_error "alias '$1' does not exist"
+        return
+    fi
+    echo "$resolved"
+}
+
+# Lists duplicate directory aliases
+_goto_find_duplicate()
+{
+    local duplicates=
+    duplicates=$(sed -n 's:[^ ]* '"$1"'$:&:p' "$GOTO_DB" 2>/dev/null)
+    echo "$duplicates"
+}
+
+# Registers and alias.
+_goto_register_alias()
+{
+    if [ "$#" -ne "2" ]; then
+        _goto_error "usage: goto -r|--register <alias> <directory>"
+        return 1
+    fi
+
+    if ! [[ $1 =~ ^[[:alnum:]]+[a-zA-Z0-9_-]*$ ]]; then
+        _goto_error "invalid alias - can start with letters or digits followed by letters, digits, hyphens or underscores"
+        return 1
+    fi
+
+    local resolved
+    resolved=$(_goto_find_alias_directory "$1")
+
+    if [ -n "$resolved" ]; then
+        _goto_error "alias '$1' exists"
+        return 1
+    fi
+
+    local directory
+    directory=$(_goto_expand_directory "$2")
+    if [ -z "$directory" ]; then
+        _goto_error "failed to register '$1' to '$2' - can't cd to directory"
+        return 1
+    fi
+
+    local duplicate
+    duplicate=$(_goto_find_duplicate "$directory")
+    if [ -n "$duplicate" ]; then
+        _goto_warning "duplicate alias(es) found: \\n$duplicate"
+    fi
+    # Append entry to file.
+    echo "$1 $directory" >> "$GOTO_DB"
+    echo "Alias '$1' registered successfully."
+}
+
+# Unregisters the given alias.
+_goto_unregister_alias()
+{
+    if [ "$#" -ne "1" ]; then
+        _goto_error "usage: goto -u|--unregister <alias>"
+        return 1
+    fi
+    local resolved
+    resolved=$(_goto_find_alias_directory "$1")
+    if [ -z "$resolved" ]; then
+        _goto_error "alias '$1' does not exist"
+        return 1
+    fi
+    GOTO_PATH="$HOME/.config/goto"
+    # shellcheck disable=SC2034
+    local readonly GOTO_DB_TMP="$GOTO_PATH/goto_"
+    # Delete entry from file.
+    sed "/^$1 /d" "$GOTO_DB" > "$GOTO_DB_TMP" && mv "$GOTO_DB_TMP" "$GOTO_DB"
+    echo "Alias '$1' unregistered successfully."
+}
+
+# Pushes the current directory onto the stack, then goto
+_goto_directory_push()
+{
+    if [ "$#" -ne "1" ]; then
+        _goto_error "usage: goto -p|--push <alias>"
+        return
+    fi
+    { pushd . || return; } 1>/dev/null 2>&1
+    _goto_directory "$@"
+}
+
+# Pops the top directory from the stack, then goto
+_goto_directory_pop()
+{
+    { popd || return; } 1>/dev/null 2>&1
+}
+
+# Unregisters aliases whose directories no longer exist.
+_goto_cleanup()
+{
+    if ! [ -f "$GOTO_DB" ]; then
+        return
+    fi
+
+    while IFS= read -r i && [ -n "$i" ]; do
+        echo "Cleaning up: $i"
+        _goto_unregister_alias "$i"
+    done <<< "$(awk '{al=$1; $1=""; dir=substr($0,2); system("[ ! -d \"" dir "\" ] && echo " al)}' "$GOTO_DB")"
+}
+
+# Changes to the given alias' directory
+_goto_directory()
+{
+    local target
+    target=$(_goto_resolve_alias "$1") || return 1
+    builtin cd "$target" 2> /dev/null || { _goto_error "Failed to goto '$target'" && return 1; }
+}
+
+# Fetches the alias directory.
+_goto_find_alias_directory()
+{
+    local resolved
+    resolved=$(sed -n "s/^$1 \\(.*\\)/\\1/p" "$GOTO_DB" 2>/dev/null)
+    echo "$resolved"
+}
+
+# Displays the given error.
+# Used for common error output.
+_goto_error()
+{
+    (>&2 echo -e "goto error: $1")
+}
+
+# Displays the given warning.
+# Used for common warning output.
+_goto_warning()
+{
+    (>&2 echo -e "goto warning: $1")
+}
+
+# Displays entries with aliases starting as the given one.
+_goto_print_similar()
+{
+    local similar
+    similar=$(sed -n "/^$1[^ ]* .*/p" "$GOTO_DB" 2>/dev/null)
+    if [ -n "$similar" ]; then
+        (>&2 echo "Did you mean:")
+        (>&2 column -t <<< "$similar")
+    fi
+}
+
+# Fetches alias directory, errors if it doesn't exist.
+_goto_resolve_alias()
+{
+    local resolved
+    resolved=$(_goto_find_alias_directory "$1")
+    if [ -z "$resolved" ]; then
+        _goto_error "unregistered alias $1"
+        _goto_print_similar "$1"
+        return 1
+    else
+        echo "${resolved}"
+    fi
+}
+
+# Completes the goto function with the available commands
+_complete_goto_commands()
+{
+    local IFS=$' \t\n'
+    # shellcheck disable=SC2207
+    COMPREPLY=($(compgen -W "-r --register -u --unregister -p --push -o --pop -l --list -x --expand -c --cleanup -v --version" -- "$1"))
+}
+
+# Completes the goto function with the available aliases
+_complete_goto_aliases()
+{
+    local IFS=$'\n' matches
+    _goto_resolve_db
+
+    # shellcheck disable=SC2207
+    matches=($(sed -n "/^$1/p" "$GOTO_DB" 2>/dev/null))
+
+    if [ "${#matches[@]}" -eq "1" ]; then
+        # remove the filenames attribute from the completion method
+        compopt +o filenames 2>/dev/null
+        # if you find only one alias don't append the directory
+        COMPREPLY=("${matches[0]// *}")
+    else
+        for i in "${!matches[@]}"; do
+            # remove the filenames attribute from the completion method
+            compopt +o filenames 2>/dev/null
+            if ! [[ $(uname -s) =~ Darwin* ]]; then
+                matches[$i]=$(printf '%*s' "-$COLUMNS" "${matches[$i]}")
+                COMPREPLY+=("$(compgen -W "${matches[$i]}")")
+            else
+                COMPREPLY+=("${matches[$i]// */}")
+            fi
+        done
+    fi
+}
+
+# Bash programmable completion for the goto function
+_complete_goto_bash()
+{
+    local cur="${COMP_WORDS[$COMP_CWORD]}" prev
+  
+    if [ "$COMP_CWORD" -eq "1" ]; then
+        # if we are on the first argument
+        if [[ $cur == -* ]]; then
+            # and starts like a command, prompt commands
+            _complete_goto_commands "$cur"
+        else
+            # and doesn't start as a command, prompt aliases
+            _complete_goto_aliases "$cur"
+        fi
+    elif [ "$COMP_CWORD" -eq "2" ]; then
+        # if we are on the second argument
+        prev="${COMP_WORDS[1]}"
+        if [[ $prev = "-u" ]] || [[ $prev = "--unregister" ]]; then
+            # prompt with aliases if user tries to unregister one
+            _complete_goto_aliases "$cur"
+        elif [[ $prev = "-x" ]] || [[ $prev = "--expand" ]]; then
+            # prompt with aliases if user tries to expand one
+            _complete_goto_aliases "$cur"
+        elif [[ $prev = "-p" ]] || [[ $prev = "--push" ]]; then
+            # prompt with aliases only if user tries to push
+            _complete_goto_aliases "$cur"
+        fi
+    elif [ "$COMP_CWORD" -eq "3" ]; then
+        # if we are on the third argument
+        prev="${COMP_WORDS[1]}"
+        if [[ $prev = "-r" ]] || [[ $prev = "--register" ]]; then
+            # prompt with directories only if user tries to register an alias
+            local IFS=$' \t\n'
+            # shellcheck disable=SC2207
+            COMPREPLY=($(compgen -d -- "$cur"))
+        fi
+    fi
+}
+
+# Zsh programmable completion for the goto function
+_complete_goto_zsh()
+{
+    local all_aliases=()
+    while IFS= read -r line; do
+        all_aliases+=("$line")
+    done <<< "$(sed -e 's/ /:/g' "${GOTO_DB}" 2>/dev/null)"
+  
+    local state
+    local -a options=(
+      '(1)'{-r,--register}'[registers an alias]:register:->register'
+      '(- 1 2)'{-u,--unregister}'[unregisters an alias]:unregister:->unregister'
+      '(: -)'{-l,--list}'[lists aliases]'
+      '(*)'{-c,--cleanup}'[cleans up non existent directory aliases]'
+      '(1 2)'{-x,--expand}'[expands an alias]:expand:->aliases'
+      '(1 2)'{-p,--push}'[pushes the current directory onto the stack, then performs goto]:push:->aliases'
+      '(*)'{-o,--pop}'[pops the top directory from stack, then changes to that directory]'
+      '(: -)'{-h,--help}'[prints this help]'
+      '(* -)'{-v,--version}'[displays the version of the goto script]'
+    )
+    _arguments -C "${options[@]}" \
+        '1:alias:->aliases' \
+        '2:dir:_files' \
+        && ret=0
+    case ${state} in
+        (aliases)
+            _describe -t aliases 'goto aliases:' all_aliases && ret=0
+        ;;
+        (unregister)
+            _describe -t aliases 'unregister alias:' all_aliases && ret=0
+        ;;
+    esac
+    return $ret
+}
+
+# Register the goto completions.
+if [ -n "${BASH_VERSION}" ]; then
+    if ! [[ $(uname -s) =~ Darwin* ]]; then
+        complete -o filenames -F _complete_goto_bash goto
+    else
+        complete -F _complete_goto_bash goto
+    fi
+elif [ -n "${ZSH_VERSION}" ]; then
+    compdef _complete_goto_zsh goto
+else
+    echo "Unsupported shell."
+    exit 1
+fi
diff --git a/bin/manp b/bin/manp
index bb8da40e..95ce84dc 100755
--- a/bin/manp
+++ b/bin/manp
@@ -1,6 +1,7 @@
 #!/usr/bin/env bash
 
-if [[ "$1" == "-h" || "$1" == "--help" ]]; then cat <<HELP
+function usage(){
+cat <<HELP
 Manpage-as-PDF Viewer
 http://benalman.com/
 
@@ -13,24 +14,40 @@ Copyright (c) 2012 "Cowboy" Ben Alman
 Licensed under the MIT license.
 http://benalman.com/about/license/
 HELP
-exit; 
-fi
-
-if [ ! "$1" ]; then
-  echo 'What manual page do you want?!'
-  exit
-fi
-
-cache_dir=$HOME/.cache/manpdf
-
-# Figure out what the filename should be.
-file="$cache_dir/${2:+$2.}$1.pdf"
-
-# Create directory if it doesn't exist.
-[[ -e "$cache_dir" ]] || mkdir -p "$cache_dir"
-
-# Create PDF if it doesn't exist.
-[[ -e "$file" ]] || man -t "$@" | ps2pdf - "$file" >/dev/null 2>&1
-
-# Open PDF (if it does exist).
-[[ -e "$file" ]] && xdg-open "$file"
+}
+
+function main(){
+    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
+        usage
+        exit 0;
+    fi
+    
+    if [ -z "$1" ]; then
+        echo 'What manual page do you want?!'
+        exit
+    fi
+    
+    # Set cache dir name..
+    local cache_dir=$HOME/.cache/manpdf
+    
+    # Figure out what the filename should be.
+    local file="$cache_dir/${2:+$2.}$1.pdf"
+    
+    # Open PDF (if it does exist).
+    [[ -e "$file" ]] && xdg-open "$file" && exit 0
+    
+    # Create directory if it doesn't exist.
+    [[ -e "$cache_dir" ]] || mkdir -p "$cache_dir"
+    
+    # Create PDF because it doesn't exist.
+    local psbuff="$(man -t "$@")"
+    
+    if [ $? -eq 0 ]; then
+        echo "${psbuff}" | ps2pdf - "$file" >/dev/null 2>&1
+        xdg-open "$file"
+    fi
+    
+    exit 0
+}
+
+main "$@"
\ No newline at end of file
diff --git a/bin/movie2gif b/bin/movie2gif
new file mode 100755
index 00000000..b8a9f4ec
--- /dev/null
+++ b/bin/movie2gif
@@ -0,0 +1,45 @@
+#!/usr/bin/env bash
+# A small script to convert movies (tested with mpg files) into gifs.
+# Usage: ./movie2gif input.mpeg [output.gif]
+#set -eu
+
+if [ -f "$HOME/bin/mycommon" ]; then
+    . "$HOME/bin/mycommon"
+fi
+
+function usage(){
+cat <<EOF
+Usage: $(basename "$0") input.mpeg [output.gif]
+
+A small script to convert movies (tested with mpg files) into gifs.
+EOF
+}
+
+function main(){
+    [ -z "$1" ] && usage && exit 1
+    precheck "ffmpeg"
+    precheck "imgemagick"
+    
+    local INPUT="$1"
+    local OUTPUT="$2"
+    
+    if [ -z ${2+x} ]; then
+        OUTPUT="$1.gif"
+    fi
+    
+    [ ! -d /tmp/gif ] && mkdir -p /tmp/gif
+    trap 'rm -rf /tmp/gif; exit' INT TERM EXIT ERR
+    
+    echo "Converting..."
+    ffmpeg -loglevel panic -i $INPUT -vf scale=320:-1:flags=lanczos,fps=10 /tmp/gif/ffout%04d.png
+    
+    echo "Generating gif..."
+    convert -loop 0 -delay 10 /tmp/gif/*.png $OUTPUT
+    
+    echo "Cleaning up..."
+    rm -rf /tmp/gif
+    
+    echo "Converted the movie into $OUTPUT"
+}
+
+main "$@"
diff --git a/bin/my-motd b/bin/my-motd
index 2dd6579f..68855cd3 100755
--- a/bin/my-motd
+++ b/bin/my-motd
@@ -1,22 +1,21 @@
 #!/usr/bin/env bash
+# Show a message of the day quotation(via fortune)
 
 if [ -f "$HOME/bin/mycommon" ]; then
     . "$HOME/bin/mycommon"
 fi
 
-# Show a message of the day quotation(via fortune)
 function main() {
-    local fortcmd=""
-    fortcmd="$(command -v fortune 2> /dev/null)"
+    local fortcmd="$(command -v fortune 2> /dev/null)"
     [ -z "$fortcmd" ] && exit 0
     [ -f ~/.plan ] && rm -f ~/.plan &>/dev/null
     ${fortcmd} -a > ~/.plan
     while [ $(wc -l < ~/.plan) -ge 3 ]; do
-      rm -f ~/.plan &>/dev/null
-      ${fortcmd} -a > ~/.plan
+        rm -f ~/.plan &>/dev/null
+        ${fortcmd} -a > ~/.plan
     done
     # awk '{ print $0 }' ~/.plan | sed -e 's/^[ \t]*//' | awk '{$1=$1}1' | cowsay -f $(random_cow_file)
     awk '{ print $0 }' ~/.plan | sed -e 's/^[ \t]*//' | awk '{$1=$1}1'
 }
 
-main
+main "$@"
diff --git a/bin/mycommon b/bin/mycommon
index 877400a5..ac001c8d 100644
--- a/bin/mycommon
+++ b/bin/mycommon
@@ -4,15 +4,10 @@ test -f ${XDG_CONFIG_HOME:-~/.config}/user-dirs.dirs && source ${XDG_CONFIG_HOME
 
 # Find and/or create path for logging
 function doLogPath() {
-    local fpPath="/var/log"
-    [ ! -w "$fpPath" ] && fpPath="$HOME/.local/var/log" ;
-    [ ! -d "$fpPath" ] && mkdir -p $fpPath ;
-    if [ ! -d "$fpPath" ]; then
-        echo ""
-        return 1
-    fi
-    echo "$fpPath"
-    return 0
+    local lpath="/var/log"
+    [ -w "$lpath" ] && echo "$lpath" && return 0  || lpath="$HOME/.local/var/log"
+    [ ! -d "$lpath" ] && mkdir -p $lpath 
+    [ -d "$lpath" ] && echo "$lpath" && return 0 || echo "" &&  return 1
 }
 
 # Script name that is sourcing this
@@ -42,14 +37,20 @@ function log() {
 
 function bailout () {
     echo "Error: $@"
+    [ -f "$myLogFile" ] && log "Error: $@"
     exit 1
 }
 
-# Check required software
+# Check for required software
 function precheck () {
     hash "$1" >/dev/null 2>&1 || bailout "Please install $1"
 }
 
+# Check for software existence 
+function checkfor () {
+    hash "$1" >/dev/null 2>&1 && return 0 || return 1
+}
+
 # direct it all to /dev/null
 function nullify() {
     "$@" >/dev/null 2>&1
@@ -65,95 +66,146 @@ function is_git_repository() {
     [ "$(git rev-parse &>/dev/null; printf $?)" -eq 0 ] && return 0 || return 1
 }
 
-# Trim leading and tailing spaces
+# Trim all spaces
 # Usage: trim_string "   example   string    "
-function trim_string() {
+function trim_spaces() {
     : "${1#"${1%%[![:space:]]*}"}"
     : "${_%"${_##*[![:space:]]}"}"
     printf '%s\n' "$_"
 }
 
+# remove trailing slash (substitute for realpath -s)
+# warning: returns empty if $1 is just /
+function trim_slash() {
+    printf "%s" "${1%/}"
+}
+
+# Trim leading spaces
+# Usage: ltrim "   example   string    "
+function ltrim() {
+    : "${1#"${1%%[![:space:]]*}"}"
+    printf '%s\n' "$_"
+}
+
+# Trim tailing spaces
+# Usage: rtrim "  example   string    "
+function rtrim() {
+    : "${1%"${1##*[![:space:]]}"}"
+    printf '%s\n' "$_"
+}
+
+# Ask for a simple yes/no confirmation
+# Usage: ask_confirmation "Are you ready?"
+function ask_confirmation() {
+    printf "\n${_cl_bold}$@${_cl_reset}"
+    read -p " (y/n) " -n 1
+    printf "\n"
+}
+
+# Test whether the result of an 'ask' is a confirmation
+# Usage: is_confirmed 
+function is_confirmed() {
+    [[ "$REPLY" =~ ^[Yy]$ ]] && return 0 || return 1
+}
+
 # Usage: say text [delayAfterText]
 function say() {
     fold -s -w 76 <<< "$1" | sed 's/^/  /' # wraps text nicely and adds two leading spaces
     snore "${2-0}"
 }
 
-# Adapted from Addy
-# 'battery_stt -i' = with icon, 'battery' = text only
-function battery_stt(){
-    local BATTERY=0
-    local BATTERY_INFO=$(acpi -b | grep "Battery ${BATTERY}")
-    local BATTERY_STATE=$(echo "${BATTERY_INFO}" | grep -wo "Full\|Charging\|Discharging")
-    local BATTERY_POWER=$(echo "${BATTERY_INFO}" | grep -o '[0-9]\+%' | tr -d '%')
-    
-    if [[ "${BATTERY_STATE}" = "Charging" ]]; then
-        if  [[ $1 = "-i" ]]; then
-            echo "  ${BATTERY_POWER}%+"
-        else
-            echo "${BATTERY_POWER}%+"
-        fi
-    elif [[ "${BATTERY_STATE}" = "Discharging" ]]; then
-        if  [[ $1 = "-i" ]]; then
-            echo "  ${BATTERY_POWER}%-"
-        else
-            echo "${BATTERY_POWER}%-"
-        fi
-    else
-        if  [[ $1 = "-i" ]]; then
-            echo "  ${BATTERY_POWER}%"
-        else
-            echo "${BATTERY_POWER}%"
-        fi
-    fi
-}
-
 # ps with ISO date format
 function ps_ISO(){
     if [ -z "$1" ]; then
-        ps -eo etimes,ruser,pid,cmd --sort=start_time | \
-            awk 'BEGIN{now=systime()} {$1=strftime("%Y-%m-%d-%H:%M:%S", now-$1); print $0}' | grep -v "grep" | grep -v "awk"
+        ps -eo etimes,ruser,pid,ppid,cmd --sort=start_time | awk 'BEGIN{now=systime()} {$1=strftime("%Y-%m-%d-%H:%M:%S", now-$1); print $0}' | grep -v "grep" | grep -v "awk"
     else
-        ps -eo etimes,ruser,pid,cmd --sort=start_time | \
-            awk 'BEGIN{now=systime()} {$1=strftime("%Y-%m-%d-%H:%M:%S", now-$1); print $0}' | grep -v "grep" | grep -v "awk" | grep "$1"
+        ps -eo etimes,ruser,pid,ppid,cmd --sort=start_time | awk 'BEGIN{now=systime()} {$1=strftime("%Y-%m-%d-%H:%M:%S", now-$1); print $0}' | grep -v "grep" | grep -v "awk" | grep "$1"
     fi
 }
 
-# Kill older instances of itself
+# Kill older instances of itself (bash based scripts)
 function kill_older(){
     local s_name="${0##*/}"
     local my_pid=$$
     snore 0.3
     for i in $(ps_ISO "$s_name" | grep "$USER" | grep -P "bash" | grep -v "grep" | awk '{print $3}'); do 
         if [ "$i" != "$my_pid" ]; then
-            log "Older instances found: pid=$i  name=$s_name "
-            kill "$i" &>/dev/null || true
+            kill "$i" &>/dev/null && log "Older instances found: pid=$i  name=$s_name"
+            [ $? -ne 0 ] && kill -9 "$i" &>/dev/null && log "Older instances found: pid=$i name=$s_name" || true
         fi
     done
     return 0
 }
 
+# Kill all process by pattern (but not me)
+function kill_it(){
+    local s_name="$1"
+    snore 0.3
+    for i in $(ps_ISO "$s_name" | grep "$USER" | grep -v "grep" | awk '{print $3}'); do 
+        if [ "$i" != "$$" ]; then
+            kill "$i" &>/dev/null && log "Stopping instance(kill): pid=$i name=$s_name"
+            [ $? -ne 0 ] && kill -9 "$i" &>/dev/null && log "Stopping instance(kill): pid=$i name=$s_name" || true
+            snore 0.1
+        fi
+    done
+    return 0
+}
+
+# Cleanup running processes.
+function stop_it() {
+    [ -z "$1" ] && return 1
+    local s_name="$1"
+    case ${2:-stop} in
+        stop)
+            for i in $(ps_ISO "$s_name" | grep -v "grep" | awk '{print $3}'); do 
+                kill "$i" &>/dev/null && log "Stopping instance(kill): pid=$i name=$s_name"
+                [ $? -ne 0 ] && kill -9 "$i" &>/dev/null && log "Stopping instance(kill): pid=$i name=$s_name"
+                [ $? -ne 0 ] && pkill -USR1 --euid "$(id -u)" --exact "$s_name" && log "Stopping instances(pkill): name=$s_name " 
+                [ $? -ne 0 ] && killall "$1" > /dev/null && log "Stopping instances(killall): name=$s_name " || true
+                snore 0.1
+            done
+            return 0
+        ;;
+        debug)
+            if [ $(pgrep -lfc "$1") -ge 1 ] ; then
+                log "$1 need to be terminated"
+            else
+                log "$1 not found"
+            fi
+            return 0
+        ;;
+        *)
+            log "2nd argument must be: stop or debug";
+            return 1
+        ;;
+    esac
+}
+
 # Return 0 if user in the active session can issue power related commands via policykit
 function auth_user() {
     [ $(loginctl show-session $XDG_SESSION_ID --property=Active | grep "yes") ] && return 0
     return 1
 }
 
+# Check if can hibernate using dbus
 function can_hibernate() {
     [ $(qdbus --system org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.CanHibernate | grep "yes") ] && return 0
     return 1
 }
 
+# Check if can poweroff using dbus
 function can_poweroff() {
     [ $(qdbus --system org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.CanPowerOff | grep "yes") ] && return 0
     return 1
 }
 
+# Check if can reboot using dbus
 function can_reboot() {
     [ $(qdbus --system org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.CanReboot | grep "yes") ] && return 0
     return 1
 }
 
+# Check if can suspend using dbus
 function can_suspend() {
     [ $(qdbus --system org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.CanSuspend | grep "yes") ] && return 0
     return 1
@@ -191,44 +243,9 @@ function dbus_suspend() {
     /org/freedesktop/login1 "org.freedesktop.login1.Manager.Suspend" boolean:true
 }
 
-# Return 0 if systemctl is found.
-function systemctl_ok() {
-    [ $(command -v systemctl) ] && return 0
-    return 1
-}
-
-# Return 0 if shutdown is found.
-function shutdown_ok() {
-    [ $(command -v shutdown) ] && return 0
-    return 1
-}
-
-# Return 0 if init is found.
-function init_ok() {
-    [ $(command -v init) ] && return 0
-    return 1
-}
-
-# Is the screen already locked?
-function locked() {
-    local DebugMode=${1:-no}
-    local scrsvApps=('i3lock' 'mate-screensaver-dialog' 'cinnamon-screensaver-pam-helper' 'slimlock' 'gnome-screensaver-dialog' 'xscreensaver')
-    local c=0
-    for p1 in "${scrsvApps[@]}"; do
-        c=$(pgrep -lfc "${p1}")
-        if [ $c -gt 0 ] ; then
-            if [ "$DebugMode" = "debug" ]; then
-                log "${p1} found and active";
-                return 0;
-            fi
-        fi
-    done
-    return 1;
-}
-
 # Control the dunst daemon, if it is running.
 function dunstctl() {
-    pkill -0 --exact dunst || return 0
+    [ $(pgrep -lfc dunst) -ge 1 ] || return 0
     
     case ${1:-} in
         stop)
@@ -238,10 +255,12 @@ function dunstctl() {
         resume)
             log "...Resuming notifications."
             pkill -USR2 --euid "$(id -u)" --exact dunst
+            dunst &
+            disown
         ;;
         check)
             log "Checking for dunst."
-            [ $(command -v dunst) ] && return 0 || return 1
+            checkfor "dunst" && return 0 || return 1
         ;;
         *)
             echo "dunstctl argument required: stop, resume or check"
@@ -251,196 +270,129 @@ function dunstctl() {
     return 0
 }
 
-# Cleanup running processes.
-function stop_it() {
-    [ -z "$1" ] && return 1
-    
-    case ${2:-} in
-        stop)
-            if [ $(pgrep -lfc "$1") -ge 1 ] ; then
-                local v_pid=( $(ps -aux | grep "$1" | egrep -v 'grep --color=auto' | sort -u | awk '{print $2}') )
-                local v_len=${#v_pid[@]}
-                let v_len=v_len-1
-                local one_pid="0"
-                for i in $(seq 0 $v_len ); do
-                    one_pid=$(echo "${v_pid[$i]}");
-                    log "killing $1 pid= $one_pid"
-                    kill "$one_pid" &>/dev/null || true
-                    sleep 0.1;
-                done
-            fi
-            return 0
-        ;;
-        debug)
-            if [ $(pgrep -lfc "$1") -ge 1 ] ; then
-                log "$1 need to be terminated"
-            else
-                log "$1 not found"
-            fi
-            return 0
-        ;;
-        *)
-            log "2nd argument must be: stop or debug";
-            return 1
-        ;;
-    esac
-}
-
 # xset required
 # check for a running X server
 function is_running_X(){
-    if ! xset q &>/dev/null; then
-        return 1
-    fi
-    return 0
+    xset q &>/dev/null && return 0 || return 1
+}
+
+# Is the screen already locked?
+function locked() {
+    local sclist=('i3lock' 'mate-screensaver-dialog' 'cinnamon-screensaver-pam-helper' 'slimlock' 'gnome-screensaver-dialog' 'xscreensaver')
+    for p in "${sclist[@]}"; do
+        [ $(pgrep -lfc "${p}") -gt 0 ] && return 0;
+    done
+    return 1;
 }
 
-# builtin sleep in bash
+# builtin sleep version in bash
 function snore(){
     local IFS
     [[ -n "${_snore_fd:-}" ]] || exec {_snore_fd}<> <(:)
     read ${1:+-t "$1"} -u $_snore_fd || :
 }
 
-# required awk, bc
-function findJPGPath(){
-    if [ -z "$1" ] || [ -z "$2" ]; then
-        echo ""
-        return 1
-    fi
-    local iconJPG="${2}.jpg"
+# helper find normal icon fullname file path
+function findNrmIconHelper(){
+    [ -z "$1" ] && echo "" && return 1
+    [ -z "$2" ] && echo "" && return 1
     cd "${1}"
-    find . -name "${iconJPG}" | grep "16" | cut -c 2- | tail -n 1
+    find . -name "${2}" | grep "svg\|png\|jpg" | cut -c 2- | head -n 1
     return 0
 }
 
-function findPNGPath(){
-    if [ -z "$1" ] || [ -z "$2" ]; then
-        echo ""
-        return 1
-    fi
-    local iconPNG="${2}.png"
+# helper find status icon fullname file path
+function findStatIconHelper(){
+    [ -z "$1" ] && echo "" && return 1
+    [ -z "$2" ] && echo "" && return 1
     cd "${1}"
-    find . -name "${iconPNG}" | grep "16" | cut -c 2- | tail -n 1
+    find . -name "${2}" | grep "svg\|png\|jpg" | grep -i "status" | cut -c 2- | tail -n 1
     return 0
 }
 
+# find jpg icon fullname file path
+function findJPGPath(){
+    findNrmIconHelper "$1" "${2}.jpg" | grep "16"
+    return 0
+}
+
+# find png icon fullname file path
+function findPNGPath(){
+    findNrmIconHelper "$1" "${2}.png" | grep "16"
+    return 0
+}
+
+# find svg icon fullname file path
 function findSVGPath(){
-    if [ -z "$1" ] || [ -z "$2" ]; then
-        echo ""
-        return 1
-    fi
-    local iconSVG="${2}.svg"
-    cd "${1}"
-    find . -name "${iconSVG}" | cut -c 2- | tail -n 1
+    findNrmIconHelper "$1" "${2}.svg"
     return 0
 }
 
+# find current icon theme name
 function findIconThemeName(){
     local tn=""
-    tn=$(gsettings get org.mate.interface icon-theme | tr -d "'")
-    [ -z "$tn" ] && tn=$(gsettings get org.gnome.desktop.interface icon-theme | tr -d "'")
+    hash dump_xsettings && tn="$(dump_xsettings | grep "Net\/IconThemeName" | awk '{print $2}' | tr -d '"')"
+    [ -z "$tn" ] && tn="$(gsettings get org.mate.interface icon-theme | tr -d "'")"
+    [ -z "$tn" ] && tn="$(gsettings get org.gnome.desktop.interface icon-theme | tr -d "'")"
     echo "$tn"
     return 0
 }
 
+# find current icon theme path for search
 function findIconThemePath(){
-    if [ -z "$1" ]; then
-        echo ""
-        return 1
-    fi
+    [ -z "$1" ] && echo "" && return 1
     local tn="$1"
-    local tp=""
-    tp="/usr/share/icons/$tn"
-    
-    if [ -d "$tp" ]; then
-        echo "$tp"
-        return 0
-    else
-        tp="$HOME/.icons/$tn"
-        if [ -d "$tp" ]; then
-            echo "$tp"
-            return 0
-        fi
-    fi
+    local tp="/usr/share/icons/$tn"
+    [ -d "$tp" ] && echo "$tp" && return 0
+    tp="$HOME/.icons/$tn"
+    [ -d "$tp" ] && echo "$tp" && return 0
     echo ""
     return 1
 }
 
+# find icon path inside current icon theme
 function FindIconPath(){
     if [ -z "$1" ] || [ -z "$2" ]; then
         echo ""
         return 1
     fi
-    
     local tp="$2"
-    local nip=""
-    
-    nip=$(findSVGPath "$tp" "${1}")
-    [ -z "$nip" ] && nip=$(findPNGPath "$tp" "${1}")
-    [ -z "$nip" ] && nip=$(findJPGPath "$tp" "${1}")
-    if [ -z "$nip" ]; then
-        echo ""
-        return 1
-    fi
-    
+    local nip=$(findNrmIconHelper "$tp" "${1}.svg" )
+    [ -z "$nip" ] && nip=$(findNrmIconHelper "$tp" "${1}.png" | grep "16")
+    [ -z "$nip" ] && nip=$(findNrmIconHelper "$tp" "${1}.jpg" | grep "16")
+    [ -z "$nip" ] && echo "" && return 1
     echo "$tp$nip"
     return 0
 }
 
+# find icon path on fallback conditions
 function FallbackiconPath(){
     if [ -z "$1" ] || [ -z "$2" ]; then
         echo ""
         return 1
     fi
     
-    local tp="$2"
-    local seaDirs=( $(grep "nherit" "$tp/index.theme" | cut -d"=" -f2 | xargs -d ",") )
+    local sdirs=( $(grep "nherit" "$2/index.theme" | cut -d"=" -f2 | xargs -d ",") )
     local tp=""
-    local iconPath=""
+    local nip=""
     
-    for i in "${seaDirs[@]}"; do
+    for i in "${sdirs[@]}"; do
         tp=$(findIconThemePath "$i");
-        iconPath=$(FindIconPath "$1" "$tp");
+        nip=$(FindIconPath "$1" "$tp");
         #echo "o i = $i e o tp = $tp e o iconName=$1  e o iconPath = $iconPath"
-        if [ ! -z "$iconPath" ]; then
-            echo "$iconPath"
-            return 0
-        fi
+        [ ! -z "$nip" ] && echo "$nip" && return 0
     done
     echo ""
     return 1
 }
 
+# find icon path 
 function iconPath(){
-    if [ -z "$1" ]; then
-        echo ""
-        return 1
-    fi
-    
-    local themePath=""
-    local iconPath=""
-    local themeName=""
-    
-    themeName=$(findIconThemeName)
-    themePath=$(findIconThemePath "$themeName")
-    
-    if [ -z "$themePath" ]; then
-        echo ""
-        return 1
-    fi
-    
-    iconPath=$(FindIconPath "$1" "$themePath");
-    
-    if [ -z "$iconPath" ]; then
-        iconPath=$(FallbackiconPath "$1" "$themePath")
-        if [ -z "$iconPath" ]; then
-            echo ""
-            return 1
-        fi
-    fi
-    
+    [ -z "$1" ] && echo "" && return 1
+    local themePath="$(findIconThemePath "$(findIconThemeName)")"
+    [ -z "$themePath" ] && echo "" && return 1
+    local iconPath="$(FindIconPath "$1" "$themePath")"
+    [ -z "$iconPath" ] && iconPath=$(FallbackiconPath "$1" "$themePath")
     echo "$iconPath"
     return 0
 }
-
diff --git a/bin/mycursor b/bin/mycursor
index be59c4f2..e1e57d4a 100755
--- a/bin/mycursor
+++ b/bin/mycursor
@@ -38,17 +38,25 @@ function do_default_theme(){
     fi
 }
 
-cmd=${1:-empty}
+function main(){
+    precheck "gsettings" 
+    precheck "update-alternatives"
+    precheck "sudo"
 
-[ -z "$2" ] && exit 1;
+    local cmd=${1:-empty}
+    
+    [ -z "$2" ] && exit 1;
+    
+    case "$cmd" in
+        default)
+            do_default_theme $2
+        ;;
+        install)
+            do_install_theme $2
+        ;;
+        *)
+            log "Unrecognized option: $1"
+    esac
+}
 
-case "$cmd" in
-    default)
-        do_default_theme $2
-    ;;
-    install)
-        do_install_theme $2
-    ;;
-    *)
-        log "Unrecognized option: $1"
-esac
+main "$@"
\ No newline at end of file
diff --git a/bin/myedit b/bin/myedit
index 098ebc25..94ed0492 100755
--- a/bin/myedit
+++ b/bin/myedit
@@ -5,86 +5,58 @@ if [ -f "$HOME/bin/mycommon" ]; then
     . "$HOME/bin/mycommon"
 fi
 
-XedtApps=('subl' 'subl3' 'sublime-text' 'geany' 'xed' 'gedit' 'pluma' 'leafpad' 'atom' 'vscode')
+function _fX(){
+    # list by priority from the left to the right
+    local Xl=('subl' 'subl3' 'sublime-text' 'geany' 'xed' 'gedit' 'pluma' 'kate' 'kwrite' 'medit' 'leafpad' 'atom' 'vscode' 'eclipse' 'brackets' 'gvim')
+    local r=""
+    for i in "${Xl[@]}"; do
+        r=$(command -v "${i}")
+        [ -n "$r" ] && echo "$r" && return 0
+    done
+    [ $(hash xdg-open) ] && echo "$(command -v xdg-open)" && return 0
+    echo ""
+    return 1
+}
 
-function has_editor(){
-    local tmp="$(command -v $1)"
-    echo "$tmp"
-    [ -z "$tmp" ] && return 1 || return 0
+function _fnoX(){
+    # list by priority from the left to the right
+    local noXl=('nano' 'pico' 'jed' 'joe' 'mcedit' 'micro' 'vim' 'neovim' 'vi' 'kakoune' 'emacs')
+    local r=""
+    for i in "${noXl[@]}"; do
+        r=$(command -v "${i}")
+        [ -n "$r" ] && echo "$r" && return 0
+    done
+    echo ""
+    return 1
 }
 
-function do_edit() {
+function main() {
+    [ -z "$1" ] && log "No target informed" && return 1
     local edt=""
-    
     if is_running_X ; then
-        for i in "${XedtApps[@]}"; do
-            edt=$(has_editor "${i}")
+        if [ "$2" = "cli" ]; then
+            edt="$(_fnoX)"
             if [ -n "$edt" ]; then
-                $edt "$1"
+                x-terminal-emulator -e $edt "$1" &
+                disown
                 return 0
             fi
-        done
-    else
-        edt=$(has_editor "nano")
+        fi
+        edt="$(_fX)"
         if [ -n "$edt" ]; then
-            $edt "$1"
+            $edt "$1" &
+            disown
             return 0
         fi
-    fi
-    
-    if [ -z "$edt" ]; then
-        log "no editors found"
-    fi
-    
-    return 0
-}
-
-function do_test() {
-    local edt=""
-    
-    if [ ! -z "$1" ]; then
-        log "target is $1"
-    else
-        log "no target found"
-    fi
-    
-    if is_running_X ; then
-        log "X is running"
     else
-        log "X server down"
-    fi
-    
-    for i in "${XedtApps[@]}"; do
-        edt=$(has_editor "$i")
+        edt=$(_fnoX)
         if [ -n "$edt" ]; then
-            log "$i present @ $edt"
-        else
-            log "$i not found"
+            $edt "$1"
+            return 0
         fi
-    done
-    
-    edt=$(has_editor "nano")
-   
-    if [ -n "$edt" ]; then
-        log "nano present @ $edt"
-    else
-        log "nano not found"
     fi
-    
+    [ -z "$edt" ] && log "no editors found"
     return 0
 }
 
-cmd=${2:-edit}
-
-case "$cmd" in
-    edit)
-        do_edit "$1"
-    ;;
-    debug)
-        do_test "$1"
-    ;;
-    *)
-        log "Unrecognized option: $2"
-esac
-
-unset XedtApps
\ No newline at end of file
+main "$@"
\ No newline at end of file
diff --git a/bin/myexit b/bin/myexit
index f631fff3..3e5bd12e 100755
--- a/bin/myexit
+++ b/bin/myexit
@@ -6,54 +6,51 @@ if [ -f "$HOME/bin/mycommon" ]; then
 fi
 
 # Exit wm if possible.
-function do_this_exit() {
+function do_exit(){
     # Only works if X is running.
-    if ! is_running_X ; then
-        log "X server is not running";
-        return 0;
-    fi
-
+    ! is_running_X && log "X server is not running" && return 0
+    
     # Screen must be unlocked first.
     locked && return 0;
     
     dunstctl stop
-
+    
     # Stop this session and daemon running processes.
-    stop_it "polkit-gnome-authentication-agent-1" "stop"
-    stop_it "gnome-keyring-daemon" "stop"
-    stop_it "gnome-settings-daemon" "stop"
-    stop_it "gnome-screensaver" "stop"
-    stop_it "polkit-mate-authentication-agent-1" "stop"
-    stop_it "mate-settings-daemon" "stop"
-    stop_it "mate-power-manager" "stop"
-    stop_it "mate-volume-control-applet" "stop"
-    stop_it "mate-screensaver" "stop"
-    stop_it "cinnamon-screensaver" "stop"
-    stop_it "xscreensaver" "stop"
-    stop_it "xautolock" "stop"
-    stop_it "redshift-gtk" "stop"
-    stop_it "redshift" "stop"
-    stop_it "mylightson" "stop"
-    stop_it "mywallchng" "stop"
-    stop_it "tint2" "stop"
-    stop_it "compton" "stop"
-
+    stop_it "polkit-gnome-authentication-agent-1"
+    stop_it "gnome-keyring-daemon"
+    stop_it "gnome-settings-daemon"
+    stop_it "gnome-screensaver"
+    stop_it "polkit-mate-authentication-agent-1"
+    stop_it "mate-settings-daemon"
+    stop_it "mate-power-manager"
+    stop_it "mate-volume-control-applet"
+    stop_it "mate-screensaver"
+    stop_it "cinnamon-screensaver"
+    stop_it "xscreensaver"
+    stop_it "xautolock"
+    stop_it "redshift-gtk"
+    stop_it "redshift"
+    stop_it "mylightson"
+    stop_it "mywallchng"
+    stop_it "tint2"
+    stop_it "compton"
+    
     log "Exiting now..."
     openbox --exit;
-
+    
     killall openbox;
-
+    
     # dbus-launch cleanup
     pkill -u $USER -t `tty | cut -d '/' -f 3,4` dbus-launch
-
+    
     return 0
 }
 
-function do_test() {
+function do_test(){
     is_running_X && log "X is running" || log "X server down"
     locked "debug" && log "Screen already locked" || log "Screen not locked";
     pgrep -f dunst && log "dunst found" || log "dunst not found"
-
+    
     stop_it "polkit-gnome-authentication-agent-1" "debug"
     stop_it "gnome-keyring-daemon" "debug"
     stop_it "gnome-settings-daemon" "debug"
@@ -74,7 +71,7 @@ function do_test() {
     stop_it "mywallchng" "debug"
     stop_it "tint2" "debug"
     stop_it "compton" "debug"
-
+    
     log "Exiting now..."
     log "openbox --exit;"
     log "kilall openbox;"
@@ -83,16 +80,22 @@ function do_test() {
     return 0
 }
 
-
-cmd=${1:-exit}
-
-case "$cmd" in
-    exit)
-        do_this_exit
-        ;;  
-    debug)
-        do_test
+function main(){
+    precheck "xset"
+    precheck "pkill"
+    
+    local cmd=${1:-exit}
+    
+    case "$cmd" in
+        exit)
+            do_exit
+        ;;
+        debug)
+            do_test
         ;;
-    *)
-        log "Unrecognized option: $1"
-esac
+        *)
+            log "Unrecognized option: $1"
+    esac
+}
+
+main "$@"
\ No newline at end of file
diff --git a/bin/myfind b/bin/myfind
index 73bca83a..115cf7ce 100755
--- a/bin/myfind
+++ b/bin/myfind
@@ -1,8 +1,17 @@
 #!/usr/bin/env bash
+#set -eu
 
-if [[ -n $(find . -name ${1} -print0) ]]; then
-    find . -name ${1} -ls ;
-else
-	echo "Arquivo nao encontrado";
+if [ -f "$HOME/bin/mycommon" ]; then
+    . "$HOME/bin/mycommon"
 fi
 
+function main(){
+    [ -z "$1" ] && exit 0
+    if [[ -n $(find . -name "${1}" -print0) ]]; then
+        find . -name "${1}" -ls ;
+    else
+        echo "Arquivo nao encontrado";
+    fi
+}
+
+main "$@"
\ No newline at end of file
diff --git a/bin/mylightson b/bin/mylightson
index 815307a0..6de23c11 100755
--- a/bin/mylightson
+++ b/bin/mylightson
@@ -18,56 +18,57 @@ if [ -f "$HOME/bin/mycommon" ]; then
     . "$HOME/bin/mycommon"
 fi
 
-# DC_DEBUG=0 for NO output
-# DC_DEBUG=1 for sleep prints
-# DC_DEBUG=2 for everything
-DC_DEBUG=0
+# LO_DEBUG=0 for NO output
+# LO_DEBUG=1 for sleep prints
+# LO_DEBUG=2 for everything
+LO_DEBUG=0
 
 # Modify these variables if you want this script to detect if MPV, Mplayer,
 # VLC, Minitube, Totem or a web browser Flash/HTML5 Video.
 
 # Names of programs which, when running, you wish to delay the screensaver.
 # For example ('ardour2' 'gmpc').
-DC_mandatoryApps=('cura' 'wineserver' 'dbgl' 'openscad' 'dgen' 'lutris' 'playonlinux' 'avidemux' 'synaptic' 'scummvm' 'flare' 'frozen-bubble' '0ad' 'TeamViewer' 'remmina' 'dosbox' 'wine')
+LO_mandatoryApps=('cura' 'wineserver' 'dbgl' 'openscad' 'dgen' 'lutris' 'playonlinux' 'avidemux' 'synaptic' 'scummvm' 'flare' 'frozen-bubble' '0ad' 'TeamViewer' 'remmina' 'dosbox' 'wine')
 
 # Names of programs which, when running, you wish to delay the screensaver.
 # For example ('ardour2' 'gmpc').
-DC_delayMediaApps=('vlc' 'celluloid' 'xplayer' 'bino' 'curlew' 'avidemux' 'mpv' 'smplayer' 'smtube' 'gmpc' 'ardour2' 'xine' 'totem' 'parole' 'qmmp' 'kaffeine' 'kmplayer' 'kdenlive' 'ffmpeg')
+LO_delayMediaApps=('vlc' 'celluloid' 'xplayer' 'bino' 'curlew' 'avidemux' 'mpv' 'smplayer' 'smtube' 'gmpc' 'ardour2' 'xine' 'totem' 'parole' 'qmmp' 'kaffeine' 'kmplayer' 'kdenlive' 'ffmpeg')
 
 # Names of programs which, when using sound server, you wish to delay the screensaver.
-DC_delayWebBasedApps=('chrome' 'firefox' 'opera' 'Iceweasel' 'surf' 'yandex_browser' 'luakit' 'WebKit' 'vivaldi' 'brave' 'chromium' 'epiphany' 'youtube-dl' 'smtube' 'midori' 'min' 'falkon' 'slimjet' 'steam')
+LO_delayWebBasedApps=('chrome' 'firefox' 'opera' 'Iceweasel' 'surf' 'yandex_browser' 'luakit' 'WebKit' 'vivaldi' 'brave' 'chromium' 'epiphany' 'youtube-dl' 'smtube' 'midori' 'min' 'falkon' 'slimjet' 'steam')
 
 # Display outputs to check, display screensaver when they are connected.
 # Run xrandr to show current monitor config.
-DC_outputPattern=('HDMI1')
+LO_outputPattern=('HDMI1')
 
 # DPMS settings in seconds, 600 seconds = 10 minutes.
-# If you don't want to change DMPS settings, modify DC_DPMSControl to 0.
-DC_DPMSControl=1
-DC_DPMSStandbyTime=600
-DC_DPMSSuspendTime=600
-DC_DPMSOffTime=600
+# If you don't want to change DMPS settings, modify LO_DPMSControl to 0.
+LO_DPMSControl=1
+LO_DPMSStandbyTime=600
+LO_DPMSSuspendTime=600
+LO_DPMSOffTime=600
 
 # X11 Screen Saver Extension settings in seconds, 600 seconds = 10 minutes.
-# If you don't want to change these settings, modify DC_X11ScrSvrControl to 0.
-DC_X11ScrSvrControl=1
-DC_X11ScrSvrTimeout=600
+# If you don't want to change these settings, modify LO_X11ScrSvrControl to 0.
+LO_X11ScrSvrControl=1
+LO_X11ScrSvrTimeout=600
+
 
 # clean status file
-function DC_state_clean() {
-    if [ -f "$DC_stateFile" ]; then
-        rm -f "$DC_stateFile"
+function LO_state_clean() {
+    if [ -f "$LO_stateFile" ]; then
+        rm -f "$LO_stateFile"
     fi
     return 0
 }
 
-# DC_log feature
-function DC_log() {
-    if [ $DC_DEBUG -eq 2 ]; then
+# LO_log feature
+function LO_log() {
+    if [ $LO_DEBUG -eq 2 ]; then
         echo "$@"
         log "$@" 
-    elif [ $DC_DEBUG -eq 1 ]; then
-        if [ "$(echo "$@" | grep -c 'sleeping for')" == "1" ]; then
+    elif [ $LO_DEBUG -eq 1 ]; then
+        if [ "$(echo "$@" | grep -c 'sleeping for')" -eq 1 ]; then
             echo "$@"
             log "$@"
         fi
@@ -75,88 +76,54 @@ function DC_log() {
 }
 
 # save current state
-function DC_save_state() {
+function LO_save_state() {
     local st="$1"
-    echo "$st" > "$DC_stateFile"
+    echo "$st" > "$LO_stateFile"
 }
 
 # enable dpms
-function DC_enable_dpms() {
-    # NOTE the timeouts are set by laptop-mode.
+# NOTE the timeouts are set by laptop-mode.
+function LO_enable_dpms() {
     xset +dpms
-    DC_log "DC_enable_dpms(): DPMS ENABLED"
+    LO_log "LO_enable_dpms(): DPMS ENABLED"
 }
 
 # disable dpms
-function DC_disable_dpms() {
+function LO_disable_dpms() {
     xset -dpms
-    DC_log "DC_disable_dpms(): DPMS DISABLED"
+    LO_log "LO_disable_dpms(): DPMS DISABLED"
 }
 
 # query state
-function DC_read_state() {
-    if [ -f "$DC_stateFile" ]; then
-         awk '{ print $0 }' "$DC_stateFile"
+function LO_read_state() {
+    if [ -f "$LO_stateFile" ]; then
+         awk '{ print $0 }' "$LO_stateFile"
     else
         echo "ENABLED"
     fi
 }
 
 # Turn X11 Xset to on 
-function DC_XSetOn() {
-    X11XsetStatus=$(xset q | grep timeout | sed "s/cycle.*$//" | tr -cd '[:digit:]')
-    if [ $X11XsetStatus -eq 0 ]; then
-        DC_log "DC_XSetOn(): X11 Screensaver Extension ENABLED"
+function LO_XSetOn() {
+    if [ $(xset q | grep timeout | sed "s/cycle.*$//" | tr -cd '[:digit:]') -eq 0 ]; then
+        LO_log "LO_XSetOn(): X11 Screensaver Extension ENABLED"
         xset s on
     fi
 }
 
 # Turn X11 Xset to off 
-function DC_XSetOff() {
-    X11XsetStatus=$(xset q | grep timeout | sed "s/cycle.*$//" | tr -cd '[:digit:]')
-    if [ $X11XsetStatus -ge 1 ]; then
-        DC_log "DC_XSetOff(): X11 Screensaver Extension DISABLED"
+function LO_XSetOff() {
+    if [ $(xset q | grep timeout | sed "s/cycle.*$//" | tr -cd '[:digit:]') -ge 1 ]; then
+        LO_log "LO_XSetOff(): X11 Screensaver Extension DISABLED"
         xset s off
     fi
 }
 
-# disable xautolock + Xset + dpms off
-function DC_disableXautolock() {
-    if [ "$(DC_whichScrSvrRunning)" = "xautolock" ]; then
-        xautolock -disable
-        if [ "$1" == "force" ]; then
-            DC_log "DC_disableXautolock(): Shutting down xautolock daemon..."
-            while 2>/dev/null killall xautolock; do
-                snore 1
-            done
-        fi
-    fi
-    DC_disable_dpms
-    DC_XSetOff
-}
-
-# enable xautolock + Xset + dpms on
-function DC_enableXautolock() {
-    if [ "$1" == "force" ]; then
-        if [ "$(DC_whichScrSvrRunning)" = "xautolock" ]; then
-            # remove obsolete processes
-            while 2>/dev/null killall xautolock; do
-                snore 1
-            done
-        fi
-        DC_log "DC_enableXautolock(): Restarting xautolock daemon..."
-        xautolock -detectsleep -noclose -time 5 -locker "\"$HOME/bin/mylock\"" -notify 10 -notifier "\"$HOME/bin/mynotify\"" -killtime 10 -killer "\"$HOME/bin/mysuspend\"" &
-    fi
-    xautolock -enable
-    DC_enable_dpms
-    DC_XSetOn
-}
-
 # Find mandatory apps in fullscreen mode
-function DC_hasMandatoryDelay() {
-    for p1 in "${DC_mandatoryApps[@]}"; do
+function LO_hasMandatoryDelay() {
+    for p1 in "${LO_mandatoryApps[@]}"; do
         if [ $(pgrep -lfc "${p1}") -gt 0 ] ; then
-            DC_log "DC_hasMandatoryDelay(): mandatory delay program $p1 found..."
+            LO_log "LO_hasMandatoryDelay(): mandatory delay program $p1 found..."
             return 0
         fi
     done
@@ -164,66 +131,45 @@ function DC_hasMandatoryDelay() {
 }
 
 # Find a screensaver process running
-function DC_whichScrSvrRunning() {
-    if [ $DC_xautolockPresent -eq 1 ]; then
-        [ $(pgrep -lfc xautolock) -gt 0 ] && echo "xautolock"
-        return 0
-    fi
-    if [ $DC_gnomeScrSvrPresent -eq 1 ]; then
-        [ $(pgrep -lfc gnome-screensaver) -gt 0 ] && echo "gnome-screensaver"
-        return 0
-    fi
-    if [ $DC_mateScrSvrPresent -eq 1 ]; then
-        [ $(pgrep -lfc mate-screensaver) -gt 0 ] && echo "mate-screensaver"
-        return 0
-    fi
-    if [ $DC_cinnamonScrSvrPresent -eq 1 ]; then
-        [ $(pgrep -lfc cinnamon-screensaver) -gt 0 ] && echo "cinnamon-screensaver"
-        return 0
-    fi
-    if [ $DC_xScrSvrPresent -eq 1 ]; then
-        [ $(pgrep -lfc xscreensaver) -gt 0 ] && echo "xscreensaver"
-        return 0
-    fi
-    if [ $DC_xdgScrSvrPresent -eq 1 ]; then
-        [ $(pgrep -lfc xdg-screensaver) -gt 0 ] && echo "xdg-screensaver"
-        return 0
-    fi
+function LO_whichScrSvrRunning() {
+    [ $(pgrep -lfc xautolock) -gt 0 ] && echo "xautolock" && return 0
+    [ $(pgrep -lfc gnome-screensaver) -gt 0 ] && echo "gnome-screensaver" && return 0
+    [ $(pgrep -lfc mate-screensaver) -gt 0 ] && echo "mate-screensaver" && return 0
+    [ $(pgrep -lfc cinnamon-screensaver) -gt 0 ] && echo "cinnamon-screensaver" && return 0
+    [ $(pgrep -lfc xscreensaver) -gt 0 ] && echo "xscreensaver" && return 0
+    [ $(pgrep -lfc xdg-screensaver) -gt 0 ] && echo "xdg-screensaver" && return 0
     echo ""
     return 0
 }
 
 # Detect if soundcard is being used
-function DC_isSndCardBeingUsed() {
+function LO_isSndCardBeingUsed() {
     if grep RUNNING /proc/asound/card*/pcm*/sub*/status > /dev/null; then
-        DC_log "DC_isSndCardBeingUsed(): YES"
+        LO_log "LO_isSndCardBeingUsed(): YES"
         return 0
     else
-        DC_log "DC_isSndCardBeingUsed(): NO"
+        LO_log "LO_isSndCardBeingUsed(): NO"
         return 1
     fi
 }
 
 # find a delay program using pulseaudio
-function DC_whichUsingPulseaudio() {
+function LO_whichUsingPulseaudio() {
     local nm_ps=""
     local str=""
     str=$(pacmd list-sink-inputs | grep "application.process.id" | awk '{print $3}' | sed 's/\"//g' | sed 's/\n//g')
-    if [ -z "$str" ]; then 
-        echo "$nm_ps" 
-        return 0
-    fi
+    [ -z "$str" ] && echo "$nm_ps" && return 0
     local arr=( $str )
     for i in "${arr[@]}"; do 
         nm_ps=$(ps -p "$i" -o comm=;)
-        for p1 in "${DC_delayMediaApps[@]}"; do
-            if [ "$p1" = "$nm_ps" ] ; then
+        for p1 in "${LO_delayMediaApps[@]}"; do
+            if [ "$p1" = "$nm_ps" ]; then
                 echo "$nm_ps"
                 return 0
             fi
         done
-        for p2 in "${DC_delayWebBasedApps[@]}"; do
-            if [ "$p2" = "$nm_ps" ] ; then
+        for p2 in "${LO_delayWebBasedApps[@]}"; do
+            if [ "$p2" = "$nm_ps" ]; then
                 echo "$nm_ps"
                 return 0
             fi
@@ -234,22 +180,22 @@ function DC_whichUsingPulseaudio() {
 }
 
 # find a running online stream
-function DC_detectOnlineMedia() {
+function LO_detectOnlineMedia() {
     local tmp=""
-    tmp=$(wmctrl -lx 2> /dev/null | grep -si "youtube\|stream\|mp4\|mpeg\|mpg\|webm\|vimeo\|anime\|divX\|flix\|rackle\|odcast\|cecast\|cine\|muu\|movie")
+    tmp=$(wmctrl -lx 2> /dev/null | grep -si "youtube\|stream\|mp4\|mpeg\|mkv\|mpg\|webm\|vimeo\|anime\|divX\|flix\|rackle\|odcast\|cecast\|cine\|muu\|movie")
     if [ $? -eq 0 ] ; then 
-        DC_log "DC_detectOnlineMedia(): $tmp"
+        LO_log "LO_detectOnlineMedia(): $tmp"
         return 0
     fi
     return 1
 }
 
 # find a running online stream
-function DC_fullScrWinID() {
+function LO_fullScrWinID() {
     local oldIFS=$IFS
     IFS=$'\n'
     # Loop through every display looking for a fullscreen window.
-    for display in $DC_displays; do
+    for display in $LO_displays; do
         local allWinID=""
         allWinID=$(DISPLAY=:${display} wmctrl -l | awk '{print $1}')
         for oneWinID in $allWinID; do
@@ -267,11 +213,11 @@ function DC_fullScrWinID() {
 }
 
 # find a running online stream
-function DC_scrAboveWinID() {
+function LO_scrAboveWinID() {
     local oldIFS=$IFS
     IFS=$'\n'
     # Loop through every display looking for a above window.
-    for display in $DC_displays; do
+    for display in $LO_displays; do
         local allWinID=""
         allWinID=$(DISPLAY=:${display} wmctrl -l | awk '{print $1}')
         for oneWinID in $allWinID; do
@@ -289,8 +235,8 @@ function DC_scrAboveWinID() {
 }
 
 # Check if active window is matched with user settings.
-# This function covers the standard way to check apps in DC_hasDelayApp
-function DC_runcheck() {
+# This function covers the standard way to check apps in LO_hasDelayApp
+function LO_runcheck() {
     if [[ "$1" = *$2* ]]; then
         if [ "$(pidof -s "$2")" ]; then
             return 0
@@ -300,25 +246,23 @@ function DC_runcheck() {
 }
 
 # find a delay program for a given window ID
-function DC_hasDelayApp() {
+function LO_hasDelayApp() {
     # active window ID must be passed as parameter
     if [ -z "$1" ]; then
-        DC_log "DC_hasDelayApp(): Active Win ID parameter needed"
+        LO_log "LO_hasDelayApp(): Active Win ID parameter needed"
         return 1
     else
         local winID=$1
     fi
     # Get title of active window.
-    local activWinTitle=""
-    activWinTitle=$(xprop -id "$winID" 2> /dev/null | grep "WM_CLASS(STRING)")
-    
+    local activWinTitle="$(xprop -id "$winID" 2> /dev/null | grep "WM_CLASS(STRING)")"
     # Check if user want to detect HTML5 on Chrome.
     if [[ "$activWinTitle" = *oogle-chrome* ]]; then
         # Check if Chrome process is running.
         # chrome_process=`pgrep -lfc "(c|C)hrome --type=gpu-process "
         chrome_process=$(pgrep -lfc "(c|C)hrome")
         if [[ $chrome_process -ge 1 ]]; then
-            DC_log "DC_hasDelayApp(): chrome html5 detected"
+            LO_log "LO_hasDelayApp(): chrome html5 detected"
             return 0
         fi
     fi
@@ -327,7 +271,7 @@ function DC_hasDelayApp() {
     if [[ "$activWinTitle" == *hromium* ]]; then
         # Check if Chromium process is running.
         if [[ $(pgrep -lfc "chromium") -ge 1 ]]; then
-            DC_log "DC_hasDelayApp(): chromium html5 detected"
+            LO_log "LO_hasDelayApp(): chromium html5 detected"
             return 0
         fi
     fi
@@ -336,15 +280,15 @@ function DC_hasDelayApp() {
     if [[ "$activWinTitle" == *andex-browser* ]]; then
         # Check if Yandex browser process is running.
         if [[ $(pgrep -lfc "yandex_browser") -ge 1 ]]; then
-            DC_log "DC_hasDelayApp(): Yandex browser detected"
+            LO_log "LO_hasDelayApp(): Yandex browser detected"
             return 0
         fi
     fi
     
     # detect browsers that need delay screensaver
-    for wapp in "${DC_delayWebBasedApps[@]}"; do
-        if DC_runcheck "$activWinTitle" "$wapp" ; then
-            DC_log "DC_hasDelayApp(): $wapp detected"
+    for wapp in "${LO_delayWebBasedApps[@]}"; do
+        if LO_runcheck "$activWinTitle" "$wapp" ; then
+            LO_log "LO_hasDelayApp(): $wapp detected"
             return 0
         fi
     done
@@ -353,7 +297,7 @@ function DC_hasDelayApp() {
     if [[ "$activWinTitle" = *unknown* || "$activWinTitle" = *plugin-container* ]]; then
         # Check if plugin-container process is running.
         if [ "$(pidof -s plugin-container)" ]; then
-            DC_log "DC_hasDelayApp(): firefox flash detected"
+            LO_log "LO_hasDelayApp(): firefox flash detected"
             return 0
         fi
     fi
@@ -362,7 +306,7 @@ function DC_hasDelayApp() {
         # Check if Chromium Flash process is running.
         flash_process=$(pgrep -lfc ".*chromium.*flashp.*")
         if [[ $flash_process -ge 1 ]]; then
-            DC_log "DC_hasDelayApp(): chromium flash detected"
+            LO_log "LO_hasDelayApp(): chromium flash detected"
             return 0
         fi
     fi
@@ -371,7 +315,7 @@ function DC_hasDelayApp() {
         # Check if Chromium pepper Flash process is running.
         chromium_process=$(pgrep -lfc "chromium(|-browser) --type=ppapi ")
         if [[ $chromium_process -ge 1 ]]; then
-            DC_log "DC_hasDelayApp(): chromium pepper flash detected"
+            LO_log "LO_hasDelayApp(): chromium pepper flash detected"
             return 0
         fi
     fi
@@ -380,7 +324,7 @@ function DC_hasDelayApp() {
         # Check if Chrome pepper Flash process is running.
         chrome_process=$(pgrep -lfc "(c|C)hrome --type=ppapi ")
         if [[ $chrome_process -ge 1 ]]; then
-            DC_log "DC_hasDelayApp(): chrome flash detected"
+            LO_log "LO_hasDelayApp(): chrome flash detected"
             return 0
         fi
     fi
@@ -389,7 +333,7 @@ function DC_hasDelayApp() {
         # Check if Opera flash process is running.
         flash_process=$(pgrep -lfc operapluginwrapper-native)
         if [[ $flash_process -ge 1 ]]; then
-            DC_log "DC_hasDelayApp(): opera flash detected"
+            LO_log "LO_hasDelayApp(): opera flash detected"
             return 0
         fi
     fi
@@ -398,7 +342,7 @@ function DC_hasDelayApp() {
         # Check if WebKit Flash process is running.
         flash_process=$(pgrep -lfc ".*WebKitPluginProcess.*flashp.*")
         if [[ $flash_process -ge 1 ]]; then
-            DC_log "DC_hasDelayApp(): webkit flash detected"
+            LO_log "LO_hasDelayApp(): webkit flash detected"
             return 0
         fi
     fi
@@ -406,34 +350,34 @@ function DC_hasDelayApp() {
     if [[ "$activWinTitle" = *mplayer* || "$activWinTitle" = *MPlayer* ]]; then
         # Check if MPlayer is running.
         if [ "$(pidof -s mplayer)" ]; then
-            DC_log "DC_hasDelayApp(): mplayer detected"
+            LO_log "LO_hasDelayApp(): mplayer detected"
             return 0
         fi
     fi
 
     # detect programs that need delay screensaver
-    for prog in "${DC_delayMediaApps[@]}"; do
-        if DC_runcheck "$activWinTitle" "$prog" ; then
-            DC_log "DC_hasDelayApp(): $prog fullscreen detected"
+    for prog in "${LO_delayMediaApps[@]}"; do
+        if LO_runcheck "$activWinTitle" "$prog" ; then
+            LO_log "LO_hasDelayApp(): $prog fullscreen detected"
             return 0
         fi
     done
 
-    DC_log "DC_hasDelayApp(): NO application fullscreen detected"
+    LO_log "LO_hasDelayApp(): NO application fullscreen detected"
     return 1
 }
 
 # check for fullscreen or above screen that set to trigger the delay
-function DC_isFullScreenBeingUsed() {
+function LO_isFullScreenBeingUsed() {
     local activWinFullscreenID=""
     local activeWinID=""
     local activWinAboveID=""
-    activWinFullscreenID=$(DC_fullScrWinID)
+    activWinFullscreenID=$(LO_fullScrWinID)
     if [ -z "$activWinFullscreenID" ]; then
-        DC_log "DC_isFullScreenBeingUsed(): NO fullscreen detected"
-        activWinAboveID=$(DC_scrAboveWinID)
+        LO_log "LO_isFullScreenBeingUsed(): NO fullscreen detected"
+        activWinAboveID=$(LO_scrAboveWinID)
         if [ -z "$activWinAboveID" ]; then 
-            DC_log "DC_isFullScreenBeingUsed(): NO above screen detected"
+            LO_log "LO_isFullScreenBeingUsed(): NO above screen detected"
             return 1
         else
             activeWinID=$activWinAboveID
@@ -444,23 +388,23 @@ function DC_isFullScreenBeingUsed() {
     
     # Above state is used in some window managers instead of fullscreen.
     # if we reach this part at least one window id was found
-    DC_log "DC_isFullScreenBeingUsed(): active Win ID=$activeWinID"
+    LO_log "LO_isFullScreenBeingUsed(): active Win ID=$activeWinID"
     
-    if DC_detectOnlineMedia; then 
-        DC_log "DC_isFullScreenBeingUsed(): Fullscreen detected: streaming is running..."
+    if LO_detectOnlineMedia; then 
+        LO_log "LO_isFullScreenBeingUsed(): Fullscreen detected: streaming is running..."
         return 0
     fi
-    if DC_hasDelayApp "$activeWinID"; then 
-        DC_log "DC_isFullScreenBeingUsed(): Fullscreen detected: the app is set to trigger the delay"
+    if LO_hasDelayApp "$activeWinID"; then 
+        LO_log "LO_isFullScreenBeingUsed(): Fullscreen detected: the app is set to trigger the delay"
         return 0
     fi
     
-    DC_log "DC_isFullScreenBeingUsed(): Fullscreen detected: the app is UNKNOWN or NOT set to trigger the delay"
+    LO_log "LO_isFullScreenBeingUsed(): Fullscreen detected: the app is UNKNOWN or NOT set to trigger the delay"
     return 1
 }
 
 #check for output connections to disable xautolock and reset screensaver
-function DC_hasDelayOutputConns() {
+function LO_hasDelayOutputConns() {
     local oldIFS=$IFS
     local output=""
     declare -A connOutput
@@ -474,7 +418,7 @@ function DC_hasDelayOutputConns() {
         fi
     done < <(xrandr | sed -rn "s/^([^ ]+)[ ]+((dis)?connected)[ ]+(primary)?[ ]*([0-9]+x[0-9]+\+[0-9]+\+[0-9]+)?[ ]*.+$/output=\1\nconnected=\2\nignore=\3\nprimary=\4\nresolution=\5/p")
     IFS=$oldIFS
-    for out in "${DC_outputPattern[@]}" ; do
+    for out in "${LO_outputPattern[@]}" ; do
         if [[ ${connOutput["$out"]} = "connected" ]]; then
             echo "$out"
             unset connOutput
@@ -486,401 +430,370 @@ function DC_hasDelayOutputConns() {
     return 1
 }
 
-# disable xautolock
-function DC_disableScrXautolock() {
-    local stt=""
-    stt=$(DC_read_state)
-    
+# disable xautolock + Xset + dpms off
+function LO_disableScrXautolock() {
+    if [ "$(LO_read_state)" == "DISABLED" ]; then
+        LO_log "LO_disableScrXautolock(): xautolock screensaver already DISABLED..."
+        return 0
+    fi
     if [ "${1}" == "force" ]; then
-        DC_disableXautolock "${1}"
-        DC_log "DC_disableScrXautolock(): xautolock screensaver disable force option..."
+        LO_log "LO_disableXautolock(): Shutting down xautolock daemon..."
+        stop_it "xautolock"
     else
-        if [ "$stt" == "DISABLED" ]; then
-            DC_log "DC_disableScrXautolock(): xautolock screensaver already DISABLED..."
-            return 0
-        else
-            DC_disableXautolock
-            DC_log "DC_disableScrXautolock(): delaying xautolock..."
-        fi
+        LO_log "LO_disableScrXautolock(): delaying xautolock..."
+        [ "$LO_screenSaverProgram" = "xautolock" ] && xautolock -disable
     fi
-
-    DC_save_state "DISABLED"
+    LO_disable_dpms
+    LO_XSetOff
+    LO_save_state "DISABLED"
 }
 
-# enable xautolock 
-function DC_enableScrXautolock() {
-    local stt=""
-    stt=$(DC_read_state)
+# enable xautolock + Xset + dpms on
+function LO_enableScrXautolock() {
+    if [ "$(LO_read_state)" == "ENABLED" ] && [ "${1}" != "force" ]; then
+        LO_log "LO_enableScrXautolock(): xautolock screensaver already ENABLED..."
+        return 0
+    fi
     
     if [ "${1}" == "force" ]; then
-        DC_enableXautolock "${1}"
-        DC_log "DC_enableScrXautolock(): xautolock screensaver enable force option..."
+        stop_it "xautolock"
+        LO_log "LO_enableScrXautolock(): (Re)/Starting xautolock daemon..."
+        xautolock -detectsleep -noclose -time 5 -locker "\"$HOME/bin/mylock\"" -notify 10 -notifier "\"$HOME/bin/mynotify\"" -killtime 10 -killer "\"$HOME/bin/mysuspend\"" &
+        snore 0.5
     else
-        if [ "$stt" == "ENABLED" ]; then
-            DC_log "DC_enableScrXautolock(): xautolock screensaver already ENABLED..."
-            return 0
-        else
-            DC_enableXautolock
-            DC_log "DC_enableScrXautolock(): xautolock ENABLED..."
-        fi
+        xautolock -enable
+        LO_log "LO_enableScrXautolock(): xautolock ENABLED..."
     fi
     
+    LO_enable_dpms
+    LO_XSetOn
+
     # Setting DPMS.
-    if [ $DC_DPMSControl -eq 1 ]; then
-        DC_log "DC_enableScrXautolock(): DC_enableScrXautolock(): Setting DPMS Standby Time: $DC_DPMSStandbyTime, Suspend: $DC_DPMSSuspendTime, Off: $DC_DPMSOffTime"
-        xset dpms $DC_DPMSStandbyTime $DC_DPMSSuspendTime $DC_DPMSOffTime
+    if [ $LO_DPMSControl -eq 1 ]; then
+        LO_log "LO_enableScrXautolock(): LO_enableScrXautolock(): Setting DPMS Standby Time: $LO_DPMSStandbyTime, Suspend: $LO_DPMSSuspendTime, Off: $LO_DPMSOffTime"
+        xset dpms $LO_DPMSStandbyTime $LO_DPMSSuspendTime $LO_DPMSOffTime
     fi
     
     # Setting X11 Scrensaver Extension.
-    if [ $DC_X11ScrSvrControl -eq 1 ]; then
-        DC_log "DC_enableScrXautolock(): Setting X11 Scrensaver Extension to Timeout: $DC_X11ScrSvrTimeout"
-        xset s $DC_X11ScrSvrTimeout
+    if [ $LO_X11ScrSvrControl -eq 1 ]; then
+        LO_log "LO_enableScrXautolock(): Setting X11 Scrensaver Extension to Timeout: $LO_X11ScrSvrTimeout"
+        xset s $LO_X11ScrSvrTimeout
     fi
 
-    DC_save_state "ENABLED"
+    LO_save_state "ENABLED"
 }
 
 # delay/disable other than xautolock
-function DC_disableScrSvrOther() {
+function LO_disableScrSvrOther() {
     # Reset inactivity time counter so screensaver is not started.
-    if [ "$DC_screenSaverProgram" == "xscreensaver" ]; then
-        DC_log "DC_disableScrSvrOther(): delaying xscreensaver..."
+    if [ "$LO_screenSaverProgram" == "xscreensaver" ]; then
+        LO_log "LO_disableScrSvrOther(): delaying xscreensaver..."
         xscreensaver-command -deactivate > /dev/null
-    elif [ "$DC_screenSaverProgram" == "kscreensaver" ]; then
-        DC_log "DC_disableScrSvrOther(): delaying kscreensaver..."
+    elif [ "$LO_screenSaverProgram" == "kscreensaver" ]; then
+        LO_log "LO_disableScrSvrOther(): delaying kscreensaver..."
         qdbus org.freedesktop.ScreenSaver /ScreenSaver SimulateUserActivity > /dev/null
-    elif [ "$DC_screenSaverProgram" == "gnome-screensaver" ]; then
-        DC_log "DC_disableScrSvrOther(): delaying gnome-screensaver..."
+    elif [ "$LO_screenSaverProgram" == "gnome-screensaver" ]; then
+        LO_log "LO_disableScrSvrOther(): delaying gnome-screensaver..."
         dbus-send --session --dest=org.gnome.ScreenSaver --type=method_call /org/gnome/ScreenSaver org.gnome.ScreenSaver.SimulateUserActivity >/dev/null 2>&1
-    elif [ "$DC_screenSaverProgram" == "cinnamon-screensaver" ]; then
-        DC_log "DC_disableScrSvrOther(): delaying cinnamon-screensaver..."
+    elif [ "$LO_screenSaverProgram" == "cinnamon-screensaver" ]; then
+        LO_log "LO_disableScrSvrOther(): delaying cinnamon-screensaver..."
         dbus-send --session --dest=org.cinnamon.ScreenSaver --type=method_call /org/cinnamon/ScreenSaver org.cinnamon.ScreenSaver.SimulateUserActivity >/dev/null 2>&1
-    elif [ "$DC_screenSaverProgram" == "mate-screensaver" ]; then
-        DC_log "DC_disableScrSvrOther(): delaying mate-screensaver..."
+    elif [ "$LO_screenSaverProgram" == "mate-screensaver" ]; then
+        LO_log "LO_disableScrSvrOther(): delaying mate-screensaver..."
         dbus-send --session --dest=org.mate.ScreenSaver --type=method_call /org/mate/ScreenSaver org.mate.ScreenSaver.SimulateUserActivity >/dev/null 2>&1
     else
-        if [ $DC_xdgScrSvrPresent -eq 1 ]; then
-            DC_log "DC_disableScrSvrOther(): trying to delay with xdg-screensaver..."
+        if [ $LO_xdgScrSvrPresent -eq 1 ]; then
+            LO_log "LO_disableScrSvrOther(): trying to delay with xdg-screensaver..."
             xdg-screensaver reset
         fi
     fi
 
     local sessionIdleDelay
     # Reset gnome session idle timer.
-    if [[ $DC_gsettingsPresent -eq 1 && $(gsettings get org.gnome.desktop.session idle-delay 2>/dev/null) ]]; then
+    if [[ $LO_gsettingsPresent -eq 1 && $(gsettings get org.gnome.desktop.session idle-delay 2>/dev/null) ]]; then
         sessionIdleDelay=$(gsettings get org.gnome.desktop.session idle-delay 2>/dev/null | sed "s/^.* //")
         if [[ $sessionIdleDelay -ge 1 ]]; then
-            DC_log "DC_disableScrSvrOther(): resetting gnome session..."
+            LO_log "LO_disableScrSvrOther(): resetting gnome session..."
             gsettings set org.gnome.desktop.session idle-delay 0 2>/dev/null
             gsettings set org.gnome.desktop.session idle-delay "$sessionIdleDelay" 2>/dev/null
         fi
     fi
-
-    DC_disable_dpms
-    DC_XSetOff
-    DC_save_state "DISABLED"
+    LO_disable_dpms
+    LO_XSetOff
+    LO_save_state "DISABLED"
 }
 
 # enable other than xautolock
-function DC_enableScrSvrOther() {
+function LO_enableScrSvrOther() {
     # Reset inactivity time counter so screensaver is not started.
-    if [ "$DC_screenSaverProgram" == "xscreensaver" ]; then
-        DC_log "DC_enableScrSvrOther(): delaying xscreensaver..."
+    if [ "$LO_screenSaverProgram" == "xscreensaver" ]; then
+        LO_log "LO_enableScrSvrOther(): delaying xscreensaver..."
         xscreensaver-command -activate > /dev/null
     else
-        if [ $DC_xdgScrSvrPresent -eq 1 ]; then
-            DC_log "DC_enableScrSvrOther(): trying to delay with xdg-screensaver..."
+        if [ $LO_xdgScrSvrPresent -eq 1 ]; then
+            LO_log "LO_enableScrSvrOther(): trying to delay with xdg-screensaver..."
             xdg-screensaver reset
         fi
     fi
 
-    DC_enable_dpms
+    LO_enable_dpms
+    
     # Setting DPMS.
-    if [ $DC_DPMSControl -eq 1 ]; then
-        DC_log "DC_enableScrSvrOther(): Setting DPMS Standby Time: $DC_DPMSStandbyTime, Suspend: $DC_DPMSSuspendTime, Off: $DC_DPMSOffTime"
-        xset dpms $DC_DPMSStandbyTime $DC_DPMSSuspendTime $DC_DPMSOffTime
+    if [ $LO_DPMSControl -eq 1 ]; then
+        LO_log "LO_enableScrSvrOther(): Setting DPMS Standby Time: $LO_DPMSStandbyTime, Suspend: $LO_DPMSSuspendTime, Off: $LO_DPMSOffTime"
+        xset dpms $LO_DPMSStandbyTime $LO_DPMSSuspendTime $LO_DPMSOffTime
     fi
     
-    DC_XSetOn
+    LO_XSetOn
+
     # Setting X11 Scrensaver Extension.
-    if [ $DC_X11ScrSvrControl -eq 1 ]; then
-        DC_log "DC_enableScrSvrOther(): Setting X11 Scrensaver Extension to Timeout: $DC_X11ScrSvrTimeout"
-        xset s $DC_X11ScrSvrTimeout
+    if [ $LO_X11ScrSvrControl -eq 1 ]; then
+        LO_log "LO_enableScrSvrOther(): Setting X11 Scrensaver Extension to Timeout: $LO_X11ScrSvrTimeout"
+        xset s $LO_X11ScrSvrTimeout
     fi
     
-    DC_save_state "ENABLED"
+    LO_save_state "ENABLED"
 }
 
 # disable xautolock/screensaver
-function DC_disableScreensaver() {
-    if [ "$DC_screenSaverProgram" = "xautolock" ]; then
-        DC_disableScrXautolock "force"
+function LO_disableScreensaver() {
+    if [ "$LO_screenSaverProgram" = "xautolock" ]; then
+        LO_disableScrXautolock "force"
     else
-        DC_disableScrSvrOther
+        LO_disableScrSvrOther
     fi
 }
 
 # enable xautolock/screensaver
-function DC_enableScreensaver() {
-    if [ "$DC_screenSaverProgram" = "xautolock" ]; then
-        DC_enableScrXautolock "force"
+function LO_enableScreensaver() {
+    if [ "$LO_screenSaverProgram" = "xautolock" ]; then
+        LO_enableScrXautolock "force"
     else
-        DC_enableScrSvrOther
+        LO_enableScrSvrOther
     fi
 }
 
-# check for delay programs to disable xautolock/screensaver
-function DC_delayScreensaver() {
-    DC_log "DC_delayScreensaver(): Scrensaver $DC_screenSaverProgram detected ..."
+# Check for delay programs to disable xautolock/screensaver
+function LO_delayScreensaver() {
+    LO_log "LO_delayScreensaver(): Scrensaver $LO_screenSaverProgram detected ..."
     # disable screensaver if mandatory delay progs were found
-    if DC_hasMandatoryDelay; then 
-        DC_log "DC_delayScreensaver(): Delaying the screensaver because a mandatory delay program is running..."
-        DC_disableScreensaver 
+    if LO_hasMandatoryDelay; then 
+        LO_log "LO_delayScreensaver(): Delaying the screensaver because a mandatory delay program is running..."
+        LO_disableScreensaver 
         return 0
     else
-        DC_log "DC_delayScreensaver(): NO mandatory delay programs were found..."
+        LO_log "LO_delayScreensaver(): NO mandatory delay programs were found..."
     fi
-    # disable xautolock if delay progs are playing (using sound card)
-    if DC_isSndCardBeingUsed; then 
-        local progName=""
-        progName=$(DC_whichUsingPulseaudio)
+    # disable screensaver if there are delay apps using sound card
+    if LO_isSndCardBeingUsed; then 
+        local progName="$(LO_whichUsingPulseaudio)"
         if [ ! -z "$progName" ]; then 
-            DC_log "DC_delayScreensaver(): Delaying the screensaver because a delay program (or stream), \"$progName\", is running..."
-            DC_disableScreensaver 
+            LO_log "LO_delayScreensaver(): Delaying the screensaver because a delay program (or stream), \"$progName\", is running..."
+            LO_disableScreensaver 
             return 0
         else
-            DC_log "DC_delayScreensaver(): NO delay program (or stream) using sound card is running..."
+            LO_log "LO_delayScreensaver(): NO delay program (or stream) using sound card is running..."
         fi
     fi
-    # disable xautolock if delay progs are in fullscreen mode
-    if DC_isFullScreenBeingUsed; then 
-        DC_log "DC_delayScreensaver(): Delaying the screensaver because a Fullscreen delay program is running..."
-        DC_disableScreensaver 
+    # disable screensaver if there are delay apps in fullscreen mode
+    if LO_isFullScreenBeingUsed; then 
+        LO_log "LO_delayScreensaver(): Delaying the screensaver because a Fullscreen delay program is running..."
+        LO_disableScreensaver 
         return 0
     else
-        DC_log "DC_delayScreensaver(): NO delay program (or stream) in Fullscreen mode is running..."
+        LO_log "LO_delayScreensaver(): NO delay program (or stream) in Fullscreen mode is running..."
     fi
-    # disable xautolock if we have significant ouput connections
-    if DC_hasDelayOutputConns; then 
-        DC_log "DC_delayScreensaver(): Delaying the screensaver because Output connections were found..."
-        DC_disableScreensaver 
+    # disable screensaver if we have significant ouput connections
+    if LO_hasDelayOutputConns; then 
+        LO_log "LO_delayScreensaver(): Delaying the screensaver because Output connections were found..."
+        LO_disableScreensaver 
         return 0
     else
-        DC_log "DC_delayScreensaver(): NO delay output connections detected..."
+        LO_log "LO_delayScreensaver(): NO delay output connections detected..."
     fi
 
-    DC_log "DC_delayScreensaver(): NO delay programs were detected for suspending screensaver..."
+    LO_log "LO_delayScreensaver(): NO delay programs were detected for suspending screensaver..."
 
-    #-----------------------------------------
     # Since NO delay situations were detected we must enable screensaver if necessary
-    #-----------------------------------------
-    local stt=""
-    stt=$(DC_read_state)
-
-    DC_log "DC_delayScreensaver(): Current screensaver state = $stt "
-    
+    local stt="$(LO_read_state)"
+    LO_log "LO_delayScreensaver(): Current screensaver state = $stt "
     if [ "$stt" == "DISABLED" ]; then
-        DC_enableScreensaver 
-        DC_log "DC_delayScreensaver(): running screensaver ENABLED..."
+        LO_enableScreensaver 
+        LO_log "LO_delayScreensaver(): running screensaver ENABLED..."
         return 0
     fi
 }
 
 # sleep for the next iteration
-function DC_sleep() {
-    if [ $DC_enableDynDelay -eq 0 ]; then
-        DC_log "DC_sleep(): sleeping for $DC_delay"
-        DC_log "--------------- loop done! ---------------"
-        snore "$DC_delay"
+function LO_sleep() {
+    if [ $LO_enableDynDelay -eq 0 ]; then
+        LO_log "LO_sleep(): sleeping for $LO_delay"
+        LO_log "--------------- loop done! ---------------"
+        snore "$LO_delay"
         return 0
     fi
-    local DC_systemSleepDelay=""
-    local DC_sleepDelay=""
-    if [ $DC_mateScrSvrPresent -eq 1 ]; then
+    local LO_systemSleepDelay=""
+    local LO_sleepDelay=""
+    if [ $LO_mateScrSvrPresent -eq 1 ]; then
         if [ -f /sys/class/power_supply/ADP1/online ]; then
-            if [ $DC_gsettingsPresent -eq 1 ]; then
+            if [ $LO_gsettingsPresent -eq 1 ]; then
                 if [ "$( awk '{ print $0 }' /sys/class/power_supply/ADP1/online)" == "1" ]; then
-                    DC_systemSleepDelay=$(gsettings get org.mate.power-manager sleep-display-ac 2>/dev/null)
+                    LO_systemSleepDelay=$(gsettings get org.mate.power-manager sleep-display-ac 2>/dev/null)
                 else
-                    DC_systemSleepDelay=$(gsettings get org.mate.power-manager sleep-display-battery 2>/dev/null)
+                    LO_systemSleepDelay=$(gsettings get org.mate.power-manager sleep-display-battery 2>/dev/null)
                 fi
             fi
         fi
-    elif [ $DC_gnomeScrSvrPresent -eq 1 ]; then
+    elif [ $LO_gnomeScrSvrPresent -eq 1 ]; then
         if [ -f /sys/class/power_supply/ADP1/online ]; then
-            if [ $DC_gsettingsPresent -eq 1 ]; then
+            if [ $LO_gsettingsPresent -eq 1 ]; then
                 if [ "$( awk '{ print $0 }' /sys/class/power_supply/ADP1/online)" == "1" ]; then
-                    DC_systemSleepDelay=$(gsettings get org.gnome.settings-daemon.plugins.power sleep-inactive-ac-timeout 2>/dev/null)
+                    LO_systemSleepDelay=$(gsettings get org.gnome.settings-daemon.plugins.power sleep-inactive-ac-timeout 2>/dev/null)
                 else
-                    DC_systemSleepDelay=$(gsettings get org.gnome.settings-daemon.plugins.power sleep-inactive-battery-timeout 2>/dev/null)
+                    LO_systemSleepDelay=$(gsettings get org.gnome.settings-daemon.plugins.power sleep-inactive-battery-timeout 2>/dev/null)
                 fi
             fi
         fi
     fi
-    if [ "$(echo "$DC_systemSleepDelay" | egrep -c "^[0-9]+$")" == "1" ]; then
-        if [ $DC_systemSleepDelay -le $(($DC_defaultSleepDelay+5)) ]; then
-            DC_sleepDelay=$DC_defaultSleepDelay
+    if [ "$(echo "$LO_systemSleepDelay" | egrep -c "^[0-9]+$")" == "1" ]; then
+        if [ $LO_systemSleepDelay -le $(($LO_defaultSleepDelay+5)) ]; then
+            LO_sleepDelay=$LO_defaultSleepDelay
         else
-            DC_sleepDelay=$(($DC_systemSleepDelay-5))
+            LO_sleepDelay=$(($LO_systemSleepDelay-5))
         fi
     else
-        DC_sleepDelay=$DC_defaultSleepDelay
+        LO_sleepDelay=$LO_defaultSleepDelay
     fi
-    DC_log "DC_sleep(): sleeping for $DC_sleepDelay (system idle timeout is $DC_systemSleepDelay)"
-    DC_log "--------------- loop done! ---------------"
-    snore "$DC_sleepDelay"
+    LO_log "LO_sleep(): sleeping for $LO_sleepDelay (system idle timeout is $LO_systemSleepDelay)"
+    LO_log "--------------- loop done! ---------------"
+    snore "$LO_sleepDelay"
 }
 
-# if we are using custom xautolock configs, we can kill all other screensavers daemons 
-function DC_disableOtherSS() {
-    if [ $(pgrep -lfc cinnamon-screensaver) -ge 1 ] ; then
-        DC_log "Shutting down cinnamon-screensaver daemon..."
-        while 2>/dev/null killall cinnamon-screensaver; do
-            snore 1
-        done
-    fi
-    if [ $(pgrep -lfc mate-screensaver) -ge 1 ] ; then
-        DC_log "Shutting down mate-screensaver daemon..."
-        while 2>/dev/null killall mate-screensaver; do
-            snore 1
-        done
-    fi
-    if [ $(pgrep -lfc gnome-screensaver) -ge 1 ] ; then
-        DC_log "Shutting down gnome-screensaver daemon..."
-        while 2>/dev/null killall gnome-screensaver; do
-            snore 1
-        done
-    fi
-    if [ $(pgrep -lfc xscreensaver) -ge 1 ] ; then
-        DC_log "Shutting down xscreensaver daemon..."
-        while 2>/dev/null killall xscreensaver; do
-            snore 1
-        done
-    fi
+# If we are using custom xautolock configs, we can kill all other screensavers daemons 
+function LO_disableOtherSS() {
+    stop_it "cinnamon-screensaver"
+    stop_it "mate-screensaver"
+    stop_it "gnome-screensaver"
+    stop_it "xscreensaver"
     return 0
 }
 
 # check if an application is present and can be executed
-function DC_isPresentAndExec() {
-    [ -z "$1" ] && return 1;
-    local tmp=""
-    tmp=$(command -v "$1")
-    [ -z "$tmp" ] && return 1;
-
-    if [ -x "${tmp}" ]; then 
-        return 0; 
-    else 
-        return 1; 
-    fi
+function LO_isPresentAndExec() {
+    [ -z "$1" ] && return 1
+    local tmp="$(command -v "$1")"
+    [ ! -z "$tmp" ] && [ -x "${tmp}" ] && return 0 || return 1
 }
 
-# this is actually the minimum allowed dynamic delay.
-# Also the default (if everything else fails)
-DC_defaultSleepDelay=150
+# required binaries that must be present in order to run
+precheck "xset"
+precheck "wmctrl"
+precheck "xvinfo"
+precheck "xprop"
+precheck "xrandr"
+precheck "bc"
+precheck "xautolock"
+precheck "pulseaudio"
+precheck "awk"
+precheck "grep"
 
 # Enable use of dynamic delay via gsettings
-DC_enableDynDelay=0
+LO_enableDynDelay=0
+LO_delay=""
 
-DC_delay=""
+# This is actually the minimum allowed dynamic delay.
+# Also the default (if everything else fails)
+LO_defaultSleepDelay=150
 
-# If argument is not integer quit.
+# If passed argument is not integer quit.
 if [ ! -z "$1" ]; then
     if [[ $1 = *[^0-9]* ]]; then
+        LO_log "The Argument \"$1\" is not valid, not an integer."
         echo "The Argument \"$1\" is not valid, not an integer"
         echo "Please use the time in seconds you want the checks to repeat."
         echo "You want it to be ~10 seconds less than the time it takes your screensaver or DPMS to activate"
         exit 1
     else
-        DC_delay=$1
+        LO_delay=$1
     fi
-elif [ $DC_enableDynDelay -eq 0 ]; then
-    DC_delay=$DC_defaultSleepDelay
+elif [ $LO_enableDynDelay -eq 0 ]; then
+    LO_delay=$LO_defaultSleepDelay
 fi
 
-# If argument empty, use dynamic delay.
-DC_systemSleepDelay=$DC_defaultSleepDelay
+# Check for screensaver apps on your system
+LO_xautolockPresent=$(if LO_isPresentAndExec "xautolock"; then echo 1; else echo 0; fi)
+LO_gsettingsPresent=$(if LO_isPresentAndExec "gsettings"; then echo 1; else echo 0; fi)
+LO_xdgScrSvrPresent=$(if LO_isPresentAndExec "xdg-screensaver"; then echo 1; else echo 0; fi)
+LO_mateScrSvrPresent=$(if LO_isPresentAndExec "mate-screensaver"; then echo 1; else echo 0; fi)
+LO_gnomeScrSvrPresent=$(if LO_isPresentAndExec "gnome-screensaver"; then echo 1; else echo 0; fi)
+LO_cinnamonScrSvrPresent=$(if LO_isPresentAndExec "cinnamon-screensaver"; then echo 1; else echo 0; fi)
+LO_xScrSvrPresent=$(if LO_isPresentAndExec "xscreensaver"; then echo 1; else echo 0; fi)
+
+# Search for a running screensaver program 
+LO_screenSaverProgram=$(LO_whichScrSvrRunning)
+
+# xautolock is default and also fallback option 
 
-if [ -z "$DC_delay" ]; then
-    DC_enableDynDelay=1
-    DC_log "NO delay specified, dynamic delay activated"
+if [ -z "$LO_screenSaverProgram" ]; then
+    [ $LO_xautolockPresent -eq 1 ] && LO_screenSaverProgram="xautolock"
+fi
+
+# If argument empty, use dynamic delay.
+LO_systemSleepDelay=$LO_defaultSleepDelay
+if [ -z "$LO_delay" ]; then
+    LO_enableDynDelay=1
+    LO_log "NO delay specified, dynamic delay activated"
 fi
 
 # config vars
-DC_scriptName="${0##*/}"
-DC_scriptBaseName="${DC_scriptName%%.*}"
-DC_scriptFPath="$(dirname "$(readlink -f $0)")/${DC_scriptName}"
-DC_defaultDisableTime="$(echo "2^7" | bc)"
-DC_logFile="/var/log/${DC_scriptBaseName}.log"
-DC_stateFile="/tmp/${DC_scriptBaseName}_${USER}_state.txt"
-
-# YOU SHOULD NOT NEED TO MODIFY ANYTHING BELOW THIS LINE
-DC_xautolockPresent=$(if DC_isPresentAndExec "xautolock"; then echo 1; else echo 0; fi)
-DC_gsettingsPresent=$(if DC_isPresentAndExec "gsettings"; then echo 1; else echo 0; fi)
-DC_xdgScrSvrPresent=$(if DC_isPresentAndExec "xdg-screensaver"; then echo 1; else echo 0; fi)
-DC_mateScrSvrPresent=$(if DC_isPresentAndExec "mate-screensaver"; then echo 1; else echo 0; fi)
-DC_gnomeScrSvrPresent=$(if DC_isPresentAndExec "gnome-screensaver"; then echo 1; else echo 0; fi)
-DC_cinnamonScrSvrPresent=$(if DC_isPresentAndExec "cinnamon-screensaver"; then echo 1; else echo 0; fi)
-DC_xScrSvrPresent=$(if DC_isPresentAndExec "xscreensaver"; then echo 1; else echo 0; fi)
+LO_scriptName="${0##*/}"
+LO_scriptBaseName="${LO_scriptName%%.*}"
+LO_scriptFPath="$(dirname "$(readlink -f $0)")/${LO_scriptName}"
+LO_defaultDisableTime="$(echo "2^7" | bc)"
+LO_stateFile="/tmp/${LO_scriptBaseName}_${USER}_state.txt"
 
 # enumerate all the attached screens
-DC_displays=$(xvinfo | awk -F'#' '/^screen/ {print $2}' | xargs)
+LO_displays=$(xvinfo | awk -F'#' '/^screen/ {print $2}' | xargs)
 
 # Kill older instances of this job
 kill_older
 
-# clean DC_state file
-DC_state_clean
-
-# start-up DC_log messages
-DC_log "[ START ] $DC_scriptName  "
-DC_log "DC_logFile..............: $DC_logFile" 
-DC_log "DC_stateFile............: $DC_stateFile"
-DC_log "DC_scriptName...........: $DC_scriptName"
-DC_log "DC_scriptFPath..........: $DC_scriptFPath"
-DC_log "DC_defaultDisableTime...: $DC_defaultDisableTime"
-DC_log "DC_defaultSleepDelay....: $DC_defaultSleepDelay"
-DC_log "DC_enableDynDelay.......: $DC_enableDynDelay"
-DC_log "DC_delay................: $DC_delay"
-DC_log "DC_xautolockPresent.....: $DC_xautolockPresent"
-DC_log "DC_gsettingsPresent.....: $DC_gsettingsPresent"
-DC_log "DC_xdgScrSvrPresent.....: $DC_xdgScrSvrPresent"
-DC_log "DC_mateScrSvrPresent....: $DC_mateScrSvrPresent"
-DC_log "DC_gnomeScrSvrPresent...: $DC_gnomeScrSvrPresent"
-DC_log "DC_cinnamonScrSvrPresent: $DC_cinnamonScrSvrPresent"
-DC_log "DC_xScrSvrPresent.......: $DC_xScrSvrPresent"
+# clean LO_state file
+LO_state_clean
+
+# start-up LO_log messages
+LO_log "[ START ] $LO_scriptName  "
+LO_log "LO_stateFile............: $LO_stateFile"
+LO_log "LO_scriptName...........: $LO_scriptName"
+LO_log "LO_scriptFPath..........: $LO_scriptFPath"
+LO_log "LO_defaultDisableTime...: $LO_defaultDisableTime"
+LO_log "LO_defaultSleepDelay....: $LO_defaultSleepDelay"
+LO_log "LO_enableDynDelay.......: $LO_enableDynDelay"
+LO_log "LO_delay................: $LO_delay"
+LO_log "LO_xautolockPresent.....: $LO_xautolockPresent"
+LO_log "LO_gsettingsPresent.....: $LO_gsettingsPresent"
+LO_log "LO_xdgScrSvrPresent.....: $LO_xdgScrSvrPresent"
+LO_log "LO_mateScrSvrPresent....: $LO_mateScrSvrPresent"
+LO_log "LO_gnomeScrSvrPresent...: $LO_gnomeScrSvrPresent"
+LO_log "LO_cinnamonScrSvrPresent: $LO_cinnamonScrSvrPresent"
+LO_log "LO_xScrSvrPresent.......: $LO_xScrSvrPresent"
+LO_log "Original Screensaver detected = $LO_screenSaverProgram"
 
-# Search for a running screensaver program 
-DC_screenSaverProgram=$(DC_whichScrSvrRunning)
-
-DC_log "Original Screensaver detected = $DC_screenSaverProgram"
-
-# xautolock is default. 
-# If not present verify for another screensaver running
-if [ -z "$DC_screenSaverProgram" ]; then
-    [ $DC_xautolockPresent -eq 1 ] && DC_screenSaverProgram="xautolock"
+# Starting procedures for xautolock daemon
+if [ "$LO_screenSaverProgram" = "xautolock" ]; then 
+    LO_log "Starting xautolock daemon..."
+    LO_enableScrXautolock "force"
 fi
 
 # Starting with ENABLED state
-DC_log "Saving initial state = ENABLED"
-DC_save_state "ENABLED"
-
-# Starting procedures for xautolock daemon
-if [ "$DC_screenSaverProgram" = "xautolock" ]; then 
-    DC_log "Shutting down previous xautolock daemon..."
-    while 2>/dev/null killall xautolock; do
-        snore 1
-    done
-    DC_log "Starting xautolock daemon..."
-    DC_enableXautolock "force"
-fi
+LO_log "Saving initial state = ENABLED"
+LO_save_state "ENABLED"
 
 # Initiate monitoring
 while true; do
-    #DC_screenSaverProgram=$(DC_whichScrSvrRunning)
-    if [ "$DC_screenSaverProgram" = "xautolock" ]; then
-        DC_disableOtherSS
-    fi
-    DC_delayScreensaver
-    DC_sleep $DC_delay
+    #LO_screenSaverProgram=$(LO_whichScrSvrRunning)
+    [ "$LO_screenSaverProgram" = "xautolock" ] && LO_disableOtherSS
+    LO_delayScreensaver
+    LO_sleep $LO_delay
 done
 exit 0
\ No newline at end of file
diff --git a/bin/mylock b/bin/mylock
index df44f4e8..6b61df69 100755
--- a/bin/mylock
+++ b/bin/mylock
@@ -1,37 +1,31 @@
 #!/usr/bin/env bash
+# This script is intended to be run as the xautolock locker and notifier.
+# It requires i3lock, and dunst is optional.
 #set -eu
 
 if [ -f "$HOME/bin/mycommon" ]; then
     . "$HOME/bin/mycommon"
 fi
 
-# This script is intended to be run as the xautolock locker and notifier.
-# It requires i3lock, and dunst is optional.
-
 # Lock screen if possible.
 function do_lock() {
     # Only works if X is running.
-    if ! is_running_X ; then
-        log "X server is not running";
-        return 0;
-    fi
+    ! is_running_X && log "X server is not running" && return 0
     
     # Already locked
     locked && return 0;
     
     log "Locking screen now..."
     dunstctl stop
-    
     # Fork both i3lock and its monitor to avoid blocking xautolock.
     # this must be the last command, and it must be 'non forking', as expected by 'xautolock'
-    "$HOME"/bin/lock -gpf Comic-Sans-MS -- scrot -z &
-        
+    ~/bin/lock -gpf Comic-Sans-MS -- scrot -z &
     pid="$!"
-    log "Waiting for PID $pid to end..."
+    log "Locked and Waiting until (screen lock) PID $pid ends up..."
     while 2>/dev/null kill -0 "$pid"; do
-        sleep 1
+        snore 1.2
     done
-    
+    log "Unlocked and resumed..."
     dunstctl resume
 }
 
@@ -41,15 +35,23 @@ function do_test() {
     pgrep -f dunst && log "dunst found" || log "dunst not found"
 }
 
-cmd=${1:-lock}
+function main(){
+    precheck "xset"
+    precheck "i3lock"
+
+    local cmd=${1:-lock}
+    
+    case "$cmd" in
+        lock)
+            do_lock
+        ;;
+        debug)
+            do_test
+        ;;
+        *)
+            log "Unrecognized option: $1"
+    esac
+}
+
+main "$@"
 
-case "$cmd" in
-    lock)
-        do_lock
-    ;;
-    debug)
-        do_test
-    ;;
-    *)
-        log "Unrecognized option: $1"
-esac
diff --git a/bin/mynotify b/bin/mynotify
index 3f58741d..9d766531 100755
--- a/bin/mynotify
+++ b/bin/mynotify
@@ -1,36 +1,27 @@
 #!/usr/bin/env bash
+# This script is intended to be run as the main notifier script for this installation.
 set -eu
 
 if [ -f "$HOME/bin/mycommon" ]; then
     . "$HOME/bin/mycommon"
 fi
 
-# This script is intended to be run as the main notifier script for this installation.
-
 # Notify desired message.
 function do_notify() {
     # Only works if X is running.
-    if ! is_running_X; then
-        log "X server is not running";
-        return 0;
-    fi
-
+   !is_running_X && log "X server is not running" && return 0
+    
     # Notification should not be issued while locked.
     locked && return 0;
-    log "Sending notification.";
     
-    local secs="";
-
     # grep finds either Xautolock.notify or Xautolock*notify
-    secs="$(xrdb -query | grep -m1 '^Xautolock.notify' | cut -f2)";
+    local secs="$(xrdb -query | grep -m1 '^Xautolock.notify' | cut -f2)"
+    [ -n "$secs" ] || secs="30"
     
-    test -n "$secs" || secs="30"
-
-    log "Locking in $secs seconds";
-
-    notify-send --urgency="normal" --app-name="mynotify" \
-        --icon="$(iconPath system-lock-screen)" \
-        -- "Screen Lock in " "$secs seconds";
+    log "Locking in $secs seconds"
+    log "Sending notification."
+    
+    notify-send --urgency="normal" --app-name="mynotify" --icon="$(iconPath system-lock-screen)" -- "Screen Lock in " "$secs seconds"
     return 0
 }
 
@@ -38,23 +29,25 @@ function do_test() {
     is_running_X && log "X is running" || log "X server down"
     locked "debug" && log "Screen already locked" || log "Screen not locked";
     local secs="$(xrdb -query | grep -m1 '^Xautolock.notify' | cut -f2)"
-    
-    if [ -n "$secs" ]; then
-        log "Locking in $secs seconds"
-    else
-        log "secs not defined"
-    fi
+    [ -n "$secs" ] && log "Locking in $secs seconds" || log "secs not defined"
 }
 
-cmd=${1:-notify}
-
-case "$cmd" in
-    notify)
-        do_notify
+function main(){
+    precheck "xset"
+    precheck "xrdb"
+    
+    cmd=${1:-notify}
+    
+    case "$cmd" in
+        notify)
+            do_notify
         ;;
-    debug)
-        do_test
+        debug)
+            do_test
         ;;
-    *)
-        log "Unrecognized option: $1"
-esac
+        *)
+            log "Unrecognized option: $1"
+    esac
+}
+
+main "$@"
\ No newline at end of file
diff --git a/bin/myoff b/bin/myoff
index a64cc635..64b845a7 100755
--- a/bin/myoff
+++ b/bin/myoff
@@ -1,49 +1,43 @@
 #!/usr/bin/env bash
+# This script is intended to be run as the main dpms off script for this installation.
 #set -eu
 
 if [ -f "$HOME/bin/mycommon" ]; then
     . "$HOME/bin/mycommon"
 fi
 
-# This script is intended to be run as the main dpms off script for this installation.
-cmd=${1:-off}
-
-# Return 0 if xset is found.
-function xset_ok() {
-    [ $(command -v xset) ] && return 0 || return 1
-}
-
 #off the screen if possible.
 function do_off() {
     # Only works if X is running.
-    
-    if is_running_X; then
-        log "X server is not running";
-        return 0;
-    fi
-    
-    if xset_ok; then
-        # if "off" is given as parameter, then spawn a new thread to turn off the screen
-        snore 1
-        xset dpms force off &
-    else
-        log "xset command not found";
-    fi
- }
+    ! is_running_X && log "X server is not running" && return 0
+    # if "off" is given as parameter, then spawn a new thread to turn off the screen
+    xset dpms force off & 
+    disown
+    return 0
+}
 
 function do_test() {
-    is_running_X && log "X is running" || log "X server down";
-    xset_ok && log "xset command can be used" || log "xset command not found";
-    locked "debug" && log "Screen already locked" || log "Screen not locked";
+    is_running_X && log "X is running" || log "X server down"
+    checkfor "xset" && log "xset command can be used" || log "xset command not found"
+    locked "debug" && log "Screen already locked" || log "Screen not locked"
+    return 0
 }
 
-case "$cmd" in
-    off)
-        do_off
-        ;;  
-    debug)
-        do_test
+function main(){
+    precheck "xset"
+
+    local cmd=${1:-off}
+    
+    case "$cmd" in
+        off)
+            do_off
         ;;
-    *)
-        log "Unrecognized option: $1"
-esac
+        debug)
+            do_test
+        ;;
+        *)
+            log "Unrecognized option: $1"
+    esac
+}
+
+main "$@"
diff --git a/bin/myreboot b/bin/myreboot
index a925efd5..0a72099e 100755
--- a/bin/myreboot
+++ b/bin/myreboot
@@ -1,104 +1,94 @@
 #!/usr/bin/env bash
+# This script is intended to be run as the main reboot script for this installation.
 set -eu
 
 if [ -f "$HOME/bin/mycommon" ]; then
     . "$HOME/bin/mycommon"
 fi
 
-# This script is intended to be run as the main reboot script for this installation.
 function do_reboot() {
+    auth_user && continue || return 0
+    
     if is_running_X ; then
-        if locked ; then
-            return 0
+        locked && return 0
+        
+        if checkfor "systemctl"; then
+            systemctl reboot &
+            exit 0
         fi
-        if auth_user; then
-            if systemctl_ok; then
-                systemctl reboot &
-                exit 0
-            fi
-            if can_reboot; then
-                dbus_reboot
-                exit 0
-            fi
-            if shutdown_ok; then
-                shutdown -r now &
-                exit 0
-            fi
-            if init_ok; then
-                init 6 &
-                exit 0
-            fi
+        if can_reboot; then
+            dbus_reboot &
+            exit 0
+        fi
+        if checkfor "shutdown"; then
+            shutdown -r now &
+            exit 0
+        fi
+        if checkfor "init"; then
+            init 6 &
+            exit 0
         fi
     else
-        if auth_user; then
-            if systemctl_ok; then
-                systemctl reboot &
-                exit 0
-            fi
-            if shutdown_ok; then
-                shutdown -r now &
-                exit 0
-            fi
-            if init_ok; then
-                init 6 &
-                exit 0
-            fi
+        if checkfor "systemctl"; then
+            systemctl reboot &
+            exit 0
+        fi
+        if checkfor "shutdown"; then
+            shutdown -r now &
+            exit 0
+        fi
+        if checkfor "init"; then
+            init 6 &
+            exit 0
         fi
     fi
-    
 }
 
 function do_test() {
     if is_running_X ; then
         log "X is running"
-        if locked "debug" ; then
-            log "Screen locked"
-        else
-            log "Screen not locked"
-        fi
+        locked  && log "Screen locked" || log "Screen not locked"
         if auth_user; then
             log "user $USER has polkit binding to reboot"
-            if systemctl_ok; then
-                log "can use: systemctl reboot"
-            fi
-            if can_reboot; then
-                log "can use: dbus logind to reboot"
-            fi
-            if shutdown_ok; then
-                log "can use: shutdown -r now"
-            fi
-            if init_ok; then
-                log "can use: init 6"
-            fi
+            checkfor "systemctl" && log "can use: systemctl reboot"
+            can_reboot && log "can use: dbus logind to reboot"
+            checkfor "shutdown" && log "can use: shutdown -r now"
+            checkfor "init" && log "can use: init 6"
+        else
+            log "user $USER has not polkit binding to reboot"
         fi
     else
         log "X is not running"
         if auth_user; then
             log "user $USER has polkit binding to reboot"
-            if systemctl_ok; then
-                log "can use: systemctl reboot"
-            fi
-            if shutdown_ok; then
-                log "can use: shutdown -r now"
-            fi
-            if init_ok; then
-                log "can use: init 6"
-            fi
+            checkfor "systemctl" && log "can use: systemctl reboot"
+            checkfor "shutdown" && log "can use: shutdown -r now"
+            checkfor "init" && log "can use: init 6"
+        else
+            log "user $USER has not polkit binding to reboot"
         fi
     fi
     return 0
 }
 
-cmd=${1:-reboot}
+function main(){
+    precheck "xset"
+    precheck "loginctl"
+    
+    local cmd=${1:-reboot}
+    
+    case "$cmd" in
+        reboot)
+            log "reboot now..."
+            do_reboot
+        ;;
+        debug)
+            do_test
+        ;;
+        *)
+            log "Unrecognized option: $1"
+    esac
+}
+
+main "$@"
 
-case "$cmd" in
-    reboot)
-        log "reboot now..."
-        do_reboot
-    ;;
-    debug)
-        do_test
-    ;;
-    *)
-        log "Unrecognized option: $1"
-esac
diff --git a/bin/myshutdown b/bin/myshutdown
index d9ff121b..c032030c 100755
--- a/bin/myshutdown
+++ b/bin/myshutdown
@@ -1,39 +1,36 @@
 #!/usr/bin/env bash
+# This script is intended to be run as the main shutdown script for this installation.
 set -eu
 
 if [ -f "$HOME/bin/mycommon" ]; then
     . "$HOME/bin/mycommon"
 fi
 
-# This script is intended to be run as the main shutdown script for this installation.
-
 function do_shutdown() {
+    auth_user && continue || return 0
+    
     if is_running_X ; then
-        if locked ; then
-            return 0
+        locked && return 0
+        if checkfor "systemctl"; then
+            systemctl poweroff &
+            exit 0
         fi
-        if auth_user; then
-            if systemctl_ok; then
-                systemctl poweroff &
-                exit 0
-            fi
-            if can_poweroff; then
-                dbus_poweroff
-                exit 0
-            fi
+        if can_poweroff; then
+            dbus_poweroff &
+            exit 0
         fi
     else
-        if auth_user; then
-            if systemctl_ok; then
-                systemctl poweroff &
-                exit 0
-            fi
-            if shutdown_ok; then
-                shutdown -h now
-            fi
-            if init_ok; then
-                init 0
-            fi
+        if checkfor "systemctl"; then
+            systemctl poweroff &
+            exit 0
+        fi
+        if checkfor "shutdown"; then
+            shutdown -h now &
+            exit 0
+        fi
+        if checkfor "init"; then
+            init 0 &
+            exit 0
         fi
     fi
 }
@@ -41,54 +38,47 @@ function do_shutdown() {
 function do_test() {
     if is_running_X ; then
         log "X is running"
-        if locked "debug" ; then
-            log "Screen locked"
-        else
-            log "Screen not locked"
-        fi
+        locked && log "Screen locked" || log "Screen not locked"
         if auth_user; then
             log "user $USER has polkit binding to poweroff"
-            if systemctl_ok; then
-                log "can use: systemctl poweroff"
-            fi
-            if can_poweroff; then
-                log "can use: dbus logind to poweroff"
-            fi
-            if shutdown_ok; then
-                log "can use: shutdown -h now"
-            fi
-            if init_ok; then
-                log "can use: init 0"
-            fi
+            checkfor "systemctl" && log "can use: systemctl poweroff"
+            can_poweroff && log "can use: dbus logind to poweroff"
+            checkfor "shutdown" && log "can use: shutdown -h now"
+            checkfor "init" && log "can use: init 0"
+        else
+            log "user $USER has not polkit binding to poweroff"
         fi
     else
         log "X is not running"
         if auth_user; then
             log "user $USER has polkit binding to poweroff"
-            if systemctl_ok; then
-                log "can use: systemctl poweroff"
-            fi
-            if shutdown_ok; then
-                log "can use: shutdown -h now"
-            fi
-            if init_ok; then
-                log "can use: init 0"
-            fi
+            checkfor "systemctl" && log "can use: systemctl poweroff"
+            checkfor "shutdown" && log "can use: shutdown -h now"
+            checkfor "init" && log "can use: init 0"
+        else
+            log "user $USER has not polkit binding to poweroff"
         fi
     fi
     return 0
 }
 
-cmd=${1:-down}
+function main(){
+    precheck "xset"
+    precheck "loginctl"
+
+    local cmd=${1:-down}
+    
+    case "$cmd" in
+        down)
+            log "shutdown now..."
+            do_shutdown
+        ;;
+        debug)
+            do_test
+        ;;
+        *)
+            log "Unrecognized option: $1"
+    esac
+}
 
-case "$cmd" in
-    down)
-        log "shutdown now..."
-        do_shutdown
-    ;;
-    debug)
-        do_test
-    ;;
-    *)
-        log "Unrecognized option: $1"
-esac
+main "$@"
\ No newline at end of file
diff --git a/bin/mysuspend b/bin/mysuspend
index e112a518..bd262bff 100755
--- a/bin/mysuspend
+++ b/bin/mysuspend
@@ -1,33 +1,28 @@
 #!/usr/bin/env bash
+# This script is intended to be run as the main suspend script for this installation.
 set -eu
 
 if [ -f "$HOME/bin/mycommon" ]; then
     . "$HOME/bin/mycommon"
 fi
 
-# This script is intended to be run as the main suspend script for this installation.
-
 function do_suspend() {
+    auth_user && continue || return 0
+    
     if is_running_X ; then
-        if locked ; then
-            return 0
+        # locked && return 0
+        if checkfor "systemctl"; then
+            systemctl suspend &
+            exit 0
         fi
-        if auth_user; then
-            if systemctl_ok; then
-                systemctl suspend &
-                exit 0
-            fi
-            if can_suspend; then
-                dbus_suspend
-                exit 0
-            fi
+        if can_suspend; then
+            dbus_suspend &
+            exit 0
         fi
     else
-        if auth_user; then
-            if systemctl_ok; then
-                systemctl suspend &
-                exit 0
-            fi
+        if checkfor "systemctl"; then
+            systemctl suspend &
+            exit 0
         fi
     fi
 }
@@ -35,45 +30,43 @@ function do_suspend() {
 function do_test() {
     if is_running_X ; then
         log "X is running"
-        if locked "debug" ; then
-            log "Screen locked"
-        else
-            log "Screen not locked"
-        fi
+        locked && log "Screen locked" || log "Screen not locked"
         if auth_user; then
             log "user $USER has polkit binding to suspend"
-            if systemctl_ok; then
-                log "using: systemctl suspend"
-                return 0
-            fi
-            if can_suspend; then
-                log "using: dbus logind to suspend"
-                return 0
-            fi
+            checkfor "systemctl" && log "using: systemctl suspend"
+            can_suspend && log "using: dbus logind to suspend"
+        else
+            log "user $USER has not polkit binding to suspend"
         fi
     else
         log "X is not running"
         if auth_user; then
             log "user $USER has polkit binding to suspend"
-            if systemctl_ok; then
-                log "using: systemctl suspend"
-                return 0
-            fi
+            checkfor "systemctl" && log "using: systemctl suspend"
+        else
+            log "user $USER has not polkit binding to suspend"
         fi
     fi
     return 0
 }
 
-cmd=${1:-suspend}
+function main(){
+    precheck "xset"
+    precheck "loginctl"
+
+    local cmd=${1:-suspend}
+    
+    case "$cmd" in
+        suspend)
+            log "suspend now..."
+            do_suspend
+        ;;
+        debug)
+            do_test
+        ;;
+        *)
+            log "Unrecognized option: $1"
+    esac
+}
 
-case "$cmd" in
-    suspend)
-        log "suspend now..."
-        do_suspend
-    ;;
-    debug)
-        do_test
-    ;;
-    *)
-        log "Unrecognized option: $1"
-esac
+main "$@"
diff --git a/bin/mywallchng b/bin/mywallchng
index c7116d1a..66d1c86f 100755
--- a/bin/mywallchng
+++ b/bin/mywallchng
@@ -1,37 +1,34 @@
 #!/usr/bin/env bash
+# This script is intended to be run as the main wallpaper changer for this installation.
+#set -eu
 
 if [ -f "$HOME/bin/mycommon" ]; then
     . "$HOME/bin/mycommon"
 fi
 
 function change_wallpaper(){
+    locked && return 0
     local old_IFS=$IFS
     IFS=$'\n'
-    local WallDir="${XDG_PICTURES_DIR:-$HOME/Imagens}/Wallpaper"
-    local WallList=( `find "$WallDir" -type f -iregex ".*/.*[.]\(jpe?g\|png\|gif\|bmp\)"` )
+    local wpDir="${XDG_PICTURES_DIR:-$HOME/Imagens}/Wallpaper"
+    local wpList=( $(find "$wpDir" -type f -iregex ".*/.*[.]\(jpe?g\|png\|gif\|bmp\)") )
     IFS=$old_IFS
-    local MaxFiles=${#WallList[@]}
-    if [ $MaxFiles -eq 0 ]; then
-        log "No Wallpaper files found in $WallDir"
-        exit 1
-    fi
-    local CurrIndex=1
-    [ -f "$WallDir/.last" ] && let CurrIndex="`cat "$WallDir/.last"` + 1" || let CurrIndex=1
-    if [ $CurrIndex -ge $MaxFiles ]; then
-        let CurrIndex=1
-    fi
-    echo $CurrIndex > "$WallDir"/.last
-    wpctl --set "${WallList[$CurrIndex]}" && wpctl --save
-    ## nitrogen --set-scaled --save "${WallList[$number]}"
-    log "Wallpaper changed to: ${WallList[$CurrIndex]}"
+    local qty=${#wpList[@]}
+    [ $qty -eq 0 ] && log "No Wallpaper files found in $wpDir" && log "Ending process..." && exit 1
+    local curr=1
+    [ -f "$wpDir/.last" ] && let curr="`cat "$wpDir/.last"` + 1" || let curr=1
+    [ $curr -ge $qty ] && let curr=1
+    echo $curr > "$wpDir"/.last
+    wpctl --set "${wpList[$curr]}" && wpctl --save
+    log "Wallpaper changed to: ${wpList[$curr]}"
 }
 
 function main(){
-    log "=====[ mywallchng started current PID=$$ ]====="
-    if ! is_running_X ; then
-        log "No X server at \$DISPLAY [$DISPLAY]" >&2
-        exit 1
-    fi
+    precheck "xset"
+    precheck "xdg-open"
+    
+    log "=====[ mywallchng started currrent PID=$$ ]====="
+    ! is_running_X && log "No X server at \$DISPLAY [$DISPLAY]" >&2 && exit 1
     kill_older
     ## nitrogen --restore
     wpctl --restore
diff --git a/bin/nosj b/bin/nosj
new file mode 100755
index 00000000..a87ac93c
--- /dev/null
+++ b/bin/nosj
@@ -0,0 +1,82 @@
+#!/usr/bin/env bash
+#
+# nosj - json parser in pure bash
+
+tokenize() {
+    local j str
+    
+    while read -rN 1; do
+        case $REPLY in
+            [\{\}\[\],])
+                [[ $str ]] && j+=$REPLY
+                [[ $str ]] || { tokens+=("$j" "$REPLY"); j=; }
+            ;;
+            
+            :)
+                [[ $str ]] && j+=:
+                [[ $str ]] || j+='\ '
+            ;;
+            
+            [[:space:]])
+                [[ $str ]] && j+=$REPLY
+            ;;
+            
+            [\"\'])
+                [[ $str ]] && str= || str=1
+                [[ ${j: -1} == \\ ]] && { str=1; j+=$REPLY; }
+            ;;
+            
+            *) j+=$REPLY ;;
+        esac
+    done
+}
+
+parse() {
+    local i key key_plain nosj objects o out val
+    
+    declare -A nosj
+    
+    for ((i=0;i<${#tokens[@]};i++)) {
+        case ${tokens[i]} in
+            \{|\[)
+                objects+=("${tokens[i-1]}")
+            ;;
+            
+            \}|\])
+                unset 'objects[-1]'
+            ;;
+            
+            *\\\ *)
+                key=${objects[*]//\\ /.}${tokens[i]/\\ *}
+                key_plain=index_${key//[^A-Za-z0-9]/_}
+                val=${tokens[i]/*\\ }
+                
+                if [[ -n ${nosj[$key]} ]]; then
+                    [[ -n ${nosj[${key}[0]]} ]] || {
+                        nosj["${key}[0]"]=${nosj[$key]}
+                        printf -v o 'nosj[%q]=%q' "${key}[0]" "${nosj[$key]}"
+                        out+=("$o")
+                    }
+                    
+                    declare -i "$key_plain+=1"
+                    printf -v o 'nosj[%q]=%q' "${key}[${!key_plain}]" "$val"
+                    out+=("$o")
+                    
+                elif [[ $val ]]; then
+                    nosj["$key"]=$val
+                    printf -v o 'nosj[%q]=%q' "$key" "$val"
+                    out+=("$o")
+                fi
+            ;;
+        esac
+    }
+    
+    printf '%s\n%s\n' "declare -A nosj" "${out[@]}"
+}
+
+main() {
+    tokenize < "${1:-/dev/stdin}"
+    parse
+}
+
+LANG=C LC_ALL=C IFS= main "$1"
\ No newline at end of file
diff --git a/bin/ob_off b/bin/ob_off
index 983e62b0..ca42ae81 100755
--- a/bin/ob_off
+++ b/bin/ob_off
@@ -4,38 +4,8 @@ if [ -f "$HOME/bin/mycommon" ]; then
     . "$HOME/bin/mycommon"
 fi
 
-function main() {
-    # Only works if X is running.
-    if ! is_running_X ; then
-        log "X server is not running";
-        return 0;
-    fi
-    if ! $(command -v gxmessage)
-        log "gxmessage not found";
-        return 0;
-    fi
-    # l10n support
-    case "${LANG:-}" in
-        de_* ) doMenu_en ;; # Deutsch
-        da_* ) doMenu_en ;; # Danish
-        es_* ) doMenu_en ;; # Española
-        fr_* ) doMenu_en ;; # Français
-        id_* ) doMenu_en ;; # Bahasa Indonesia
-        it_* ) doMenu_en ;; # Italian
-        lv_* ) doMenu_en ;; # Latvian
-        pl_* ) doMenu_en ;; # Polish
-        pt_* ) doMenu_pt ;; # Português
-        ru_* ) doMenu_en ;; # Russian
-        * ) doMenu_en ;; # Default to English
-    esac
-}
-
-function doMenu_en(){
-    gxmessage   -font "Sans bold 16" "          Are you sure you want to leave?" -nofocus -center  -borderless \
-    -noescape -sticky -ontop -title "Pick a choice" -default "Cancel" \
-    -buttons "_Cancel":1,"_Lock":2,"_Exit":3,"_Reboot":4,"_Poweroff":5 >/dev/null
-    
-    case $? in
+function doAction(){
+    case $1 in
         1)
             echo "Cancel"
         ;;
@@ -52,32 +22,46 @@ function doMenu_en(){
             exec ~/bin/myshutdown
         ;;
     esac
+}
+
+function doMenu_en(){
+    gxmessage -font "Sans bold 16" "          Are you sure you want to leave?" -nofocus -center -borderless -noescape -sticky -ontop \
+        -title "Pick a choice" -default "Cancel" -buttons "_Cancel":1,"_Lock":2,"_Exit":3,"_Reboot":4,"_Poweroff":5 >/dev/null
+    
+    doAction "$?"
     return 0
 }
 
 function doMenu_pt(){
-    gxmessage   -font "Sans bold 16" "          Tem certeza que quer sair?" -nofocus -center  -borderless \
-    -noescape -sticky -ontop -title "Escolha uma ação" -default "Cancelar" \
-    -buttons "_Cancelar":1,"_Bloquear":2,"_Sair":3,"_Reiniciar":4,"_Desligar":5 >/dev/null
+    gxmessage -font "Sans bold 16" "          Tem certeza que quer sair?" -nofocus -center -borderless -noescape -sticky -ontop \
+        -title "Escolha uma ação" -default "Cancelar" -buttons "_Cancelar":1,"_Bloquear":2,"_Sair":3,"_Reiniciar":4,"_Desligar":5 >/dev/null
+    doAction "$?"
+    return 0
+}
+
+function main() {
+    precheck "gxmessage"
     
-    case $? in
-        1)
-            echo "Ação Cancelada"
-        ;;
-        2)
-            exec ~/bin/mylock lock
-        ;;
-        3)
-            exec ~bin/myexit
-        ;;
-        4)
-            exec ~bin/myreboot
-        ;;
-        5)
-            exec ~/bin/myshutdown
-        ;;
+    # Only works if X is running.
+    if ! is_running_X ; then
+        log "X server is not running";
+        return 0;
+    fi
+    
+    # l10n support
+    case "${LANG:-}" in
+        de_* ) doMenu_en ;; # Deutsch
+        da_* ) doMenu_en ;; # Danish
+        es_* ) doMenu_en ;; # Española
+        fr_* ) doMenu_en ;; # Français
+        id_* ) doMenu_en ;; # Bahasa Indonesia
+        it_* ) doMenu_en ;; # Italian
+        lv_* ) doMenu_en ;; # Latvian
+        pl_* ) doMenu_en ;; # Polish
+        pt_* ) doMenu_pt ;; # Português
+        ru_* ) doMenu_en ;; # Russian
+        * ) doMenu_en ;; # Default to English
     esac
-    return 0
 }
 
-main
\ No newline at end of file
+main "$@"
\ No newline at end of file
diff --git a/bin/ob_root_menu b/bin/ob_root_menu
index e786f057..f950538d 100755
--- a/bin/ob_root_menu
+++ b/bin/ob_root_menu
@@ -1,6 +1,13 @@
 #!/usr/bin/env bash
 
+if [ -f "$HOME/bin/mycommon" ]; then
+    . "$HOME/bin/mycommon"
+fi
+
 function main(){
+    if ! is_running_X ; then
+        return 0;
+    fi
     local DISPLAYH=$(xdpyinfo  | sed 's/^ *dimensions: *[0-9]*x\([0-9]*\).*/\1/;t;d')
     local PANELH=$(sed -e 's/^panel_size = [0-9]* \([0-9]*\).*/\1/;t;d' ~/.config/tint2/tint2rc)
     local MOUSEX=$(xdotool getmouselocation 2> /dev/null | sed -e 's/x://' | awk '{print $1}')
diff --git a/bin/rofi-manual b/bin/rofi-manual
new file mode 100755
index 00000000..e967618f
--- /dev/null
+++ b/bin/rofi-manual
@@ -0,0 +1,3 @@
+#!/usr/bin/env bash
+
+man -k . | awk '{print $1}' | rofi -location 2 -font "Noto Sans 8" -dmenu -line-margin 0 -line-padding 1 -i -p " Manual: " | xargs manp
\ No newline at end of file
diff --git a/bin/rofi-off b/bin/rofi-off
index ef5607cd..dd779106 100755
--- a/bin/rofi-off
+++ b/bin/rofi-off
@@ -1,25 +1,33 @@
 #!/usr/bin/env bash
 
+if [ -f "$HOME/bin/mycommon" ]; then
+    . "$HOME/bin/mycommon"
+fi
+
 function main(){
-    local cmd=$(printf "poweroff\nreboot\nsuspend\nlock\nkillX\n" | rofi -location 2 -font "Noto Sans 8" -dmenu -l 10 -line-margin 0 -line-padding 1 -i -p "Execute:" $*)
+    local cmd=$(printf "logout\npoweroff\nreboot\nsuspend\nlock\n" | rofi -location 2 -font "Noto Sans 8" -dmenu -l 10 -line-margin 0 -line-padding 1 -xoffset 50 -yoffset 20 -width 10 -i -p "Pick a choice:" $*)
     
-    if [ -z "$cmd" ]; then
-        return 0
-    fi
+    [ -z "$cmd" ] && return 0
     
     case "$cmd" in
         poweroff)
-            ~/bin/myshutdown ;;
+            ~/bin/myshutdown
+        ;;
         reboot)
-            ~/bin/myreboot ;;
+            ~/bin/myreboot
+        ;;
         suspend)
-            ~/bin/mysuspend ;;
+            ~/bin/mysuspend
+        ;;
         lock)
-            ~/bin/autolock lock ;;
-        killX)
-            killall X ;;
+            ~/bin/autolock lock
+        ;;
+        logout)
+            ~/bin/myexit
+        ;;
         *)
             printf "Option not recognized: %s\n" "$cmd" >&2
+        ;;
     esac
     return 0
 }
diff --git a/bin/torque b/bin/torque
new file mode 100755
index 00000000..36ae8c1c
--- /dev/null
+++ b/bin/torque
@@ -0,0 +1,63 @@
+#!/usr/bin/env bash
+#
+# Torque - minimal tui for transmission-daemon.
+
+refresh() {
+    printf '\e[?7l\e[?25l\e[2J\e[H'
+    shopt -s checkwinsize; (:;:)
+    [[ -z "$LINES" ]] && read -r LINES COLUMNS < <(stty size)
+    ((j=(LINES-2)/3))
+}
+
+status() {
+    printf '\e[2m\e[%s;H%s\e[m' "$((LINES-1))" "$1"
+}
+
+get_torrents() {
+    IFS=$'\n' read -d "" -ra t < <(transmission-remote -l)
+    unset 't[0]' 't[-1]' 2>/dev/null
+
+    t=("${t[@]//[0-9] [a-z][a-z][a-z]?/.}")
+    t=("${t[@]//Up & Down/Active}")
+    t=("${t[@]//Downloading/Active}")
+    t=("${t[@]//     None/0 MB}")
+
+    for((i=${k:=0};i<(j=j>${#t[@]}?${#t[@]}:j);i++));{ t_print "${t[i]/n\/a/0}";}
+    status "[s]tart [p]ause [r]emove [o]pen [j/k] scroll ($j/${#t[@]})"$'\e[H'
+}
+
+t_print() {
+    IFS=" %" read -r num perc have unit _ up down _ stat name <<< "$1"
+
+    ((size=perc!=0?${have/.*}*100/perc:0,c=perc==100?33271340:31000000))
+
+    printf '\e[K\e[2m%s\e[m \e[1m\e[%s%b%s\e[m\n' \
+           "$num:" "${c:0:2}m" "\\u${c:2:4}\\${c:6}" "$name"
+    printf '\e[K\e7%s\e8\e[14C%s\e8\e[32C%s\e8\e[42C%s\e8\e[52C%s\n\e[K\n' \
+           "   $stat: " "$have / $size $unit" "(${perc}%)" "⇣ $down" "⇡ $up"
+}
+
+prompt() {
+    send() { transmission-remote "$@" >/dev/null; }
+    status $'\e[B\e[?25h'
+
+    case "$1" in
+        s) read -rp "start torrent: #";  send -t "$REPLY" -s ;;
+        p) read -rp "pause torrent: #";  send -t "$REPLY" -S ;;
+        r) read -rp "remove torrent: #"; send -t "$REPLY" -r; k=0 ;;
+        o) read -rp "load magnet: ";     send -a "$REPLY"; k=0 ;;
+        j) ((j==${#t[@]}))||((k=k>=j?k:++k,j=j<${#t[@]}?++j:j)) ;;
+        k) ((k==0))||((k=k<=j?k>0?--k:0:j,j=j>0?--j:j)) ;;
+    esac
+
+    [[ "$1" =~ (j|k) ]] || refresh && printf '\e[?25l\e[H'
+}
+
+main() {
+    refresh
+    trap $'printf \e[?25h\e[?7h\e[999B' EXIT
+    trap  'refresh; k=0' SIGWINCH
+    for ((;;)); { get_torrents; read -rsN1 -t1 && prompt "$REPLY"; }
+}
+
+main
\ No newline at end of file
diff --git a/bin/touchpadctl b/bin/touchpadctl
index 44afb489..d126ddd3 100755
--- a/bin/touchpadctl
+++ b/bin/touchpadctl
@@ -1,97 +1,108 @@
 #!/usr/bin/env bash
 ## $1 = "add" / "remove"
 ## $2 = %k from udev
+set -eu
 
 function usage() {
-    echo "Usage: $0 [Options]"
+    echo "Usage: $(basename $0) [Options]"
     echo "       "
-    echo "Purpose: enable|disable Touchpad"
+    echo "Purpose: To enable or disable Touchpad"
     echo "       "
     echo "Options"
-    echo "-h: Show this help"
-    echo "-d: Disable touchpad"
-    echo "-e: Enable touchpad"
-    echo "-a: Auto enable|disable on mouse plug(in/off)"
-    echo "--disable: Disable touchpad"
-    echo "--enable: Enable touchpad"
+    echo "-h | --help : Show this help"
+    echo "-d | --disable: Disable touchpad"
+    echo "-e | --enable: Enable touchpad"
     return 0;
 }
 
-# Main
-if [ $# -eq 0 ] ; then
-    usage ;
-    /usr/bin/logger -t Touchpadctl -- "No parameters."
-    exit 0
-fi
+function touch_hnd_noX(){
+    case "$1" in
+        -d | --disable)
+            echo -n manual > $base_dir/bind_mode && /usr/bin/logger -t Touchpadctl -- "Disabling the touchpad" || /usr/bin/logger -t Touchpadctl -- "Cannot disable touchpad"
+            echo -n $device_id > $base_dir/unbind 2>/dev/null || true
+        ;;
+        -e | --enable)
+            echo -n auto > $base_dir/bind_mode && /usr/bin/logger -t Touchpadctl -- "Enabling the touchpad" || /usr/bin/logger -t Touchpadctl -- "Cannot enable touchpad"
+        ;;
+        *)  usage
+            exit 0
+        ;;
+    esac
+}
 
-# Option strings
-SHORT=":a::d::e::h"
-LONG=":auto,disable,enable,help"
+function touch_hnd_X(){
+    local usr="$2"
+    local touch_id=$(/usr/bin/xinput list | \egrep -Eo 'Touchpad\s*id\=[0-9]{1,2}' | \egrep -Eo '[0-9]{1,2}')
+    local touch_stt=$(/usr/bin/xinput list-props $touch_id | \grep 'Device Enabled' | \awk '{print $4}')
+    [ $touch_id -eq 0 ] && /usr/bin/logger -t Touchpadctl -- "Touchpad device not found. $usr. ($XAUTHORITY - $DISPLAY)"
+    
+    case "$1" in
+        -a | --auto )
+            local mouse_id="$(xinput list | \egrep -Eo '[Mm]ouse\s*id\=[0-9]{1,2}' | \egrep -Eo '[0-9]{1,2}')"
+            local mouse_stt=$(/usr/bin/xinput list-props $mouse_id | \grep 'Device Enabled' | \awk '{print $4}')
+            if [ $mouse_id -ne 0 ] && [ $mouse_stt -eq 1 ]; then
+                /usr/bin/xinput disable $touch_id
+                /usr/bin/logger -t Touchpadctl -- "Additional external mice found. Touchpad disabled for $usr. ($XAUTHORITY - $DISPLAY)"
+            else
+                /usr/bin/xinput enable $touch_id
+                /usr/bin/logger -t Touchpadctl -- "Additional external mice not found. Touchpad enabled for $usr. ($XAUTHORITY - $DISPLAY)"
+            fi
+        ;;
+        -d | --disable )
+            if [ $touch_stt -eq 1 ]; then
+                /usr/bin/xinput disable $touch_id
+                /usr/bin/logger -t Touchpadctl -- "Disabling touchpad for $usr. ($XAUTHORITY - $DISPLAY)"
+            else
+                /usr/bin/logger -t Touchpadctl -- "Touchpad already disabled for $usr. ($XAUTHORITY - $DISPLAY)"
+            fi
+        ;;
+        -e | --enable )
+            if [ $touch_stt -eq 0 ]; then
+                /usr/bin/xinput enable $touch_id
+                /usr/bin/logger -t Touchpadctl -- "Enabling touchpad for $usr. ($XAUTHORITY - $DISPLAY)"
+            else
+                /usr/bin/logger -t Touchpadctl -- "Touchpad already enabled for $usr. ($XAUTHORITY - $DISPLAY)"
+            fi
+        ;;
+        *)  usage
+            exit 0
+        ;;
+    esac
+}
 
-# Read the options
-OPTS=$(getopt --options $SHORT --long $LONG --name "$0" -- "$@")
-if [ $? -ne 0 ] ; then
-    usage ;
-    /usr/bin/logger -t Touchpadctl -- "Wrong parameters.[ $* ]"
-    exit 0
-fi
+user_list="$(w -h | cut -d' ' -f1 | sort | uniq)"
+user_id="$(id -u)"
+base_dir=/sys/bus/serio/drivers/psmouse
+device_id=serio1
 
-# Obtain user list
-USERLIST=$(w -h | cut -d' ' -f1 | sort | uniq)
-for CUR_USER in ${USERLIST}; do
-    CUR_USER_XAUTH="$(sudo -Hiu "${CUR_USER}" env | grep -e "^HOME=" | cut -d'=' -f2)/.Xauthority"
-    ## Can't find a way to get another users DISPLAY variable from an isolated root environment. Have to set it manually.
-    CUR_USER_DISPL="$(sudo -Hiu "${CUR_USER}" env | grep -e "^DISPLAY=" | cut -d'=' -f2)"
-    [ -z "$CUR_USER_DISPL" ] && CUR_USER_DISPL=":0"
-    
-    export XAUTHORITY="${CUR_USER_XAUTH}"
-    export DISPLAY="${CUR_USER_DISPL}"
-    
-    # Check running X
-    if ! xset q &>/dev/null; then
-        /usr/bin/logger -t Touchpadctl -- "Xserver is not running."
-        exit 0
+function main(){
+    if [ $# -eq 0 ]; then
+        usage
+        exit 1
     fi
     
-    if [ -f "${CUR_USER_XAUTH}" ]; then
-        declare -i ID
-        ID=$(/usr/bin/xinput list | \egrep -Eo 'Touchpad\s*id\=[0-9]{1,2}' | \egrep -Eo '[0-9]{1,2}')''
-        declare -i STATE
-        STATE=$(/usr/bin/xinput list-props $ID | \grep 'Device Enabled' | \awk '{print $4}')
-        
-        case "$1" in
-            -a | --auto )
-                xinput list | \egrep -Eo '[Mm]ouse\s*id\=[0-9]{1,2}' | \egrep -Eo '[0-9]{1,2}' &>/dev/null
-                if [ $? -eq 0 ] ; then
-                    /usr/bin/xinput disable $ID
-                    /usr/bin/logger -t Touchpadctl -- "Additional external mice found. Touchpad disabled for $CUR_USER. ($XAUTHORITY - $DISPLAY)"
-                else
-                    /usr/bin/xinput enable $ID
-                    /usr/bin/logger -t Touchpadctl -- "Additional external mice not found. Touchpad enabled for $CUR_USER. ($XAUTHORITY - $DISPLAY)"
-                fi
-            ;;
-            -d | --disable )
-                if [ $STATE -eq 1 ]; then
-                    /usr/bin/xinput disable $ID
-                    /usr/bin/logger -t Touchpadctl -- "Disabling touchpad for $CUR_USER. ($XAUTHORITY - $DISPLAY)"
-                else
-                    /usr/bin/logger -t Touchpadctl -- "Touchpad already disabled for $CUR_USER. ($XAUTHORITY - $DISPLAY)"
-                fi
-            ;;
-            -e | --enable )
-                xinput list | \egrep -Eo '[Mm]ouse\s*id\=[0-9]{1,2}' | \egrep -Eo '[0-9]{1,2}' &>/dev/null
-                if [ $? -eq 0 ] ; then
-                    /usr/bin/logger -t Touchpadctl -- "Additional external mice found. Touchpad not enabled for $CUR_USER. ($XAUTHORITY - $DISPLAY)"
-                    exit 0
-                fi
-                if [ $STATE -eq 0 ]; then
-                    /usr/bin/xinput enable $ID
-                    /usr/bin/logger -t Touchpadctl -- "No additional external mice found. Enabling touchpad for $CUR_USER. ($XAUTHORITY - $DISPLAY)"
-                else
-                    /usr/bin/logger -t Touchpadctl -- "Touchpad already enabled for $CUR_USER. ($XAUTHORITY - $DISPLAY)"
-                fi
-            ;;
-            *)  usage; exit;;
-        esac
-    fi
-done
+    for u in ${user_list}; do
+        ## Can't find a way to get another users DISPLAY variable from an isolated root environment. Have to set it manually.
+        displ="$(sudo -Hiu "${u}" env | grep -e "^DISPLAY=" | cut -d'=' -f2)"
+        [ -z "$displ" ] && displ=":0"
+        export XAUTHORITY="$(sudo -Hiu "${u}" env | grep -e "^HOME=" | cut -d'=' -f2)/.Xauthority"
+        export DISPLAY="${displ}"
+        if [ -f "${XAUTHORITY}" ]; then
+            # Check running X
+            if ! xset q &>/dev/null; then
+                /usr/bin/logger -t Touchpadctl -- "Xserver is not running."
+                touch_hnd_noX "$1" "$u"
+            else
+                /usr/bin/logger -t Touchpadctl -- "Xserver is running."
+                touch_hnd_X "$1" "$u"
+            fi
+        fi
+    done
+}
+
+main "$@"
+
+unset user_list
+unset user_id
+unset base_dir
+unset device_id
diff --git a/bin/wpctl b/bin/wpctl
index a7c5a355..a06ddd8f 100755
--- a/bin/wpctl
+++ b/bin/wpctl
@@ -1,6 +1,6 @@
 #!/usr/bin/env bash
 #
-# [wp] - simple X wallpaper setter with optional
+# [wpctl] - simple X wallpaper setter with optional
 # interactive mode and save/restore functionality.
 #
 # Copyright 2016-2018 Armin Jenewein (@netzverweigerer on GitHub)
@@ -23,8 +23,8 @@ if [ -f "$HOME/bin/mycommon" ]; then
     . "$HOME/bin/mycommon"
 fi
 
-# This displays the "[wp] " prefix (coloured, if possible)
-function banner() {
+# This displays the "[wpctl] " prefix (coloured, if possible)
+function banner(){
     tput setaf 12
     echo -n "["
     tput setaf 7
@@ -35,9 +35,9 @@ function banner() {
     echo -n " "
 }
 
-function usage() {
+function usage(){
     echo -n "USAGE: "
-    echo "wp [OPTIONS]"
+    echo "wpctl [OPTIONS]"
     echo ""
     echo "OPTIONS: "
     echo "--set|-s <file>           Sets <file> as wallpaper image"
@@ -52,21 +52,15 @@ function usage() {
 }
 
 # Sets a wallpaper
-function set() {
-    if [ -z "$1" ]; then
-        echo "Specify filename to set"
-        return 1
-    fi
-    file="$1"
-    f="$(readlink -f $file)"
+function set(){
+    [ -z "$1" ] && echo "Specify filename to set" && return 1
+    local file="$1"
+    local f="$(readlink -f $file)"
     mkdir -p $HOME/.cache/wp
     echo "Setting wallpaper: ${f##*/}"
-    if [ $(command -v nitrogen) ]; then
-        nitrogen --set-scaled --save "$file" && banner
-    else
-        feh --no-fehbg --bg-fill "$file" && banner
-    fi
-    ts="/tmp/.wp.selection.${USER}"
+    checkfor "nitrogen" && nitrogen --set-scaled --save "$file" || feh --no-fehbg --bg-fill "$file"
+    banner
+    local ts="/tmp/.wp.selection.${USER}"
     echo "Temporarily storing wallpaper selection: $ts"
     banner
     echo "Use --save to store it permanently."
@@ -76,13 +70,15 @@ function set() {
 # Saves the currently selected (temporary) wallpaper. This just writes the
 # filename to ~/.wp/current (wp will exit with return code 200 if no
 # wallpaper has been temporarily set prior).
-function save() {
+function save(){
     if [[ ! -f /tmp/.wp.selection.${USER} ]]; then
+        checkfor "nitrogen" && return 0
         banner
         echo "No temporarily stored wallpaper selection found."
         exit 200
     else
-        f="$(tail -n 1 /tmp/.wp.selection.${USER})"
+        local f="$(tail -n 1 /tmp/.wp.selection.${USER})"
+        banner
         echo "Storing wallpaper selection to ~/.cache/wp/current ..."
         echo "$f" > $HOME/.cache/wp/current
     fi
@@ -90,18 +86,17 @@ function save() {
 
 # This gets the currently *saved* wallpaper selection (which can be
 # different from a wallpaper that has just been set, but not saved, yet).
-function get() {
+function get(){
     cat $HOME/.cache/wp/current
 }
 
 # Restores the last saved wallpaper
-function restore() {
-    banner
-    set "$(tail -n 1 $HOME/.cache/wp/current)"
+function restore(){
+    checkfor "nitrogen" && nitrogen --restore || banner && set "$(tail -n 1 $HOME/.cache/wp/current)"
 }
 
 # Sets a random wallpaper
-function random() {
+function random(){
     local ldir="$1"
     local recur="$2"
     echo "Using wallpaper directory: $ldir"
@@ -133,7 +128,7 @@ function random() {
 }
 
 # Used for interactive selection mode
-function handler() {
+function handler(){
     read -s -n 1 reply
     case "$reply" in
         n)
@@ -147,7 +142,7 @@ function handler() {
 }
 
 # Interactive mode
-function interactive() {
+function interactive(){
     echo "Interactive Mode. Keys: [n]ext [q]uit"
     while true; do
         banner
@@ -155,47 +150,53 @@ function interactive() {
     done
 }
 
-function main() {
+function main(){
+    precheck "feh"
+    precheck "tail"
+    
     # Path to wallpaper directory (this is likely the only thing you need to change...)
     local dir="$XDG_PICTURES_DIR/Wallpaper"
     
     # We use non-recursive mode, unless specified otherwise (-r|--recursive)
     local recursive=0
     
-    precheck "feh"
-    precheck "tail"
-    
-    banner
-    
     # Parse arguments
     case "$1" in
         --set|-s)
             shift
+            banner
             set "$1"
         ;;
         --get|-g)
+            banner
             get
         ;;
         --random|-z)
+            banner
             random "$dir" "$recursive"
         ;;
         --recursive|-e)
             recursive=1
+            banner
             random "$dir" "$recursive"
         ;;
         --restore|-t)
+            banner
             restore
         ;;
         --save|-x)
+            banner
             save
         ;;
         --interactive|-i)
+            banner
             interactive "$dir" "$recursive"
         ;;
         --help|--usage|-h|--)
             usage
         ;;
         '')
+            banner
             echo "No option specified. Setting a random wallpaper."
             banner
             echo "Use --help for usage help."
@@ -206,6 +207,7 @@ function main() {
             usage
         ;;
     esac
+    exit 0
 }
 
 main "$@"
\ No newline at end of file
